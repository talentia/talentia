[
    {
        "id": 123598,
        "uuid": "8061a16e46c558c5c8de",
        "user": {
            "id": 6090,
            "url_name": "guicho271828",
            "profile_image_url": "https://pbs.twimg.com/profile_images/378800000809306716/dbd9008f86c426eb255aadb7fb0b9769_normal.jpeg"
        },
        "title": "bashで関数プログラミングしたらlispになった",
        "created_at": "2014-09-02 17:45:12 +0900",
        "updated_at": "2014-09-03 08:10:50 +0900",
        "created_at_in_words": "21日",
        "updated_at_in_words": "20日",
        "tags": [
            {
                "name": "Bash",
                "url_name": "bash",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/005e4b716bc85c3e4f1a6cc3fcbcdc4560866392/medium.jpg?1364838255",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            }
        ],
        "stock_count": 3,
        "comment_count": 0,
        "url": "http://qiita.com/guicho271828/items/8061a16e46c558c5c8de",
        "created_at_as_seconds": 1409647512,
        "tweet": false,
        "gist_url": null,
        "private": false,
        "raw_body": "使い方:\n\n```bash\n$ map $(lambda a -- echo \"\\$(( 1 + \\$a ))\") 1 2 3\n2\n3\n4\n```\n\n実用的には\n\n```bash\ncountline (){\n    wc -l $1 | cut -d \" \" -f 1\n}\nrealcost=$(min $(map countline $(ls $probname.$config.plan.*)))\n```\nとか。\n\nシンタックスを考えると、シェルスクリプトで良い点は変数と文字列の垣根が低い点、悪い点は正則評価しか無い点(`$var` は呼び出し前に必ず展開される == 必ず評価される)、シンボルを作りにくい点。lambdaを実用しやすくするには 変数の記述方法を変えて、あとで`$`記号に変換するようにしないといけないかなあ。問題は余ってる記号が少ないこと。`\"#$%&'()=~|@{[}]<>?` 使えそうなのはだいたい使われてるなあ。残ってるのは @ と _ だな。 @ かな。\n\n```bash\n\nmap (){\n    pred=$1\n    first=$2\n    shift 2\n    echo $($pred $first)\n    if [[ $1 != \"\" ]]\n    then\n        map $pred $@\n    fi\n}\n\nreduce (){                         # list of numbers\n    if [[ $3 == \"\" ]]\n    then\n        echo $2\n    else\n        pred=$1\n        first=$2\n        second=$3\n        shift 3\n        next=$($pred $first $second)\n        reduce $pred $next $@\n    fi\n}\n\ngensym (){ mktemp --tmpdir lambda.XXXXXXXX; }\nlocaldef (){ echo \"$1=$2;\" ;}\nlocaldefs (){\n    local i=0\n    for arg in $@\n    do\n        i=$(( $i + 1 ))\n        localdef $arg \"\\$$i\"\n    done\n}\nlambda (){\n    local sym=$(gensym)\n    local args=\n    while [[ $1 != \"--\" ]]\n    do\n        args=\"$args $1\"\n        shift\n    done\n    shift\n    echo \"#!/bin/bash\" > $sym\n    localdefs $args >> $sym\n    echo \"{ $* ;}\" >> $sym\n    chmod +x $sym\n    echo $sym\n}\n\ngt (){ if [[ $1 -gt $2 ]] ; then echo $1 ; else echo $2 ; fi }\nlt (){ if [[ $1 -lt $2 ]] ; then echo $1 ; else echo $2 ; fi }\nge (){ if [[ $1 -ge $2 ]] ; then echo $1 ; else echo $2 ; fi }\nle (){ if [[ $1 -le $2 ]] ; then echo $1 ; else echo $2 ; fi }\nmax (){\n    reduce gt $@\n}\nmin (){\n    reduce lt $@\n}\n```\n",
        "body": "<p>使い方:</p>\n<div class=\"code-frame\" data-lang=\"bash\"><div class=\"highlight\"><pre><span class=\"nv\">$ </span>map <span class=\"k\">$(</span>lambda a -- <span class=\"nb\">echo</span> <span class=\"s2\">&quot;\\$(( 1 + \\$a ))&quot;</span><span class=\"k\">)</span> <span class=\"m\">1</span> <span class=\"m\">2</span> 3\n2\n3\n4\n</pre></div></div><p>実用的には</p>\n<div class=\"code-frame\" data-lang=\"bash\"><div class=\"highlight\"><pre>countline <span class=\"o\">(){</span>\n    wc -l <span class=\"nv\">$1</span> <span class=\"p\">|</span> cut -d <span class=\"s2\">&quot; &quot;</span> -f 1\n<span class=\"o\">}</span>\n<span class=\"nv\">realcost</span><span class=\"o\">=</span><span class=\"k\">$(</span>min <span class=\"k\">$(</span>map countline <span class=\"k\">$(</span>ls <span class=\"nv\">$probname</span>.<span class=\"nv\">$config</span>.plan.*<span class=\"k\">)))</span>\n</pre></div></div><p>とか。</p>\n<p>シンタックスを考えると、シェルスクリプトで良い点は変数と文字列の垣根が低い点、悪い点は正則評価しか無い点(<code>$var</code> は呼び出し前に必ず展開される == 必ず評価される)、シンボルを作りにくい点。lambdaを実用しやすくするには 変数の記述方法を変えて、あとで<code>$</code>記号に変換するようにしないといけないかなあ。問題は余ってる記号が少ないこと。<code>&quot;#$%&amp;&#39;()=~|@{[}]&lt;&gt;?</code> 使えそうなのはだいたい使われてるなあ。残ってるのは @ と _ だな。 @ かな。</p>\n<div class=\"code-frame\" data-lang=\"bash\"><div class=\"highlight\"><pre>map <span class=\"o\">(){</span>\n    <span class=\"nv\">pred</span><span class=\"o\">=</span><span class=\"nv\">$1</span>\n    <span class=\"nv\">first</span><span class=\"o\">=</span><span class=\"nv\">$2</span>\n    <span class=\"nb\">shift </span>2\n    <span class=\"nb\">echo</span> <span class=\"k\">$(</span><span class=\"nv\">$pred</span> <span class=\"nv\">$first</span><span class=\"k\">)</span>\n    <span class=\"k\">if</span> <span class=\"o\">[[</span> <span class=\"nv\">$1</span> !<span class=\"o\">=</span> <span class=\"s2\">&quot;&quot;</span> <span class=\"o\">]]</span>\n    <span class=\"k\">then</span>\n        map <span class=\"nv\">$pred</span> <span class=\"nv\">$@</span>\n    <span class=\"k\">fi</span>\n<span class=\"o\">}</span>\n\nreduce <span class=\"o\">(){</span>                         <span class=\"c\"># list of numbers</span>\n    <span class=\"k\">if</span> <span class=\"o\">[[</span> <span class=\"nv\">$3</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;&quot;</span> <span class=\"o\">]]</span>\n    <span class=\"k\">then</span>\n        <span class=\"nb\">echo</span> <span class=\"nv\">$2</span>\n    <span class=\"k\">else</span>\n        <span class=\"nv\">pred</span><span class=\"o\">=</span><span class=\"nv\">$1</span>\n        <span class=\"nv\">first</span><span class=\"o\">=</span><span class=\"nv\">$2</span>\n        <span class=\"nv\">second</span><span class=\"o\">=</span><span class=\"nv\">$3</span>\n        <span class=\"nb\">shift </span>3\n        <span class=\"nv\">next</span><span class=\"o\">=</span><span class=\"k\">$(</span><span class=\"nv\">$pred</span> <span class=\"nv\">$first</span> <span class=\"nv\">$second</span><span class=\"k\">)</span>\n        reduce <span class=\"nv\">$pred</span> <span class=\"nv\">$next</span> <span class=\"nv\">$@</span>\n    <span class=\"k\">fi</span>\n<span class=\"o\">}</span>\n\ngensym <span class=\"o\">(){</span> mktemp --tmpdir lambda.XXXXXXXX<span class=\"p\">;</span> <span class=\"o\">}</span>\nlocaldef <span class=\"o\">(){</span> <span class=\"nb\">echo</span> <span class=\"s2\">&quot;$1=$2;&quot;</span> <span class=\"p\">;</span><span class=\"o\">}</span>\nlocaldefs <span class=\"o\">(){</span>\n    <span class=\"nb\">local </span><span class=\"nv\">i</span><span class=\"o\">=</span>0\n    <span class=\"k\">for</span> arg in <span class=\"nv\">$@</span>\n    <span class=\"k\">do</span>\n        <span class=\"nv\">i</span><span class=\"o\">=</span><span class=\"k\">$((</span> <span class=\"nv\">$i</span> <span class=\"o\">+</span> <span class=\"m\">1</span> <span class=\"k\">))</span>\n        localdef <span class=\"nv\">$arg</span> <span class=\"s2\">&quot;\\$$i&quot;</span>\n    <span class=\"k\">done</span>\n<span class=\"o\">}</span>\nlambda <span class=\"o\">(){</span>\n    <span class=\"nb\">local </span><span class=\"nv\">sym</span><span class=\"o\">=</span><span class=\"k\">$(</span>gensym<span class=\"k\">)</span>\n    <span class=\"nb\">local </span><span class=\"nv\">args</span><span class=\"o\">=</span>\n    <span class=\"k\">while</span> <span class=\"o\">[[</span> <span class=\"nv\">$1</span> !<span class=\"o\">=</span> <span class=\"s2\">&quot;--&quot;</span> <span class=\"o\">]]</span>\n    <span class=\"k\">do</span>\n        <span class=\"nv\">args</span><span class=\"o\">=</span><span class=\"s2\">&quot;$args $1&quot;</span>\n        <span class=\"nb\">shift</span>\n<span class=\"nb\">    </span><span class=\"k\">done</span>\n    <span class=\"nb\">shift</span>\n<span class=\"nb\">    echo</span> <span class=\"s2\">&quot;#!/bin/bash&quot;</span> &gt; <span class=\"nv\">$sym</span>\n    localdefs <span class=\"nv\">$args</span> &gt;&gt; <span class=\"nv\">$sym</span>\n    <span class=\"nb\">echo</span> <span class=\"s2\">&quot;{ $* ;}&quot;</span> &gt;&gt; <span class=\"nv\">$sym</span>\n    chmod +x <span class=\"nv\">$sym</span>\n    <span class=\"nb\">echo</span> <span class=\"nv\">$sym</span>\n<span class=\"o\">}</span>\n\ngt <span class=\"o\">(){</span> <span class=\"k\">if</span> <span class=\"o\">[[</span> <span class=\"nv\">$1</span> -gt <span class=\"nv\">$2</span> <span class=\"o\">]]</span> <span class=\"p\">;</span> <span class=\"k\">then</span> <span class=\"nb\">echo</span> <span class=\"nv\">$1</span> <span class=\"p\">;</span> <span class=\"k\">else</span> <span class=\"nb\">echo</span> <span class=\"nv\">$2</span> <span class=\"p\">;</span> <span class=\"k\">fi</span> <span class=\"o\">}</span>\nlt <span class=\"o\">(){</span> <span class=\"k\">if</span> <span class=\"o\">[[</span> <span class=\"nv\">$1</span> -lt <span class=\"nv\">$2</span> <span class=\"o\">]]</span> <span class=\"p\">;</span> <span class=\"k\">then</span> <span class=\"nb\">echo</span> <span class=\"nv\">$1</span> <span class=\"p\">;</span> <span class=\"k\">else</span> <span class=\"nb\">echo</span> <span class=\"nv\">$2</span> <span class=\"p\">;</span> <span class=\"k\">fi</span> <span class=\"o\">}</span>\nge <span class=\"o\">(){</span> <span class=\"k\">if</span> <span class=\"o\">[[</span> <span class=\"nv\">$1</span> -ge <span class=\"nv\">$2</span> <span class=\"o\">]]</span> <span class=\"p\">;</span> <span class=\"k\">then</span> <span class=\"nb\">echo</span> <span class=\"nv\">$1</span> <span class=\"p\">;</span> <span class=\"k\">else</span> <span class=\"nb\">echo</span> <span class=\"nv\">$2</span> <span class=\"p\">;</span> <span class=\"k\">fi</span> <span class=\"o\">}</span>\nle <span class=\"o\">(){</span> <span class=\"k\">if</span> <span class=\"o\">[[</span> <span class=\"nv\">$1</span> -le <span class=\"nv\">$2</span> <span class=\"o\">]]</span> <span class=\"p\">;</span> <span class=\"k\">then</span> <span class=\"nb\">echo</span> <span class=\"nv\">$1</span> <span class=\"p\">;</span> <span class=\"k\">else</span> <span class=\"nb\">echo</span> <span class=\"nv\">$2</span> <span class=\"p\">;</span> <span class=\"k\">fi</span> <span class=\"o\">}</span>\nmax <span class=\"o\">(){</span>\n    reduce gt <span class=\"nv\">$@</span>\n<span class=\"o\">}</span>\nmin <span class=\"o\">(){</span>\n    reduce lt <span class=\"nv\">$@</span>\n<span class=\"o\">}</span>\n</pre></div></div>",
        "stock_users": [
            "Viarofka",
            "HirofumiYashima",
            "kasumani"
        ]
    },
    {
        "id": 115379,
        "uuid": "8c0e0a6bd9f756c0a353",
        "user": {
            "id": 32706,
            "url_name": "torub",
            "profile_image_url": "https://0.gravatar.com/avatar/2d4540c8e2ebe1766d9924014325ff07?d=https%3A%2F%2Fidenticons.github.com%2F268be40dd59b91110e0485d4f3ccca3d.png&r=x"
        },
        "title": "Swift で Lisp のインタプリタを作ってみる",
        "created_at": "2014-08-22 00:25:12 +0900",
        "updated_at": "2014-08-22 00:25:12 +0900",
        "created_at_in_words": "約1ヶ月",
        "updated_at_in_words": "約1ヶ月",
        "tags": [
            {
                "name": "Swift",
                "url_name": "swift",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/8924010780db484a83145542a3e49c6c2084ecb7/medium.jpg?1401738498",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "Xcode",
                "url_name": "xcode",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/c2fe3930fd953acbf56980b133119c7b78d7b922/medium.jpg?1388346193",
                "versions": []
            },
            {
                "name": "Xcode6",
                "url_name": "xcode6",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            }
        ],
        "stock_count": 11,
        "comment_count": 2,
        "url": "http://qiita.com/torub/items/8c0e0a6bd9f756c0a353",
        "created_at_as_seconds": 1408634712,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "Swift の勉強のため，Lisp のインタプリタもどきを作ってみました．\n参考にしたのは，[Arc](http://old.ycombinator.com/arc/tut.txt) という Lisp の方言ですが，全く作り込めていないため，「もどき」です．作成したソースは[github](https://github.com/torub/SwiftLisp)上に置いてあります．\niPhone アプリではなく，Mac のコマンドラインアプリとして作成しています．\n\n現時点では以下の程度しかできません．\n\n- car, cdr, list, quote, lambda式\n- 変数の定義には \"=\" を使う\n    * (= x 1)\n    * (= y (lambda (z) (list z z z)))\n\n\n今回作ってみたものの基本的な流れは，\n\n1. Lisp の型を表すクラスの作成\n2. 標準入力から文字列をパースする\n3. パースした内容を Lisp のオブジェクトに変換\n4. Lisp のオブジェクトに対して eval を呼び出して評価\n\nとなります．\n\n## 1. Lisp の型を表すクラスの作成\n- Nil，文字列，シンボル，数字，リストと，環境を表すクラスを作成しました\n\n#### LispObj プロトコル\n- 共通の protocol として LispObj を持つようにしています\n- LispObj は，良く使うリスト型かどうかをチェックする listp と，画面表示に使う toStr のみを定義しました\n- protocol が Java でいうインターフェイスにあたるものだと理解しています\n\n```Swift\nprotocol LispObj {\n    func toStr() -> String\n    func listp() -> ConsCell?\n}\n```\n\n- Swift ではプログラム中に「?」マークを付けると，nil を許容することが出来るという仕様のようです\n- Optionals と呼ばれているようです\n- ?が付いてない関数では nil を返そうとするとコンパイルエラーになった気がします\n- 似た機能として，キャストが可能であれば実施するが，出来なければしない，というのを  as? で表します\n- 以下のような感じで結構多用してしまいました．正しいかはよくわかりません\n\n```Swift\nif let hoge = foo as? Hoge {  // foo が Hoge にキャスト可能ならキャスト\n  // hoge を Hoge 型として利用する\n} else {\n  // キャスト不可だった場合の処理をこっちに書く(hoge は使えない)\n}\n```\n\n#### Nil クラス\n- Singleton の例として[ここ](http://qiita.com/1024jp/items/3a7bc437af3e79f74505)を参考にさせて頂きました．\n\n```Swift\nclass Nil: LispObj {\n    init() {\n    }\n    \n    class var sharedInstance: Nil {\n        struct Singleton {\n            private static let instance = Nil()\n        }\n        return Singleton.instance\n    }\n    \n    func toStr() -> String {\n        return \"nil\";\n    }\n    \n    func listp() -> ConsCell? {\n        return nil;\n    }\n}\n```\n\n#### Symbol クラス\n- 特に何の工夫も無いクラスです\n- LispNum と LispStr もほぼ同じ内容です\n\n```Swift\nclass Symbol: LispObj {\n    var name: String;\n    init(name: String) {\n        self.name = name;\n    }\n    \n    func toStr() -> String {\n        return name;\n    }\n\n    func listp() -> ConsCell? {\n        return nil;\n    }\n}\n\n```\n\n#### Error クラス\n- Swift には例外が無いっぽいので，エラーのハンドリング用に Error クラスを作成しました\n- 中身は Symbol とほぼ同じです．もう少しいいやり方がありそうな気もします．．\n\n```Swift\nclass Error: LispObj {\n    var message: String;\n    init(message: String) {\n        self.message = message;\n    }\n    \n    func toStr() -> String {\n        return \"Error: \" + message;\n    }\n    \n    func listp() -> ConsCell? {\n        return nil;\n    }\n}\n```\n\n#### ConsCell クラス\n- Lisp のリストを表わすために作成\n- car 部と cdr 部としてそれぞれLispObjectを持つようにした他，toStr は[ちょっと変わったLisp入門](http://www.atmarkit.co.jp/ait/articles/0810/31/news148.html)を参考に作成しました．\n\n```Swift\nclass ConsCell: LispObj {\n    var car: LispObj;\n    var cdr: LispObj;\n    \n    init(car: LispObj, cdr: LispObj) {\n        self.car = car;\n        self.cdr = cdr;\n    }\n    \n    func toStr() -> String {\n        var returnValue: String = \"\";\n        \n        returnValue += \"(\";\n        \n        var tmpcell = self;\n        \n        while (true) {\n            returnValue += tmpcell.car.toStr();\n            \n            if let cdrcell = tmpcell.cdr.listp() {\n                tmpcell = cdrcell;\n            } else if tmpcell.cdr is Nil {\n                break;\n            } else { //if tmpcell.cdr.isAtom() {\n                returnValue += \".\";\n                returnValue += tmpcell.cdr.toStr();\n                break;\n            }\n            returnValue += \" \";\n        }\n        returnValue += \")\"\n        \n        return returnValue;\n    }\n    \n    func listp() -> ConsCell? {\n        return self;\n    }\n}\n```\n\n## 2. 標準入力から文字列をパースする\n#### 標準入力から文字列取得\n- [ここ](http://stackoverflow.com/questions/24004776/input-from-the-keyboard-in-command-line-application)を参考に，以下のような関数を作りました\n- カーソルキー等にも入力値が割り当てられているようで，以下の呼び出し時に押すと，予期しない動作になったりします\n\n```Swift\nfunc read() -> String {\n    var tmp = NSFileHandle.fileHandleWithStandardInput();\n\n    var rawdata = tmp.availableData;\n    var str = NSString(data: rawdata, encoding: NSUTF8StringEncoding);\n    \n    return str;\n}\n```\n\n#### 取得した文字列を配列に変換\n- 必要な要素毎に分割して配列に入力しています\n- 文字列操作の関数があまり出揃っていない模様で，細かい処理がやりづらいです\n- Lisp では quote 記号が特別な意味を持つので，変換処理も加えています\n\n```Swift\n// 解析結果のトークンリストを入れる配列\nvar tokenlist: [String] = [];\n\n// どこまで読み込んだかを表す配列\nvar tokenIndex = 0;\n\nfunc tokenize(str: String) { //-> ([String], Int) {\n    // ' (quote記号を (quote  ... ) に置き換え\n    \n    var str2 = \"\"\n    var quoteFlag = false\n    for a in str {\n        if a == \"'\" {\n            str2 += \"(quote \"\n            quoteFlag = true\n        } else if a == \")\" && quoteFlag {\n            str2 += \"))\"\n            quoteFlag = false;\n        } else {\n            str2 += a\n        }\n    }\n\n    // \"(\" と \")\" を空白付きに変換\n    let replacedStr = str2\n        .stringByReplacingOccurrencesOfString(\"(\", withString: \" ( \", options: nil, range: nil)\n        .stringByReplacingOccurrencesOfString(\")\", withString: \" ) \", options: nil, range: nil)\n        .stringByReplacingOccurrencesOfString(\"\\n\", withString: \" \", options: nil, range: nil);\n\n    tokenlist = replacedStr.componentsSeparatedByString(\" \");\n    tokenIndex = 0;\n}\n```\n\n## 3. パースした内容を Lisp のオブジェクトに変換\n- ここまでで，パースした Lisp のプログラムが配列に格納されているため，LispObj に変換する\n- リストではない場合は，Intにキャスト可能かや，セミコロンで囲われているか等を確認して対応する型に変換\n- リストの表現の場合はリスト型のオブジェクトを作成する\n\n```Swift\nfunc parse() -> LispObj {\n    var c: LispObj;\n    c = read_next(get_token());\n    return c;\n}\nfunc read_next(var token: String) -> LispObj {\n    var carexp: LispObj, cdrexp: LispObj;\n    var list: LispObj = NIL;\n    \n    if token == \"\" {\n        return NIL;\n    }\n    if (token != \"(\") {  // \"(\" じゃないときの処理\n        if let n = token.toInt() {\n            return LispNum(value: n);\n        } else {\n            let prefix = token.hasPrefix(\"\\\"\");\n            let suffix = token.hasSuffix(\"\\\"\");\n            let length = token.utf16Count;\n            \n            if prefix && suffix {  // \"hogehoge\" のようにセミコロンで囲われている場合\n                if length > 2 {\n                    return LispStr(value: token[1...token.utf16Count-2]);\n                } else {\n                    return LispStr(value: \"\");\n                }\n            } else if prefix || suffix {  // \"hogehoge のように片方だけセミコロンが付いている場合\n                return Error(message: \"wrong String:\" + token);\n            } else {\n                return Symbol(name: token);\n            }\n        }\n    }\n    \n    token = get_token();  // ( の次のトークンを取得\n    while (true) {  // \"(\" から始まるとき\n        if (token == \")\") {\n            return list;\n        }\n        \n        carexp = read_next(token);  // 読み込んだトークンをcar部分として処理\n        token = get_token();     // 次のトークン取得\n        if (token == \".\") {       // ペアの場合\n            token = get_token();\n            cdrexp = read_next(token);  // 取得した次のトークンを cdr にセット\n            token = get_token();   // ペアの後は ) がくるはず\n            if token != \")\" {\n                println(\") required!\");\n            }\n            return ConsCell(car: carexp, cdr: cdrexp);\n        }\n        list = concat(list, cons(carexp, NIL));\n    }\n}\n```\n\n## 4. Lisp のオブジェクトに対して eval を呼び出して評価\n- 3までで作成した LispObj を与えられた環境の元で評価する\n- 昔作った[Lisp in Arc](https://gist.github.com/torub/a0f8aca789a44f6a5f92)を参考に実装\n- 環境は Dictonary 型を使い，名前と値を紐付けする\n- クロージャを使う場合は，Dictonary をグローバルのものとクロージャ内のものに分けて扱う\n\n```Swift\nfunc eval(exp: LispObj, env: Environment) -> LispObj {\n    if exp is Error {\n        return exp;\n    }\n    if exp is Nil || exp is LispNum {  // Nilまたは数値の場合はそのまま返す\n        return exp;\n    }\n    if exp is LispStr { // または文字列の場合もそのまま返す(エディタがエラーになるため、 || の連結は禁止\n        return exp;\n    }\n    if let symbol = exp as? Symbol {  // シンボルならば環境の値を検索して返す\n        var value = get(symbol.name, env);\n        if !(value is Nil) {\n            return value;\n        } else {\n            return Error(message: \"Undefined Value: \" + symbol.name);\n        }\n    }\n    \n    if let consexp = exp.listp() {\n        return apply(consexp.car, consexp.cdr, env);\n    }\n    \n    return Error(message: \"something wrong!\");\n}\n\nfunc apply(operator_var: LispObj, operand: LispObj, env: Environment) -> LispObj {\n    let operator_body = eval(operator_var, env);\n    \n    let tmp = operand;\n    if eq(car(operator_body), PRIMITIVE) {  // プリミティブ関数の場合の処理\n        switch cdr(operator_body).toStr() {\n        case \"car\":\n            return car(eval(car(operand), env));\n        case \"cdr\":\n            return cdr(eval(car(operand), env));\n        case \"=\":\n            // (= x 10)\n            // (= y \"test\")\n            // (= z (+ 1 2))\n            if let variable = car(operand) as? Symbol {  // -> x, y\n                let body = cadr(operand);   // 10, \"test\"\n                let value = eval(body, env);\n                def_var(variable, value, env);\n                \n                return variable;\n            } else {\n                return Error(message: \"Wrong type argument: \" + car(operand).toStr());\n            }\n        case \"list\":\n            return eval_args(operand, env);\n        case \"quote\":\n            if cdr(operand) is Nil {\n                return car(operand);\n            } else {\n                return Error(message: \"Wrong number of arguments: \" + operand.toStr());\n            }\n        case \"lambda\":\n            // lambda式の定義\n            // (lambda (x) (+ x 1))\n            // operand: ((x) (+ x  1))\n            let params = car(operand)   // (x)\n            let body = cadr(operand)    // (+ x 1)\n\n            let tmp = cons(LispStr(value: LAMBDA), cons(params, cons(body, cons(env.copy(), NIL))));\n            return tmp\n            \n        default:\n            return Error(message: \"unknown primitive procedure: \" + cdr(operator_body).toStr());\n        }\n    }\n    \n    if eq(car(operator_body), LAMBDA) {\n        // lambda式の実行\n        // oparator_body : (\"*** lambda ***\" (x) (list x x x) [env])\n        let lambda_params = cadr(operator_body);    // (x)\n        let lambda_body = car(cddr(operator_body)); // (list x x x)\n        if let lambda_env = cadr(cddr(operator_body)) as? Environment { // [env]\n            let operand_check = eval_args(operand, env);\n            if (operand_check is Error) {\n                return operand_check;\n            }\n            \n            if let ex_env = lambda_env.extend(lambda_params, operand: operand_check) {\n                return eval(lambda_body, ex_env);\n            } else {\n                return Error(message: \"eval lambda params error: \" + lambda_params.toStr() + \" \" + operand.toStr())\n            }\n        }\n    }\n    \n    return Error(message: \"not a function: \" + operator_body.toStr());\n}\n```\n\n### まとめ\nSwift は Java と JavaScript と Ruby がまざったような感じで，なかなか使い易い言語な気もします．が，文字列の操作の関数が少なかったり，β版なのですぐ仕様が変わったり，Xcode がすぐ落ちたりとまだまだな部分もありそうです．今後どうなるのか楽しみです．\n\nObjective-C と互換を保ち続けるとなると，結局iPhoneアプリ作るときはあの長い関数名と付き合い続ける必要があるんでしょうかね．．．\n\n\n### 参考\n- [AppleのDeveloperサイト](https://developer.apple.com/swift/)\n- [The Swift Programming Language](https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11&ls=1)\n- [Arc のチュートリアル](http://old.ycombinator.com/arc/tut.txt)\n- [ちょっと変わったLisp入門](http://www.atmarkit.co.jp/ait/articles/0810/31/news148.html)\n- [Lisp in Arc](https://gist.github.com/torub/a0f8aca789a44f6a5f92)\n",
        "body": "<p>Swift の勉強のため，Lisp のインタプリタもどきを作ってみました．<br>\n参考にしたのは，<a href=\"http://old.ycombinator.com/arc/tut.txt\" title=\"\" target=\"_blank\">Arc</a> という Lisp の方言ですが，全く作り込めていないため，「もどき」です．作成したソースは<a href=\"https://github.com/torub/SwiftLisp\" title=\"\" target=\"_blank\">github</a>上に置いてあります．<br>\niPhone アプリではなく，Mac のコマンドラインアプリとして作成しています．</p>\n<p>現時点では以下の程度しかできません．</p>\n\n<ul>\n<li>car, cdr, list, quote, lambda式</li>\n<li>変数の定義には &quot;=&quot; を使う\n\n<ul>\n<li>(= x 1)</li>\n<li>(= y (lambda (z) (list z z z)))</li>\n</ul></li>\n</ul>\n<p>今回作ってみたものの基本的な流れは，</p>\n\n<ol>\n<li>Lisp の型を表すクラスの作成</li>\n<li>標準入力から文字列をパースする</li>\n<li>パースした内容を Lisp のオブジェクトに変換</li>\n<li>Lisp のオブジェクトに対して eval を呼び出して評価</li>\n</ol>\n<p>となります．</p>\n<h2>\n        <span id=\"2-1\" class=\"fragment\"></span>\n        <a href=\"#2-1\"><i class=\"fa fa-link\"></i></a>1. Lisp の型を表すクラスの作成\n      </h2>\n<ul>\n<li>Nil，文字列，シンボル，数字，リストと，環境を表すクラスを作成しました</li>\n</ul>\n<h4>\n        <span id=\"4-1\" class=\"fragment\"></span>\n        <a href=\"#4-1\"><i class=\"fa fa-link\"></i></a>LispObj プロトコル\n      </h4>\n<ul>\n<li>共通の protocol として LispObj を持つようにしています</li>\n<li>LispObj は，良く使うリスト型かどうかをチェックする listp と，画面表示に使う toStr のみを定義しました</li>\n<li>protocol が Java でいうインターフェイスにあたるものだと理解しています</li>\n</ul>\n<div class=\"code-frame\" data-lang=\"Swift\"><div class=\"highlight\"><pre><span class=\"k\">protocol</span> <span class=\"n\">LispObj</span> <span class=\"p\">{</span>\n    <span class=\"k\">func</span> <span class=\"n\">toStr</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">String</span>\n    <span class=\"k\">func</span> <span class=\"n\">listp</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">ConsCell</span><span class=\"o\">?</span>\n<span class=\"p\">}</span>\n</pre></div></div>\n<ul>\n<li>Swift ではプログラム中に「?」マークを付けると，nil を許容することが出来るという仕様のようです</li>\n<li>Optionals と呼ばれているようです</li>\n<li>?が付いてない関数では nil を返そうとするとコンパイルエラーになった気がします</li>\n<li>似た機能として，キャストが可能であれば実施するが，出来なければしない，というのを  as? で表します</li>\n<li>以下のような感じで結構多用してしまいました．正しいかはよくわかりません</li>\n</ul>\n<div class=\"code-frame\" data-lang=\"Swift\"><div class=\"highlight\"><pre><span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">hoge</span> <span class=\"o\">=</span> <span class=\"n\">foo</span> <span class=\"kt\">as</span><span class=\"o\">?</span> <span class=\"n\">Hoge</span> <span class=\"p\">{</span>  <span class=\"c1\">// foo が Hoge にキャスト可能ならキャスト</span>\n  <span class=\"c1\">// hoge を Hoge 型として利用する</span>\n<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// キャスト不可だった場合の処理をこっちに書く(hoge は使えない)</span>\n<span class=\"p\">}</span>\n</pre></div></div><h4>\n        <span id=\"4-2\" class=\"fragment\"></span>\n        <a href=\"#4-2\"><i class=\"fa fa-link\"></i></a>Nil クラス\n      </h4>\n<ul>\n<li>Singleton の例として<a href=\"http://qiita.com/1024jp/items/3a7bc437af3e79f74505\" title=\"\">ここ</a>を参考にさせて頂きました．</li>\n</ul>\n<div class=\"code-frame\" data-lang=\"Swift\"><div class=\"highlight\"><pre><span class=\"k\">class</span> <span class=\"nl\">Nil</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span> <span class=\"p\">{</span>\n    <span class=\"k\">init</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">class</span> <span class=\"k\">var</span> <span class=\"nl\">sharedInstance</span><span class=\"p\">:</span> <span class=\"n\">Nil</span> <span class=\"p\">{</span>\n        <span class=\"k\">struct</span> <span class=\"n\">Singleton</span> <span class=\"p\">{</span>\n            <span class=\"n\">private</span> <span class=\"k\">static</span> <span class=\"k\">let</span> <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"n\">Nil</span><span class=\"p\">()</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">Singleton</span><span class=\"p\">.</span><span class=\"n\">instance</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">func</span> <span class=\"n\">toStr</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">String</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"s\">&quot;nil&quot;</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">func</span> <span class=\"n\">listp</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">ConsCell</span><span class=\"o\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nb\">nil</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div></div><h4>\n        <span id=\"4-3\" class=\"fragment\"></span>\n        <a href=\"#4-3\"><i class=\"fa fa-link\"></i></a>Symbol クラス\n      </h4>\n<ul>\n<li>特に何の工夫も無いクラスです</li>\n<li>LispNum と LispStr もほぼ同じ内容です</li>\n</ul>\n<div class=\"code-frame\" data-lang=\"Swift\"><div class=\"highlight\"><pre><span class=\"k\">class</span> <span class=\"nl\">Symbol</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nl\">name</span><span class=\"p\">:</span> <span class=\"n\">String</span><span class=\"p\">;</span>\n    <span class=\"k\">init</span><span class=\"p\">(</span><span class=\"nl\">name</span><span class=\"p\">:</span> <span class=\"n\">String</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nb\">self</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">func</span> <span class=\"n\">toStr</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">String</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">name</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">func</span> <span class=\"n\">listp</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">ConsCell</span><span class=\"o\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nb\">nil</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div></div><h4>\n        <span id=\"4-4\" class=\"fragment\"></span>\n        <a href=\"#4-4\"><i class=\"fa fa-link\"></i></a>Error クラス\n      </h4>\n<ul>\n<li>Swift には例外が無いっぽいので，エラーのハンドリング用に Error クラスを作成しました</li>\n<li>中身は Symbol とほぼ同じです．もう少しいいやり方がありそうな気もします．．</li>\n</ul>\n<div class=\"code-frame\" data-lang=\"Swift\"><div class=\"highlight\"><pre><span class=\"k\">class</span> <span class=\"nl\">Error</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nl\">message</span><span class=\"p\">:</span> <span class=\"n\">String</span><span class=\"p\">;</span>\n    <span class=\"k\">init</span><span class=\"p\">(</span><span class=\"nl\">message</span><span class=\"p\">:</span> <span class=\"n\">String</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nb\">self</span><span class=\"p\">.</span><span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"n\">message</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">func</span> <span class=\"n\">toStr</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">String</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"s\">&quot;Error: &quot;</span> <span class=\"o\">+</span> <span class=\"n\">message</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">func</span> <span class=\"n\">listp</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">ConsCell</span><span class=\"o\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nb\">nil</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div></div><h4>\n        <span id=\"4-5\" class=\"fragment\"></span>\n        <a href=\"#4-5\"><i class=\"fa fa-link\"></i></a>ConsCell クラス\n      </h4>\n<ul>\n<li>Lisp のリストを表わすために作成</li>\n<li>car 部と cdr 部としてそれぞれLispObjectを持つようにした他，toStr は<a href=\"http://www.atmarkit.co.jp/ait/articles/0810/31/news148.html\" title=\"\" target=\"_blank\">ちょっと変わったLisp入門</a>を参考に作成しました．</li>\n</ul>\n<div class=\"code-frame\" data-lang=\"Swift\"><div class=\"highlight\"><pre><span class=\"k\">class</span> <span class=\"nl\">ConsCell</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nl\">car</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span><span class=\"p\">;</span>\n    <span class=\"k\">var</span> <span class=\"nl\">cdr</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span><span class=\"p\">;</span>\n\n    <span class=\"k\">init</span><span class=\"p\">(</span><span class=\"nl\">car</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span><span class=\"p\">,</span> <span class=\"nl\">cdr</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nb\">self</span><span class=\"p\">.</span><span class=\"n\">car</span> <span class=\"o\">=</span> <span class=\"n\">car</span><span class=\"p\">;</span>\n        <span class=\"nb\">self</span><span class=\"p\">.</span><span class=\"n\">cdr</span> <span class=\"o\">=</span> <span class=\"n\">cdr</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">func</span> <span class=\"n\">toStr</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">String</span> <span class=\"p\">{</span>\n        <span class=\"k\">var</span> <span class=\"nl\">returnValue</span><span class=\"p\">:</span> <span class=\"n\">String</span> <span class=\"o\">=</span> <span class=\"s\">&quot;&quot;</span><span class=\"p\">;</span>\n\n        <span class=\"n\">returnValue</span> <span class=\"o\">+=</span> <span class=\"s\">&quot;(&quot;</span><span class=\"p\">;</span>\n\n        <span class=\"k\">var</span> <span class=\"n\">tmpcell</span> <span class=\"o\">=</span> <span class=\"nb\">self</span><span class=\"p\">;</span>\n\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">returnValue</span> <span class=\"o\">+=</span> <span class=\"n\">tmpcell</span><span class=\"p\">.</span><span class=\"n\">car</span><span class=\"p\">.</span><span class=\"n\">toStr</span><span class=\"p\">();</span>\n\n            <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">cdrcell</span> <span class=\"o\">=</span> <span class=\"n\">tmpcell</span><span class=\"p\">.</span><span class=\"n\">cdr</span><span class=\"p\">.</span><span class=\"n\">listp</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n                <span class=\"n\">tmpcell</span> <span class=\"o\">=</span> <span class=\"n\">cdrcell</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">tmpcell</span><span class=\"p\">.</span><span class=\"n\">cdr</span> <span class=\"kt\">is</span> <span class=\"n\">Nil</span> <span class=\"p\">{</span>\n                <span class=\"k\">break</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"c1\">//if tmpcell.cdr.isAtom() {</span>\n                <span class=\"n\">returnValue</span> <span class=\"o\">+=</span> <span class=\"s\">&quot;.&quot;</span><span class=\"p\">;</span>\n                <span class=\"n\">returnValue</span> <span class=\"o\">+=</span> <span class=\"n\">tmpcell</span><span class=\"p\">.</span><span class=\"n\">cdr</span><span class=\"p\">.</span><span class=\"n\">toStr</span><span class=\"p\">();</span>\n                <span class=\"k\">break</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n            <span class=\"n\">returnValue</span> <span class=\"o\">+=</span> <span class=\"s\">&quot; &quot;</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">returnValue</span> <span class=\"o\">+=</span> <span class=\"s\">&quot;)&quot;</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">returnValue</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">func</span> <span class=\"n\">listp</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">ConsCell</span><span class=\"o\">?</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nb\">self</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div></div><h2>\n        <span id=\"2-2\" class=\"fragment\"></span>\n        <a href=\"#2-2\"><i class=\"fa fa-link\"></i></a>2. 標準入力から文字列をパースする\n      </h2><h4>\n        <span id=\"4-6\" class=\"fragment\"></span>\n        <a href=\"#4-6\"><i class=\"fa fa-link\"></i></a>標準入力から文字列取得\n      </h4>\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/24004776/input-from-the-keyboard-in-command-line-application\" title=\"\" target=\"_blank\">ここ</a>を参考に，以下のような関数を作りました</li>\n<li>カーソルキー等にも入力値が割り当てられているようで，以下の呼び出し時に押すと，予期しない動作になったりします</li>\n</ul>\n<div class=\"code-frame\" data-lang=\"Swift\"><div class=\"highlight\"><pre><span class=\"k\">func</span> <span class=\"nf\">read</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">String</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"bp\">NSFileHandle</span><span class=\"p\">.</span><span class=\"n\">fileHandleWithStandardInput</span><span class=\"p\">();</span>\n\n    <span class=\"k\">var</span> <span class=\"n\">rawdata</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span><span class=\"p\">.</span><span class=\"n\">availableData</span><span class=\"p\">;</span>\n    <span class=\"k\">var</span> <span class=\"n\">str</span> <span class=\"o\">=</span> <span class=\"bp\">NSString</span><span class=\"p\">(</span><span class=\"nl\">data</span><span class=\"p\">:</span> <span class=\"n\">rawdata</span><span class=\"p\">,</span> <span class=\"nl\">encoding</span><span class=\"p\">:</span> <span class=\"n\">NSUTF8StringEncoding</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">str</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre></div></div><h4>\n        <span id=\"4-7\" class=\"fragment\"></span>\n        <a href=\"#4-7\"><i class=\"fa fa-link\"></i></a>取得した文字列を配列に変換\n      </h4>\n<ul>\n<li>必要な要素毎に分割して配列に入力しています</li>\n<li>文字列操作の関数があまり出揃っていない模様で，細かい処理がやりづらいです</li>\n<li>Lisp では quote 記号が特別な意味を持つので，変換処理も加えています</li>\n</ul>\n<div class=\"code-frame\" data-lang=\"Swift\"><div class=\"highlight\"><pre><span class=\"c1\">// 解析結果のトークンリストを入れる配列</span>\n<span class=\"k\">var</span> <span class=\"nl\">tokenlist</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">String</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[];</span>\n\n<span class=\"c1\">// どこまで読み込んだかを表す配列</span>\n<span class=\"k\">var</span> <span class=\"n\">tokenIndex</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"k\">func</span> <span class=\"nf\">tokenize</span><span class=\"p\">(</span><span class=\"nl\">str</span><span class=\"p\">:</span> <span class=\"n\">String</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">//-&gt; ([String], Int) {</span>\n    <span class=\"c1\">// &#39; (quote記号を (quote  ... ) に置き換え</span>\n\n    <span class=\"k\">var</span> <span class=\"n\">str2</span> <span class=\"o\">=</span> <span class=\"s\">&quot;&quot;</span>\n    <span class=\"k\">var</span> <span class=\"n\">quoteFlag</span> <span class=\"o\">=</span> <span class=\"nb\">false</span>\n    <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">str</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"o\">==</span> <span class=\"s\">&quot;&#39;&quot;</span> <span class=\"p\">{</span>\n            <span class=\"n\">str2</span> <span class=\"o\">+=</span> <span class=\"s\">&quot;(quote &quot;</span>\n            <span class=\"n\">quoteFlag</span> <span class=\"o\">=</span> <span class=\"nb\">true</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"o\">==</span> <span class=\"s\">&quot;)&quot;</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">quoteFlag</span> <span class=\"p\">{</span>\n            <span class=\"n\">str2</span> <span class=\"o\">+=</span> <span class=\"s\">&quot;))&quot;</span>\n            <span class=\"n\">quoteFlag</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">str2</span> <span class=\"o\">+=</span> <span class=\"n\">a</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// &quot;(&quot; と &quot;)&quot; を空白付きに変換</span>\n    <span class=\"k\">let</span> <span class=\"n\">replacedStr</span> <span class=\"o\">=</span> <span class=\"n\">str2</span>\n        <span class=\"p\">.</span><span class=\"n\">stringByReplacingOccurrencesOfString</span><span class=\"p\">(</span><span class=\"s\">&quot;(&quot;</span><span class=\"p\">,</span> <span class=\"nl\">withString</span><span class=\"p\">:</span> <span class=\"s\">&quot; ( &quot;</span><span class=\"p\">,</span> <span class=\"nl\">options</span><span class=\"p\">:</span> <span class=\"nb\">nil</span><span class=\"p\">,</span> <span class=\"nl\">range</span><span class=\"p\">:</span> <span class=\"nb\">nil</span><span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"n\">stringByReplacingOccurrencesOfString</span><span class=\"p\">(</span><span class=\"s\">&quot;)&quot;</span><span class=\"p\">,</span> <span class=\"nl\">withString</span><span class=\"p\">:</span> <span class=\"s\">&quot; ) &quot;</span><span class=\"p\">,</span> <span class=\"nl\">options</span><span class=\"p\">:</span> <span class=\"nb\">nil</span><span class=\"p\">,</span> <span class=\"nl\">range</span><span class=\"p\">:</span> <span class=\"nb\">nil</span><span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"n\">stringByReplacingOccurrencesOfString</span><span class=\"p\">(</span><span class=\"s\">&quot;</span><span class=\"se\">\\n</span><span class=\"s\">&quot;</span><span class=\"p\">,</span> <span class=\"nl\">withString</span><span class=\"p\">:</span> <span class=\"s\">&quot; &quot;</span><span class=\"p\">,</span> <span class=\"nl\">options</span><span class=\"p\">:</span> <span class=\"nb\">nil</span><span class=\"p\">,</span> <span class=\"nl\">range</span><span class=\"p\">:</span> <span class=\"nb\">nil</span><span class=\"p\">);</span>\n\n    <span class=\"n\">tokenlist</span> <span class=\"o\">=</span> <span class=\"n\">replacedStr</span><span class=\"p\">.</span><span class=\"n\">componentsSeparatedByString</span><span class=\"p\">(</span><span class=\"s\">&quot; &quot;</span><span class=\"p\">);</span>\n    <span class=\"n\">tokenIndex</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre></div></div><h2>\n        <span id=\"2-3\" class=\"fragment\"></span>\n        <a href=\"#2-3\"><i class=\"fa fa-link\"></i></a>3. パースした内容を Lisp のオブジェクトに変換\n      </h2>\n<ul>\n<li>ここまでで，パースした Lisp のプログラムが配列に格納されているため，LispObj に変換する</li>\n<li>リストではない場合は，Intにキャスト可能かや，セミコロンで囲われているか等を確認して対応する型に変換</li>\n<li>リストの表現の場合はリスト型のオブジェクトを作成する</li>\n</ul>\n<div class=\"code-frame\" data-lang=\"Swift\"><div class=\"highlight\"><pre><span class=\"k\">func</span> <span class=\"n\">parse</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">LispObj</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nl\">c</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span><span class=\"p\">;</span>\n    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">read_next</span><span class=\"p\">(</span><span class=\"n\">get_token</span><span class=\"p\">());</span>\n    <span class=\"k\">return</span> <span class=\"n\">c</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">func</span> <span class=\"n\">read_next</span><span class=\"p\">(</span><span class=\"k\">var</span> <span class=\"nl\">token</span><span class=\"p\">:</span> <span class=\"n\">String</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">LispObj</span> <span class=\"p\">{</span>\n    <span class=\"k\">var</span> <span class=\"nl\">carexp</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span><span class=\"p\">,</span> <span class=\"nl\">cdrexp</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span><span class=\"p\">;</span>\n    <span class=\"k\">var</span> <span class=\"nl\">list</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span> <span class=\"o\">=</span> <span class=\"n\">NIL</span><span class=\"p\">;</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">token</span> <span class=\"o\">==</span> <span class=\"s\">&quot;&quot;</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">NIL</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">token</span> <span class=\"o\">!=</span> <span class=\"s\">&quot;(&quot;</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"c1\">// &quot;(&quot; じゃないときの処理</span>\n        <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">token</span><span class=\"p\">.</span><span class=\"n\">toInt</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">LispNum</span><span class=\"p\">(</span><span class=\"nl\">value</span><span class=\"p\">:</span> <span class=\"n\">n</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"k\">let</span> <span class=\"kr\">prefix</span> <span class=\"o\">=</span> <span class=\"n\">token</span><span class=\"p\">.</span><span class=\"n\">hasPrefix</span><span class=\"p\">(</span><span class=\"s\">&quot;</span><span class=\"se\">\\&quot;</span><span class=\"s\">&quot;</span><span class=\"p\">);</span>\n            <span class=\"k\">let</span> <span class=\"n\">suffix</span> <span class=\"o\">=</span> <span class=\"n\">token</span><span class=\"p\">.</span><span class=\"n\">hasSuffix</span><span class=\"p\">(</span><span class=\"s\">&quot;</span><span class=\"se\">\\&quot;</span><span class=\"s\">&quot;</span><span class=\"p\">);</span>\n            <span class=\"k\">let</span> <span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"n\">token</span><span class=\"p\">.</span><span class=\"n\">utf16Count</span><span class=\"p\">;</span>\n\n            <span class=\"k\">if</span> <span class=\"kr\">prefix</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">suffix</span> <span class=\"p\">{</span>  <span class=\"c1\">// &quot;hogehoge&quot; のようにセミコロンで囲われている場合</span>\n                <span class=\"k\">if</span> <span class=\"n\">length</span> <span class=\"o\">&gt;</span> <span class=\"mi\">2</span> <span class=\"p\">{</span>\n                    <span class=\"k\">return</span> <span class=\"n\">LispStr</span><span class=\"p\">(</span><span class=\"nl\">value</span><span class=\"p\">:</span> <span class=\"n\">token</span><span class=\"p\">[</span><span class=\"mf\">1.</span><span class=\"p\">..</span><span class=\"n\">token</span><span class=\"p\">.</span><span class=\"n\">utf16Count</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">]);</span>\n                <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                    <span class=\"k\">return</span> <span class=\"n\">LispStr</span><span class=\"p\">(</span><span class=\"nl\">value</span><span class=\"p\">:</span> <span class=\"s\">&quot;&quot;</span><span class=\"p\">);</span>\n                <span class=\"p\">}</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"kr\">prefix</span> <span class=\"o\">||</span> <span class=\"n\">suffix</span> <span class=\"p\">{</span>  <span class=\"c1\">// &quot;hogehoge のように片方だけセミコロンが付いている場合</span>\n                <span class=\"k\">return</span> <span class=\"n\">Error</span><span class=\"p\">(</span><span class=\"nl\">message</span><span class=\"p\">:</span> <span class=\"s\">&quot;wrong String:&quot;</span> <span class=\"o\">+</span> <span class=\"n\">token</span><span class=\"p\">);</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">Symbol</span><span class=\"p\">(</span><span class=\"nl\">name</span><span class=\"p\">:</span> <span class=\"n\">token</span><span class=\"p\">);</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">token</span> <span class=\"o\">=</span> <span class=\"n\">get_token</span><span class=\"p\">();</span>  <span class=\"c1\">// ( の次のトークンを取得</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"c1\">// &quot;(&quot; から始まるとき</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">token</span> <span class=\"o\">==</span> <span class=\"s\">&quot;)&quot;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">list</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"n\">carexp</span> <span class=\"o\">=</span> <span class=\"n\">read_next</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">);</span>  <span class=\"c1\">// 読み込んだトークンをcar部分として処理</span>\n        <span class=\"n\">token</span> <span class=\"o\">=</span> <span class=\"n\">get_token</span><span class=\"p\">();</span>     <span class=\"c1\">// 次のトークン取得</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">token</span> <span class=\"o\">==</span> <span class=\"s\">&quot;.&quot;</span><span class=\"p\">)</span> <span class=\"p\">{</span>       <span class=\"c1\">// ペアの場合</span>\n            <span class=\"n\">token</span> <span class=\"o\">=</span> <span class=\"n\">get_token</span><span class=\"p\">();</span>\n            <span class=\"n\">cdrexp</span> <span class=\"o\">=</span> <span class=\"n\">read_next</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">);</span>  <span class=\"c1\">// 取得した次のトークンを cdr にセット</span>\n            <span class=\"n\">token</span> <span class=\"o\">=</span> <span class=\"n\">get_token</span><span class=\"p\">();</span>   <span class=\"c1\">// ペアの後は ) がくるはず</span>\n            <span class=\"k\">if</span> <span class=\"n\">token</span> <span class=\"o\">!=</span> <span class=\"s\">&quot;)&quot;</span> <span class=\"p\">{</span>\n                <span class=\"n\">println</span><span class=\"p\">(</span><span class=\"s\">&quot;) required!&quot;</span><span class=\"p\">);</span>\n            <span class=\"p\">}</span>\n            <span class=\"k\">return</span> <span class=\"n\">ConsCell</span><span class=\"p\">(</span><span class=\"nl\">car</span><span class=\"p\">:</span> <span class=\"n\">carexp</span><span class=\"p\">,</span> <span class=\"nl\">cdr</span><span class=\"p\">:</span> <span class=\"n\">cdrexp</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"n\">concat</span><span class=\"p\">(</span><span class=\"n\">list</span><span class=\"p\">,</span> <span class=\"n\">cons</span><span class=\"p\">(</span><span class=\"n\">carexp</span><span class=\"p\">,</span> <span class=\"n\">NIL</span><span class=\"p\">));</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div></div><h2>\n        <span id=\"2-4\" class=\"fragment\"></span>\n        <a href=\"#2-4\"><i class=\"fa fa-link\"></i></a>4. Lisp のオブジェクトに対して eval を呼び出して評価\n      </h2>\n<ul>\n<li>3までで作成した LispObj を与えられた環境の元で評価する</li>\n<li>昔作った<a href=\"https://gist.github.com/torub/a0f8aca789a44f6a5f92\" title=\"\" target=\"_blank\">Lisp in Arc</a>を参考に実装</li>\n<li>環境は Dictonary 型を使い，名前と値を紐付けする</li>\n<li>クロージャを使う場合は，Dictonary をグローバルのものとクロージャ内のものに分けて扱う</li>\n</ul>\n<div class=\"code-frame\" data-lang=\"Swift\"><div class=\"highlight\"><pre><span class=\"k\">func</span> <span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"nl\">exp</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span><span class=\"p\">,</span> <span class=\"nl\">env</span><span class=\"p\">:</span> <span class=\"n\">Environment</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">LispObj</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"n\">exp</span> <span class=\"kt\">is</span> <span class=\"n\">Error</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">exp</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"n\">exp</span> <span class=\"kt\">is</span> <span class=\"n\">Nil</span> <span class=\"o\">||</span> <span class=\"n\">exp</span> <span class=\"kt\">is</span> <span class=\"n\">LispNum</span> <span class=\"p\">{</span>  <span class=\"c1\">// Nilまたは数値の場合はそのまま返す</span>\n        <span class=\"k\">return</span> <span class=\"n\">exp</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"n\">exp</span> <span class=\"kt\">is</span> <span class=\"n\">LispStr</span> <span class=\"p\">{</span> <span class=\"c1\">// または文字列の場合もそのまま返す(エディタがエラーになるため、 || の連結は禁止</span>\n        <span class=\"k\">return</span> <span class=\"n\">exp</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">symbol</span> <span class=\"o\">=</span> <span class=\"n\">exp</span> <span class=\"kt\">as</span><span class=\"o\">?</span> <span class=\"n\">Symbol</span> <span class=\"p\">{</span>  <span class=\"c1\">// シンボルならば環境の値を検索して返す</span>\n        <span class=\"k\">var</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"kr\">get</span><span class=\"p\">(</span><span class=\"n\">symbol</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">env</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">value</span> <span class=\"kt\">is</span> <span class=\"n\">Nil</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">value</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">Error</span><span class=\"p\">(</span><span class=\"nl\">message</span><span class=\"p\">:</span> <span class=\"s\">&quot;Undefined Value: &quot;</span> <span class=\"o\">+</span> <span class=\"n\">symbol</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">consexp</span> <span class=\"o\">=</span> <span class=\"n\">exp</span><span class=\"p\">.</span><span class=\"n\">listp</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">apply</span><span class=\"p\">(</span><span class=\"n\">consexp</span><span class=\"p\">.</span><span class=\"n\">car</span><span class=\"p\">,</span> <span class=\"n\">consexp</span><span class=\"p\">.</span><span class=\"n\">cdr</span><span class=\"p\">,</span> <span class=\"n\">env</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">Error</span><span class=\"p\">(</span><span class=\"nl\">message</span><span class=\"p\">:</span> <span class=\"s\">&quot;something wrong!&quot;</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">func</span> <span class=\"n\">apply</span><span class=\"p\">(</span><span class=\"nl\">operator_var</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span><span class=\"p\">,</span> <span class=\"nl\">operand</span><span class=\"p\">:</span> <span class=\"n\">LispObj</span><span class=\"p\">,</span> <span class=\"nl\">env</span><span class=\"p\">:</span> <span class=\"n\">Environment</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">LispObj</span> <span class=\"p\">{</span>\n    <span class=\"k\">let</span> <span class=\"n\">operator_body</span> <span class=\"o\">=</span> <span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"n\">operator_var</span><span class=\"p\">,</span> <span class=\"n\">env</span><span class=\"p\">);</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">operand</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"nf\">eq</span><span class=\"p\">(</span><span class=\"n\">car</span><span class=\"p\">(</span><span class=\"n\">operator_body</span><span class=\"p\">),</span> <span class=\"n\">PRIMITIVE</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"c1\">// プリミティブ関数の場合の処理</span>\n        <span class=\"k\">switch</span> <span class=\"n\">cdr</span><span class=\"p\">(</span><span class=\"n\">operator_body</span><span class=\"p\">).</span><span class=\"n\">toStr</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"k\">case</span> <span class=\"s\">&quot;car&quot;</span><span class=\"o\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">car</span><span class=\"p\">(</span><span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"n\">car</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">),</span> <span class=\"n\">env</span><span class=\"p\">));</span>\n        <span class=\"k\">case</span> <span class=\"s\">&quot;cdr&quot;</span><span class=\"o\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">cdr</span><span class=\"p\">(</span><span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"n\">car</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">),</span> <span class=\"n\">env</span><span class=\"p\">));</span>\n        <span class=\"k\">case</span> <span class=\"s\">&quot;=&quot;</span><span class=\"o\">:</span>\n            <span class=\"c1\">// (= x 10)</span>\n            <span class=\"c1\">// (= y &quot;test&quot;)</span>\n            <span class=\"c1\">// (= z (+ 1 2))</span>\n            <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">variable</span> <span class=\"o\">=</span> <span class=\"n\">car</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">)</span> <span class=\"kt\">as</span><span class=\"o\">?</span> <span class=\"n\">Symbol</span> <span class=\"p\">{</span>  <span class=\"c1\">// -&gt; x, y</span>\n                <span class=\"k\">let</span> <span class=\"n\">body</span> <span class=\"o\">=</span> <span class=\"n\">cadr</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">);</span>   <span class=\"c1\">// 10, &quot;test&quot;</span>\n                <span class=\"k\">let</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"n\">body</span><span class=\"p\">,</span> <span class=\"n\">env</span><span class=\"p\">);</span>\n                <span class=\"n\">def_var</span><span class=\"p\">(</span><span class=\"n\">variable</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">env</span><span class=\"p\">);</span>\n\n                <span class=\"k\">return</span> <span class=\"n\">variable</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">Error</span><span class=\"p\">(</span><span class=\"nl\">message</span><span class=\"p\">:</span> <span class=\"s\">&quot;Wrong type argument: &quot;</span> <span class=\"o\">+</span> <span class=\"n\">car</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">).</span><span class=\"n\">toStr</span><span class=\"p\">());</span>\n            <span class=\"p\">}</span>\n        <span class=\"k\">case</span> <span class=\"s\">&quot;list&quot;</span><span class=\"o\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">eval_args</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">,</span> <span class=\"n\">env</span><span class=\"p\">);</span>\n        <span class=\"k\">case</span> <span class=\"s\">&quot;quote&quot;</span><span class=\"o\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">cdr</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">)</span> <span class=\"kt\">is</span> <span class=\"n\">Nil</span> <span class=\"p\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">car</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">);</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">Error</span><span class=\"p\">(</span><span class=\"nl\">message</span><span class=\"p\">:</span> <span class=\"s\">&quot;Wrong number of arguments: &quot;</span> <span class=\"o\">+</span> <span class=\"n\">operand</span><span class=\"p\">.</span><span class=\"n\">toStr</span><span class=\"p\">());</span>\n            <span class=\"p\">}</span>\n        <span class=\"k\">case</span> <span class=\"s\">&quot;lambda&quot;</span><span class=\"o\">:</span>\n            <span class=\"c1\">// lambda式の定義</span>\n            <span class=\"c1\">// (lambda (x) (+ x 1))</span>\n            <span class=\"c1\">// operand: ((x) (+ x  1))</span>\n            <span class=\"k\">let</span> <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"n\">car</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">)</span>   <span class=\"c1\">// (x)</span>\n            <span class=\"k\">let</span> <span class=\"n\">body</span> <span class=\"o\">=</span> <span class=\"n\">cadr</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">)</span>    <span class=\"c1\">// (+ x 1)</span>\n\n            <span class=\"k\">let</span> <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">cons</span><span class=\"p\">(</span><span class=\"n\">LispStr</span><span class=\"p\">(</span><span class=\"nl\">value</span><span class=\"p\">:</span> <span class=\"n\">LAMBDA</span><span class=\"p\">),</span> <span class=\"n\">cons</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">cons</span><span class=\"p\">(</span><span class=\"n\">body</span><span class=\"p\">,</span> <span class=\"n\">cons</span><span class=\"p\">(</span><span class=\"n\">env</span><span class=\"p\">.</span><span class=\"k\">copy</span><span class=\"p\">(),</span> <span class=\"n\">NIL</span><span class=\"p\">))));</span>\n            <span class=\"k\">return</span> <span class=\"n\">tmp</span>\n\n        <span class=\"k\">default</span><span class=\"o\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">Error</span><span class=\"p\">(</span><span class=\"nl\">message</span><span class=\"p\">:</span> <span class=\"s\">&quot;unknown primitive procedure: &quot;</span> <span class=\"o\">+</span> <span class=\"n\">cdr</span><span class=\"p\">(</span><span class=\"n\">operator_body</span><span class=\"p\">).</span><span class=\"n\">toStr</span><span class=\"p\">());</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"nf\">eq</span><span class=\"p\">(</span><span class=\"n\">car</span><span class=\"p\">(</span><span class=\"n\">operator_body</span><span class=\"p\">),</span> <span class=\"n\">LAMBDA</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// lambda式の実行</span>\n        <span class=\"c1\">// oparator_body : (&quot;*** lambda ***&quot; (x) (list x x x) [env])</span>\n        <span class=\"k\">let</span> <span class=\"n\">lambda_params</span> <span class=\"o\">=</span> <span class=\"n\">cadr</span><span class=\"p\">(</span><span class=\"n\">operator_body</span><span class=\"p\">);</span>    <span class=\"c1\">// (x)</span>\n        <span class=\"k\">let</span> <span class=\"n\">lambda_body</span> <span class=\"o\">=</span> <span class=\"n\">car</span><span class=\"p\">(</span><span class=\"n\">cddr</span><span class=\"p\">(</span><span class=\"n\">operator_body</span><span class=\"p\">));</span> <span class=\"c1\">// (list x x x)</span>\n        <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">lambda_env</span> <span class=\"o\">=</span> <span class=\"n\">cadr</span><span class=\"p\">(</span><span class=\"n\">cddr</span><span class=\"p\">(</span><span class=\"n\">operator_body</span><span class=\"p\">))</span> <span class=\"kt\">as</span><span class=\"o\">?</span> <span class=\"n\">Environment</span> <span class=\"p\">{</span> <span class=\"c1\">// [env]</span>\n            <span class=\"k\">let</span> <span class=\"n\">operand_check</span> <span class=\"o\">=</span> <span class=\"n\">eval_args</span><span class=\"p\">(</span><span class=\"n\">operand</span><span class=\"p\">,</span> <span class=\"n\">env</span><span class=\"p\">);</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">operand_check</span> <span class=\"kt\">is</span> <span class=\"n\">Error</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">operand_check</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n\n            <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">ex_env</span> <span class=\"o\">=</span> <span class=\"n\">lambda_env</span><span class=\"p\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"n\">lambda_params</span><span class=\"p\">,</span> <span class=\"nl\">operand</span><span class=\"p\">:</span> <span class=\"n\">operand_check</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"n\">lambda_body</span><span class=\"p\">,</span> <span class=\"n\">ex_env</span><span class=\"p\">);</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">Error</span><span class=\"p\">(</span><span class=\"nl\">message</span><span class=\"p\">:</span> <span class=\"s\">&quot;eval lambda params error: &quot;</span> <span class=\"o\">+</span> <span class=\"n\">lambda_params</span><span class=\"p\">.</span><span class=\"n\">toStr</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"s\">&quot; &quot;</span> <span class=\"o\">+</span> <span class=\"n\">operand</span><span class=\"p\">.</span><span class=\"n\">toStr</span><span class=\"p\">())</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"nf\">Error</span><span class=\"p\">(</span><span class=\"nl\">message</span><span class=\"p\">:</span> <span class=\"s\">&quot;not a function: &quot;</span> <span class=\"o\">+</span> <span class=\"n\">operator_body</span><span class=\"p\">.</span><span class=\"n\">toStr</span><span class=\"p\">());</span>\n<span class=\"p\">}</span>\n</pre></div></div><h3>\n        <span id=\"3-1\" class=\"fragment\"></span>\n        <a href=\"#3-1\"><i class=\"fa fa-link\"></i></a>まとめ\n      </h3><p>Swift は Java と JavaScript と Ruby がまざったような感じで，なかなか使い易い言語な気もします．が，文字列の操作の関数が少なかったり，β版なのですぐ仕様が変わったり，Xcode がすぐ落ちたりとまだまだな部分もありそうです．今後どうなるのか楽しみです．</p>\n<p>Objective-C と互換を保ち続けるとなると，結局iPhoneアプリ作るときはあの長い関数名と付き合い続ける必要があるんでしょうかね．．．</p>\n<h3>\n        <span id=\"3-2\" class=\"fragment\"></span>\n        <a href=\"#3-2\"><i class=\"fa fa-link\"></i></a>参考\n      </h3>\n<ul>\n<li><a href=\"https://developer.apple.com/swift/\" title=\"\" target=\"_blank\">AppleのDeveloperサイト</a></li>\n<li><a href=\"https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11&amp;ls=1\" title=\"\" target=\"_blank\">The Swift Programming Language</a></li>\n<li><a href=\"http://old.ycombinator.com/arc/tut.txt\" title=\"\" target=\"_blank\">Arc のチュートリアル</a></li>\n<li><a href=\"http://www.atmarkit.co.jp/ait/articles/0810/31/news148.html\" title=\"\" target=\"_blank\">ちょっと変わったLisp入門</a></li>\n<li><a href=\"https://gist.github.com/torub/a0f8aca789a44f6a5f92\" title=\"\" target=\"_blank\">Lisp in Arc</a></li>\n</ul>\n",
        "stock_users": [
            "trorogohan",
            "hakuro",
            "SuperAlloyZZ",
            "kametaro",
            "135yshr",
            "kasumani",
            "JunSuzukiJapan@github",
            "torub",
            "Reds",
            "Keita_Shiya",
            "ka_"
        ]
    },
    {
        "id": 115344,
        "uuid": "68fc6e0f2d87e19e977f",
        "user": {
            "id": 52297,
            "url_name": "defplus",
            "profile_image_url": "https://pbs.twimg.com/profile_images/499352263526084608/lkrtIUYU_normal.png"
        },
        "title": "LISP構文の直感的な読み方を、英文法で解釈する。",
        "created_at": "2014-08-21 23:22:05 +0900",
        "updated_at": "2014-08-22 05:38:13 +0900",
        "created_at_in_words": "約1ヶ月",
        "updated_at_in_words": "約1ヶ月",
        "tags": [
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            }
        ],
        "stock_count": 1,
        "comment_count": 1,
        "url": "http://qiita.com/defplus/items/68fc6e0f2d87e19e977f",
        "created_at_as_seconds": 1408630925,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "# 0. まえがき\n\nこんにちはフグです。\n\n半年前に\"On Lisp\"という本を本屋で見つけて、\nLISPってなんとなく面白そうだな～と思ったものの、\n3回ほど通読したものの全く理解できず。一度挫折。\n\nその後、でもやっぱりこれは今の僕に必要なこと何じゃないかと思い直し、\nこれまたつい先日ジャケ買いした\"Land of Lisp\"を\n1日1章ペースくらいで読んで、\nそのときどきで解釈していったことを書いていこうと思いました。\n\n\n\n\n# 1. しかし、いちばん簡単なLISPの構文すら読めなかった……\n\n`(+ 3 (* 2 4))`\n\n何この文法！！キモい！死ぬ！！！読めない！！吐血！！！終了！！！\n\nいやいや、待とう。\n同じ人間がつくったものなんだから、落ち着いて考えればわかるはずだ。\n\nどうも、+ や * というのが関数で、残りが引数ということらしい。\nどうして、こう書き方になっているのか？ という理由が納得できれば、\nもっと脳にすっと入ってくるようになるのではないか？\nと考えなおす。\n\n\n\n# 2. ふつーのオブジェクト指向言語の場合\n\n分からない問題にあたったら、既知の似たような問題から類推する。\n(by いかにして問題をとくか / G.ポリア)\n\n\nよく知っているフツーのオブジェクト指向言語(僕にとってはScala)の\nいちばん簡単な例を考えてみる。\n\n`1 + 2`\n\n全ての数字をオブジェクトとかんがえると、これは、\n\n`1.+(2)`\n\nと書かれているのに等しい。\n\n\n僕はこれを\n\n>「1」(主語) が 、「+」する(動詞)、「2」(目的語)を。\n\nというふうに脳内で読む。\n\n\n***\n\n多少複雑になって、\n`x = 1 + 2`\nになったらどうだろう？\n\nこれは\n`x.=((1.+(2))`\nと書かれているのに等しい。\n\nこれは、\n\n>「X」(主語)が、「=」する(動詞)、「((1.+(2))」(目的語)を。\n「1」(主語) が 、「+」する(動詞)、「2」(目的語)を。\n\nの2文による複文のように脳内で読める。\n\n\nしたがって、僕は、オブジェクト指向の言語の場合、\n書かれていることは SVO の第三文型で読んでいることが分かった。\n\n\n\n## 3. LISPの場合\n\n`(+ 1 2)`\n\nこれは\n>「+」しろ(動詞)、「1」に(目的語A) 「2」を(目的語B)。\n\nとも読める。\n\nつまり、I give you a candy. みたいな、\n第四文型(SVOO)のような感じなのだろう。\n\nただし主語はない。\n\n\n* * *\n* \n少し複雑になって\n`(+ 3 (* 2 4))`\nは\n\n>「+」しろ(動詞)、「3」に(目的語A)、「(* 2 4)」を(目的語B)。\n>「*」しろ(動詞)、「2」に(目的語A)、「4」を(目的語B)。\n\nの複文だということが分かる。\n\nやはり主語はない。\n\n* * *\n\nちょっと背伸びして\"Land of Lisp\"のずっと先の方のページや、\n色々なLISPのコードを見てみたけれども、\n「主語」として解釈できるようなものがいくら経っても出てこない。\n\nなので根本的にLISPには「主語」がないのだろう。\nそして一文として解釈できる単位は必ずカッコ()で把握できて、\n演算が終了した文は、必ず別の文の目的語になっている、\nということも分かった。\n\n全ての()の中身が\nV と O O... (動詞と、複数の目的語)\nでできており。\n\n() そのものは別の文の\nO (目的語)\nになっている。\n\nあ、すごく分かりやすい。\n\n* * *\n\nたぶん英語圏の人は、\n`(+ 3 (* 2 4))`\nを\n\nplus 3 by (multiple 2 by 4)\nみたいに脳内で読んでるんじゃないかな。\n\n\n\n# 4.しめ\n\nというような解釈の仕方を始めたところ、\nとりあえずLISPの構文を読み解き始めることができるようになりましたとさ。\n\n\nΣ(　・p・)⌒°＜ またね！\n",
        "body": "<h1>\n        <span id=\"1-1\" class=\"fragment\"></span>\n        <a href=\"#1-1\"><i class=\"fa fa-link\"></i></a>0. まえがき\n      </h1><p>こんにちはフグです。</p>\n<p>半年前に&quot;On Lisp&quot;という本を本屋で見つけて、<br>\nLISPってなんとなく面白そうだな～と思ったものの、<br>\n3回ほど通読したものの全く理解できず。一度挫折。</p>\n<p>その後、でもやっぱりこれは今の僕に必要なこと何じゃないかと思い直し、<br>\nこれまたつい先日ジャケ買いした&quot;Land of Lisp&quot;を<br>\n1日1章ペースくらいで読んで、<br>\nそのときどきで解釈していったことを書いていこうと思いました。</p>\n<h1>\n        <span id=\"1-2\" class=\"fragment\"></span>\n        <a href=\"#1-2\"><i class=\"fa fa-link\"></i></a>1. しかし、いちばん簡単なLISPの構文すら読めなかった……\n      </h1><p><code>(+ 3 (* 2 4))</code></p>\n<p>何この文法！！キモい！死ぬ！！！読めない！！吐血！！！終了！！！</p>\n<p>いやいや、待とう。<br>\n同じ人間がつくったものなんだから、落ち着いて考えればわかるはずだ。</p>\n<p>どうも、+ や * というのが関数で、残りが引数ということらしい。<br>\nどうして、こう書き方になっているのか？ という理由が納得できれば、<br>\nもっと脳にすっと入ってくるようになるのではないか？<br>\nと考えなおす。</p>\n<h1>\n        <span id=\"1-3\" class=\"fragment\"></span>\n        <a href=\"#1-3\"><i class=\"fa fa-link\"></i></a>2. ふつーのオブジェクト指向言語の場合\n      </h1><p>分からない問題にあたったら、既知の似たような問題から類推する。<br>\n(by いかにして問題をとくか / G.ポリア)</p>\n<p>よく知っているフツーのオブジェクト指向言語(僕にとってはScala)の<br>\nいちばん簡単な例を考えてみる。</p>\n<p><code>1 + 2</code></p>\n<p>全ての数字をオブジェクトとかんがえると、これは、</p>\n<p><code>1.+(2)</code></p>\n<p>と書かれているのに等しい。</p>\n<p>僕はこれを</p>\n\n<blockquote>\n<p>「1」(主語) が 、「+」する(動詞)、「2」(目的語)を。</p>\n</blockquote>\n<p>というふうに脳内で読む。</p>\n\n<hr>\n<p>多少複雑になって、<br>\n<code>x = 1 + 2</code><br>\nになったらどうだろう？</p>\n<p>これは<br>\n<code>x.=((1.+(2))</code><br>\nと書かれているのに等しい。</p>\n<p>これは、</p>\n\n<blockquote>\n<p>「X」(主語)が、「=」する(動詞)、「((1.+(2))」(目的語)を。<br>\n「1」(主語) が 、「+」する(動詞)、「2」(目的語)を。</p>\n</blockquote>\n<p>の2文による複文のように脳内で読める。</p>\n<p>したがって、僕は、オブジェクト指向の言語の場合、<br>\n書かれていることは SVO の第三文型で読んでいることが分かった。</p>\n<h2>\n        <span id=\"2-1\" class=\"fragment\"></span>\n        <a href=\"#2-1\"><i class=\"fa fa-link\"></i></a>3. LISPの場合\n      </h2><p><code>(+ 1 2)</code></p>\n<p>これは</p>\n\n<blockquote>\n<p>「+」しろ(動詞)、「1」に(目的語A) 「2」を(目的語B)。</p>\n</blockquote>\n<p>とも読める。</p>\n<p>つまり、I give you a candy. みたいな、<br>\n第四文型(SVOO)のような感じなのだろう。</p>\n<p>ただし主語はない。</p>\n\n<hr>\n\n<ul>\n<li>\n少し複雑になって\n<code>(+ 3 (* 2 4))</code>\nは</li>\n</ul>\n\n<blockquote>\n<p>「+」しろ(動詞)、「3」に(目的語A)、「(* 2 4)」を(目的語B)。<br>\n「*」しろ(動詞)、「2」に(目的語A)、「4」を(目的語B)。</p>\n</blockquote>\n<p>の複文だということが分かる。</p>\n<p>やはり主語はない。</p>\n\n<hr>\n<p>ちょっと背伸びして&quot;Land of Lisp&quot;のずっと先の方のページや、<br>\n色々なLISPのコードを見てみたけれども、<br>\n「主語」として解釈できるようなものがいくら経っても出てこない。</p>\n<p>なので根本的にLISPには「主語」がないのだろう。<br>\nそして一文として解釈できる単位は必ずカッコ()で把握できて、<br>\n演算が終了した文は、必ず別の文の目的語になっている、<br>\nということも分かった。</p>\n<p>全ての()の中身が<br>\nV と O O... (動詞と、複数の目的語)<br>\nでできており。</p>\n<p>() そのものは別の文の<br>\nO (目的語)<br>\nになっている。</p>\n<p>あ、すごく分かりやすい。</p>\n\n<hr>\n<p>たぶん英語圏の人は、<br>\n<code>(+ 3 (* 2 4))</code><br>\nを</p>\n<p>plus 3 by (multiple 2 by 4)<br>\nみたいに脳内で読んでるんじゃないかな。</p>\n<h1>\n        <span id=\"1-4\" class=\"fragment\"></span>\n        <a href=\"#1-4\"><i class=\"fa fa-link\"></i></a>4.しめ\n      </h1><p>というような解釈の仕方を始めたところ、<br>\nとりあえずLISPの構文を読み解き始めることができるようになりましたとさ。</p>\n<p>Σ(　・p・)⌒°＜ またね！</p>\n",
        "stock_users": [
            "ne_ko_"
        ]
    },
    {
        "id": 112119,
        "uuid": "0a7737710ba647697832",
        "user": {
            "id": 12206,
            "url_name": "y2q_actionman",
            "profile_image_url": "https://pbs.twimg.com/profile_images/1187742854/atokara_album_icon_normal.jpg"
        },
        "title": "Common Lisp に中置記法を入れようとしたら C 言語もどきになった",
        "created_at": "2014-08-17 22:52:18 +0900",
        "updated_at": "2014-08-18 16:56:14 +0900",
        "created_at_in_words": "約1ヶ月",
        "updated_at_in_words": "約1ヶ月",
        "tags": [
            {
                "name": "common-lisp",
                "url_name": "common-lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/745b73901dc247fd2b064c1766a7bcd8037cd5a7/medium.jpg?1364838584",
                "versions": []
            },
            {
                "name": "C",
                "url_name": "c",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/943e6bf8c78681eacc00068ff38a828ea0393640/medium.jpg?1364837783",
                "versions": []
            },
            {
                "name": "CommonLisp",
                "url_name": "commonlisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/7ec4b6d2f823c969579b87db605ceb000e516b63/medium.jpg?1364838934",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            }
        ],
        "stock_count": 7,
        "comment_count": 0,
        "url": "http://qiita.com/y2q_actionman/items/0a7737710ba647697832",
        "created_at_as_seconds": 1408283538,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "# ストーリー\nLisp は、「括弧が多く」「前置記法」であることにより、利用者が伸び悩んでいると言われている。Lisper 共にとっては、記法など見栄えの問題に過ぎず、これを省みる者はいない。とはいえ、中置記法に染められた人々が一定数いるということもまた事実であろう。\n\nこれは、彼らをこちらにいざなうために、中置記法を取り入れてみる一つの実験である。\n\n# 真のストーリー: 私の体験\nあるデータ構造を、 Common Lisp で実装しようと思い立ちました。そのデータ構造には、既に C 言語での実装があったので、「まあ元々の論文を読むのは面倒だし、とりあえずアルゴリズムをコピペするか」と思っていました。\n\nそこで私は思ったのです: **Common Lisp の配列参照は面倒すぎる!**\n\n例えば、以下の C の式を考えます:\n\n```c\nx[i] = y[ z[i + 1] + 1 ] - 1;\n```\n\nこれが、 Common Lisp だと:\n\n```cl\n(setf (aref x i)\n      (1- (aref y (1+ (aref z (1+ i))))))\n```\n\nCommon Lisp 版は、なんだかよく分からない気がします。配列参照についてくらい、DSL的な感じで C 言語の構文を取り入れられないかしら、と思ったのです。\n\nというわけで何かいろいろやっていたら・・配列参照以外も、結構な C の構文が食えるようになってしまいました。\n\n# 書いたもの: with-c-syntax マクロ\n## Hello, World!\n```cl\n(with-c-syntax ()\n{\n   print \\( \"Hello, World!\" \\) \\;\n})\n```\n\n`with-c-syntax` とつけて括弧で囲めば、その中では C 言語的な構文が使い放題。そんなマクロです。\n`( ) ;` という文字は、 Lisp では特殊な意味があるのでエスケープを付けています。\n\n## 値を返してみる\n```cl\n(defun test-add-args (x y)\n  (with-c-syntax ()\n    {\n    return x + y \\;\n    })\n  )\n\n(test-add-args 1 2) ; => 3\n```\n\nlexical に見えている変数なら、そのまま参照することが出来ます。\n\n## for ループで、 1 から 100 まで足そう\n```cl \n(defun test-for-loop ()\n  (let ((i 0) (sum 0))\n    (with-c-syntax ()\n      {\n      for \\( i = 0 \\; i < 100 \\; ++ i \\)\n         sum += i \\;\n      })\n    sum))\n\n(test-for-loop) ; => 5050\n```\n\n`for` ループ, 代入演算子 (`=` と `+=`), 二項演算 (`<`), インクリメントも使えます。\n\n## ループを break したり continue したり Lisp 式を混ぜたり\n```cl\n;; 50 未満の偶数の和を取る\n(defun test-loop-continue-break ()\n  (with-c-syntax ((i 0) (sum 0))\n   {\n    for \\( i = 0 \\; i < 100 \\; ++ i \\) {\n      if \\( (oddp i) \\) ; Lisp 関数 oddp\n        continue \\;\n      if \\( i == 50 \\)\n        break \\;\n      sum += i \\;\n      (format t \"i ~A, sum ~A~%\" i sum) \\; ; Lisp 関数 format\n    }\n   return sum \\;\n   }))\n\n(test-loop-continue-break) ; => 600\n```\n\nC 系言語でお馴染みの `continue`, `break` は、みなさんご存知の挙動をします。\nLisp 式を混ぜ込むことも可能です。括弧をエスケープしなければ、 Lisp の括弧として解釈されます。\n\n## switch-case しよう\n```cl \n(defun test-switch ()\n  (flet ((fun (x)\n           (with-c-syntax ((x x))\n    {\n      format \\( t \\, \"[~A] \" \\, x \\) \\;\n      switch \\( x \\) {\n      case 1 \\:\n        (format t \"case 1~%\") \\;\n        break \\;\n      case 2 \\:\n        (format t \"case 2~%\") \\;\n        (format t \"fall-though 2->3~%\") \\;\n      case 3 \\:\n        (format t \"case 3~%\") \\;\n        break \\;\n      case 4 \\:\n        (format t \"case 4~%\") \\;\n        break \\;\n      default \\:\n        (format t \"default~%\") \\;\n      }\n    })))\n    (loop for i from 0 to 5\n       do (fun i))))\n\n(test-switch)\n;; 以下のように印字される\n#|\n[0] default\n[1] case 1\n[2] case 2\nfall-though 2->3\ncase 3\n[3] case 3\n[4] case 4\n[5] default\n|#\n```\n\n`switch` - `case` もそのままに。 `switch` 文で `break` を忘れると fall through しちゃうのもそのまま再現!!\n\n## goto 無双\n```cl\n(defun test-goto ()\n  (with-c-syntax ()\n    {\n      goto d \\;\n    a \\:\n      princ \\( \"a\" \\) \\;\n    b \\:\n      princ \\( \"b\" \\) \\;\n      goto e \\;\n    c \\:\n      princ \\( \"c\" \\) \\;\n      return \\;\n    d \\:\n      princ \\( \"d\" \\) \\;\n      goto a \\;  \n    e \\:\n      princ \\( \"e\" \\) \\;\n      goto c \\;\n    })\n  )\n\n(test-goto)\n;; 以下のように印字される\n#|\ndabec\n|#\n```\n\nCommon Lisp においても、 `goto` はとても重要な制御構文です。\n\n## Duff's Device\n```cl \n(defun test-duff-device (to-seq from-seq cnt)\n  (with-c-syntax ((to-seq to-seq) (from-seq from-seq) (cnt cnt)\n                  to from n)\n    {\n    to = & to-seq \\;          ; produces a pointer\n    from = & from-seq \\;      ; (same as above)\n\n    n = \\( cnt + 7 \\) / 8 \\;\n    n = floor \\( n \\) \\;                ; CL:/ produces rational. cast it.\n    switch \\( cnt % 8 \\) {\n    case 0 \\:\tdo {\t* to ++ = * from ++ \\;\n    case 7 \\:\t\t* to ++ = * from ++ \\;\n    case 6 \\:\t\t* to ++ = * from ++ \\;\n    case 5 \\:\t\t* to ++ = * from ++ \\;\n    case 4 \\:\t\t* to ++ = * from ++ \\;\n    case 3 \\:\t\t* to ++ = * from ++ \\;\n    case 2 \\:\t\t* to ++ = * from ++ \\;\n    case 1 \\:\t\t* to ++ = * from ++ \\;\n      } while \\( -- n > 0 \\) \\;\n    }\n    })\n  to-seq)\n\n#| \n実行例\n\nCL-USER> (setf arr1 (make-array 20 :initial-element 1))\n#(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\nCL-USER> (setf arr2 (make-array 20 :initial-element 2))\n#(2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2)\nCL-USER> (test-duff-device arr1 arr2 10)\n#(2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1)\nCL-USER> arr1\n#(2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1)\n```\n\nこんな *とんでもなく曲がりくねった* コードだって使えてしまいます。\n\n# 現在の実装の進捗\n式 (Expression) と、文 (statement) は、ほぼ何でも処理できます。未対応なのは、 `sizeof` と, キャスト演算だけです。\n\n一方、宣言 (declaration) は一切使えません。そのため、 `with-c-syntax` 内部で変数を作れないという重大な制限があります。これは直します。\n\nまた、 Lisp リーダが独自の解釈をする文字にはエスケープが必要だったり、くっついてしまう文字には空白を入れて離す必要があったりします。これは適切なリーダーマクロを用意することによって解決できる予定です。\n\n# コード\nコードはこちら\n\nhttps://github.com/y2q-actionman/with-c-syntax.git\n\n# 蛇足: 実装詳細\n## 大枠\n1. C の BNF を拾う\n2. `cl-yacc` に掛けて、パーザを作る。\n3. パーザを使い、 C 言語的シンボル列を Lisp 式に変換して吐かせる。\n4. マクロでユーザの渡した式を受けとれるようにする。\n\n以下、変換例とともに、実装を解説します。\n\n## 式 (expression) の変換\n\n### 単純な式\n単項演算子や二項演算子について、その文法の読みかえをすることが大部分の仕事です。\nそしてこれは、 `cl-yacc` にちょっとアクションを仕込むだけで終わりです。\n\n以下のような感じです:\n\n```c\nx + y     // -> (+ x y)\nx < y     // -> (< x y)\nx || y    // -> (or x y)   ;; CL:or も短絡的なのでそのまま使用\n\nx ? y : z // -> (if x y z) ;; CL:if をそのまま使用\n\n!x        // -> (not x)\n\nx[y]      // -> (aref x y) \nx(y)      // -> (x y)      ;; x を関数だと思って呼び出し\nx.y       // -> (y x)      ;; y を構造体の reader function と思って呼び出し\n```\n\n### 代入演算子, インクリメント, デクリメント\nこれらは、 *代入先は `setf` 可能な場所である* と決め打ちして、 `setf` に展開しています。\n\n```c\nx = 2     // -> (setf x 2)\nx++       // -> (incf x)\n```\n\n`+=` などは、 `let` で中間結果をバインドするように展開します:\n\n```c\nx += 2    // -> (LET ((#:G1016 X)) (SETF X (+ #:G1016 2)))\n```\n\nこれについては、 `define-modify-macro` を使って、もっと実装上の記述を簡単にする手段はありそうです。\n\n\nインクリメントとデクリメントには、それぞれ `incf`, `decf` を使用しています。\nしかしいわゆる post-increment は、 `let` を使用する形で展開しています。\n\n```c\n++x       // -> (incf x)\nx++       // ->  (LET ((#:G1017 X)) (SETF X (+ #:G1017 1))\n\n```\n\n### ポインタ\n私の知るかぎり、 Common Lisp には、任意の場所を指すことが出来て、しかも整数型を同じような演算が出来るような型がありません。\n\n仕方がないので、 `pseudo-pointer` なるものを自作しています。\n詳細は、稿を改めて書く予定です。\n\n### キャスト, sizeof\nこれらは、現在は実装できていません。\n\nキャストの実装には、 C 言語の宣言の構文を解釈し、対応する型を引き出す必要があります。\n`sizeof` の実装には、さらにそれらが占めるメモリ領域を知る必要があります。\n\n宣言の構文を解釈することが出来れば、キャストは実装できるでしょう。\nしかし、 `sizeof` は面倒そうです。\n\n## 文 (statement) の変換\n\n### `goto`\nいきなり `goto` からです。これをサポートすることが、この実装の大枠に影響しています。\n\nCommon Lisp で `goto` といえば、 `tagbody` と `go` であり、今回の実装もそれを使っています。\n`tagbody` では、 lexical に見えている go tag に `go` して飛ぶことが出来ます。\n\nさて、 C 言語の goto ラベルは、恐るべきことに関数全体にスコープがあります。そのため、 `goto` は複文の中でもどこにでも飛べなければなりません。つまりこれを `tagbody` で実装するには、全ての複文をフラットに展開して、 go tag が `tagbody` から見えるようにする必要があるのです! これが、この後の全てに影響しています。\n\n例:\n\n```cl\n(with-c-syntax ()\n  {\n    goto d \\;\n\n  a \\:\n    princ \\( \"a\" \\) \\;\n\n  b \\:\n    princ \\( \"b\" \\) \\;\n    goto e \\;\n\n  c \\:\n    princ \\( \"c\" \\) \\;\n    return \\;\n\n  d \\:\n    princ \\( \"d\" \\) \\;\n    goto a \\;  \n  \n  e \\:\n    princ \\( \"e\" \\) \\;\n    goto c \\;\n  })\n```\n\n展開結果では、暗黙的な `tagbody` を含む `prog` を使っています。\n\n```cl\n(PROG ()\n   (GO D)\n  A\n   (PRINC \"a\")\n  B\n   (PRINC \"b\")\n   (GO E)\n  C\n   (PRINC \"c\")\n   (RETURN (VALUES))\n  D\n   (PRINC \"d\")\n   (GO A)\n  E\n   (PRINC \"e\")\n   (GO C))\n```\n\n### `if`\n`if` は、そのまま Common Lisp の `if` にすればいいかと思われますが、 `if` の節の中に goto ラベルが含まれていることが考えられるため、 `tagbody` を使う形に展開されます。\nthen 節 と else 節のそれぞれについて `gensym` で go tag を付け、冒頭でそこへの `go` をします。\n\n例:\n\n```cl\n(with-c-syntax ()\n  {\n  if \\( x \\) {\n    1 + 2 \\;\n  } else {\n    2 + 4 \\;\n  }\n  })\n```\n\n展開結果:\n\n```cl\n(PROG ()\n  (IF X\n      (GO #:|(if then)1053|)\n      (GO #:|(if else)1054|))\n #:|(if then)1053|\n  (+ 1 2)\n  (GO #:|(if end)1055|)\n #:|(if else)1054|\n  (+ 2 4)\n  (GO #:|(if end)1055|)\n #:|(if end)1055|))))\n```\n\n### ループ構文\nループも `tagbody` を使う形に展開します。以下の場所に飛ぶ可能性があるので、 go tag を仕込んで展開します:\n\n* ループの条件節 (ループの本体から、もしくは `while`, `for` ループの初回と、 `continue`)\n* ループの本体 (ループの条件節から、もしくは `do`-`while` の初回)\n* ループの出口 (ループの条件節から、もしくは `break`)\n\n(展開結果は、長いので略)\n\n### `switch` と `case`\nこんな感じです:\n\n* `case` や `default` を見つけたら、 go tag を `gensym` する。それをスペシャル変数に貯めておく。\n* `switch` を見つけたら、値を計算して `go` するジャンプテーブルを作る。\n* `break` での飛び先を `gensym` して展開する。\n\n(展開結果は、長いので略)\n\n### return\nこれには、 Common Lisp の `return` をそのまま使っています。展開された構文全体を、名前が `nil` の `block` で囲うことで、 `return` で脱出できます。\n\nここでは、 `tagbody` と 名前が `nil` の `block` で囲うことの両方の機能を持つ `prog` を使っています。\n\n例:\n\n```cl\n  (with-c-syntax ()\n    {\n    return 1 + 2 \\;\n    })\n```\n\n展開結果:\n\n```cl\n(PROG () (RETURN (+ 1 2)))\n```\n\n",
        "body": "<h1>\n        <span id=\"1-1\" class=\"fragment\"></span>\n        <a href=\"#1-1\"><i class=\"fa fa-link\"></i></a>ストーリー\n      </h1><p>Lisp は、「括弧が多く」「前置記法」であることにより、利用者が伸び悩んでいると言われている。Lisper 共にとっては、記法など見栄えの問題に過ぎず、これを省みる者はいない。とはいえ、中置記法に染められた人々が一定数いるということもまた事実であろう。</p>\n<p>これは、彼らをこちらにいざなうために、中置記法を取り入れてみる一つの実験である。</p>\n<h1>\n        <span id=\"1-2\" class=\"fragment\"></span>\n        <a href=\"#1-2\"><i class=\"fa fa-link\"></i></a>真のストーリー: 私の体験\n      </h1><p>あるデータ構造を、 Common Lisp で実装しようと思い立ちました。そのデータ構造には、既に C 言語での実装があったので、「まあ元々の論文を読むのは面倒だし、とりあえずアルゴリズムをコピペするか」と思っていました。</p>\n<p>そこで私は思ったのです: <strong>Common Lisp の配列参照は面倒すぎる!</strong></p>\n<p>例えば、以下の C の式を考えます:</p>\n<div class=\"code-frame\" data-lang=\"c\"><div class=\"highlight\"><pre><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"p\">[</span> <span class=\"n\">z</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n</pre></div></div><p>これが、 Common Lisp だと:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">setf</span> <span class=\"p\">(</span><span class=\"nb\">aref</span> <span class=\"nv\">x</span> <span class=\"nv\">i</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nb\">1-</span> <span class=\"p\">(</span><span class=\"nb\">aref</span> <span class=\"nv\">y</span> <span class=\"p\">(</span><span class=\"nb\">1+</span> <span class=\"p\">(</span><span class=\"nb\">aref</span> <span class=\"nv\">z</span> <span class=\"p\">(</span><span class=\"nb\">1+</span> <span class=\"nv\">i</span><span class=\"p\">))))))</span>\n</pre></div></div><p>Common Lisp 版は、なんだかよく分からない気がします。配列参照についてくらい、DSL的な感じで C 言語の構文を取り入れられないかしら、と思ったのです。</p>\n<p>というわけで何かいろいろやっていたら・・配列参照以外も、結構な C の構文が食えるようになってしまいました。</p>\n<h1>\n        <span id=\"1-3\" class=\"fragment\"></span>\n        <a href=\"#1-3\"><i class=\"fa fa-link\"></i></a>書いたもの: with-c-syntax マクロ\n      </h1><h2>\n        <span id=\"2-1\" class=\"fragment\"></span>\n        <a href=\"#2-1\"><i class=\"fa fa-link\"></i></a>Hello, World!\n      </h2><div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nv\">with-c-syntax</span> <span class=\"p\">()</span>\n<span class=\"nv\">{</span>\n   <span class=\"nb\">print</span> <span class=\"nv\">\\(</span> <span class=\"s\">&quot;Hello, World!&quot;</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n<span class=\"nv\">}</span><span class=\"p\">)</span>\n</pre></div></div><p><code>with-c-syntax</code> とつけて括弧で囲めば、その中では C 言語的な構文が使い放題。そんなマクロです。<br>\n<code>( ) ;</code> という文字は、 Lisp では特殊な意味があるのでエスケープを付けています。</p>\n<h2>\n        <span id=\"2-2\" class=\"fragment\"></span>\n        <a href=\"#2-2\"><i class=\"fa fa-link\"></i></a>値を返してみる\n      </h2><div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">test-add-args</span> <span class=\"p\">(</span><span class=\"nv\">x</span> <span class=\"nv\">y</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nv\">with-c-syntax</span> <span class=\"p\">()</span>\n    <span class=\"nv\">{</span>\n    <span class=\"nb\">return</span> <span class=\"nv\">x</span> <span class=\"nb\">+</span> <span class=\"nv\">y</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">}</span><span class=\"p\">)</span>\n  <span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"nv\">test-add-args</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"c1\">; =&gt; 3</span>\n</pre></div></div><p>lexical に見えている変数なら、そのまま参照することが出来ます。</p>\n<h2>\n        <span id=\"2-3\" class=\"fragment\"></span>\n        <a href=\"#2-3\"><i class=\"fa fa-link\"></i></a>for ループで、 1 から 100 まで足そう\n      </h2><div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">test-for-loop</span> <span class=\"p\">()</span>\n  <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">i</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">sum</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n    <span class=\"p\">(</span><span class=\"nv\">with-c-syntax</span> <span class=\"p\">()</span>\n      <span class=\"nv\">{</span>\n      <span class=\"nv\">for</span> <span class=\"nv\">\\(</span> <span class=\"nv\">i</span> <span class=\"nb\">=</span> <span class=\"mi\">0</span> <span class=\"nv\">\\;</span> <span class=\"nv\">i</span> <span class=\"nb\">&lt;</span> <span class=\"mi\">100</span> <span class=\"nv\">\\;</span> <span class=\"nv\">++</span> <span class=\"nv\">i</span> <span class=\"nv\">\\)</span>\n         <span class=\"nv\">sum</span> <span class=\"nv\">+=</span> <span class=\"nv\">i</span> <span class=\"nv\">\\;</span>\n      <span class=\"nv\">}</span><span class=\"p\">)</span>\n    <span class=\"nv\">sum</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"nv\">test-for-loop</span><span class=\"p\">)</span> <span class=\"c1\">; =&gt; 5050</span>\n</pre></div></div><p><code>for</code> ループ, 代入演算子 (<code>=</code> と <code>+=</code>), 二項演算 (<code>&lt;</code>), インクリメントも使えます。</p>\n<h2>\n        <span id=\"2-4\" class=\"fragment\"></span>\n        <a href=\"#2-4\"><i class=\"fa fa-link\"></i></a>ループを break したり continue したり Lisp 式を混ぜたり\n      </h2><div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"c1\">;; 50 未満の偶数の和を取る</span>\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">test-loop-continue-break</span> <span class=\"p\">()</span>\n  <span class=\"p\">(</span><span class=\"nv\">with-c-syntax</span> <span class=\"p\">((</span><span class=\"nv\">i</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">sum</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n   <span class=\"nv\">{</span>\n    <span class=\"nv\">for</span> <span class=\"nv\">\\(</span> <span class=\"nv\">i</span> <span class=\"nb\">=</span> <span class=\"mi\">0</span> <span class=\"nv\">\\;</span> <span class=\"nv\">i</span> <span class=\"nb\">&lt;</span> <span class=\"mi\">100</span> <span class=\"nv\">\\;</span> <span class=\"nv\">++</span> <span class=\"nv\">i</span> <span class=\"nv\">\\)</span> <span class=\"nv\">{</span>\n      <span class=\"k\">if</span> <span class=\"nv\">\\(</span> <span class=\"p\">(</span><span class=\"nb\">oddp</span> <span class=\"nv\">i</span><span class=\"p\">)</span> <span class=\"nv\">\\)</span> <span class=\"c1\">; Lisp 関数 oddp</span>\n        <span class=\"nb\">continue</span> <span class=\"nv\">\\;</span>\n      <span class=\"k\">if</span> <span class=\"nv\">\\(</span> <span class=\"nv\">i</span> <span class=\"nv\">==</span> <span class=\"mi\">50</span> <span class=\"nv\">\\)</span>\n        <span class=\"nb\">break</span> <span class=\"nv\">\\;</span>\n      <span class=\"nv\">sum</span> <span class=\"nv\">+=</span> <span class=\"nv\">i</span> <span class=\"nv\">\\;</span>\n      <span class=\"p\">(</span><span class=\"nb\">format</span> <span class=\"no\">t</span> <span class=\"s\">&quot;i ~A, sum ~A~%&quot;</span> <span class=\"nv\">i</span> <span class=\"nv\">sum</span><span class=\"p\">)</span> <span class=\"nv\">\\;</span> <span class=\"c1\">; Lisp 関数 format</span>\n    <span class=\"nv\">}</span>\n   <span class=\"nb\">return</span> <span class=\"nv\">sum</span> <span class=\"nv\">\\;</span>\n   <span class=\"nv\">}</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"nv\">test-loop-continue-break</span><span class=\"p\">)</span> <span class=\"c1\">; =&gt; 600</span>\n</pre></div></div><p>C 系言語でお馴染みの <code>continue</code>, <code>break</code> は、みなさんご存知の挙動をします。<br>\nLisp 式を混ぜ込むことも可能です。括弧をエスケープしなければ、 Lisp の括弧として解釈されます。</p>\n<h2>\n        <span id=\"2-5\" class=\"fragment\"></span>\n        <a href=\"#2-5\"><i class=\"fa fa-link\"></i></a>switch-case しよう\n      </h2><div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">test-switch</span> <span class=\"p\">()</span>\n  <span class=\"p\">(</span><span class=\"k\">flet</span> <span class=\"p\">((</span><span class=\"nv\">fun</span> <span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">)</span>\n           <span class=\"p\">(</span><span class=\"nv\">with-c-syntax</span> <span class=\"p\">((</span><span class=\"nv\">x</span> <span class=\"nv\">x</span><span class=\"p\">))</span>\n    <span class=\"nv\">{</span>\n      <span class=\"nb\">format</span> <span class=\"nv\">\\(</span> <span class=\"no\">t</span> <span class=\"nv\">\\,</span> <span class=\"s\">&quot;[~A] &quot;</span> <span class=\"nv\">\\,</span> <span class=\"nv\">x</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n      <span class=\"nv\">switch</span> <span class=\"nv\">\\(</span> <span class=\"nv\">x</span> <span class=\"nv\">\\)</span> <span class=\"nv\">{</span>\n      <span class=\"nb\">case</span> <span class=\"mi\">1</span> <span class=\"nv\">\\:</span>\n        <span class=\"p\">(</span><span class=\"nb\">format</span> <span class=\"no\">t</span> <span class=\"s\">&quot;case 1~%&quot;</span><span class=\"p\">)</span> <span class=\"nv\">\\;</span>\n        <span class=\"nb\">break</span> <span class=\"nv\">\\;</span>\n      <span class=\"nb\">case</span> <span class=\"mi\">2</span> <span class=\"nv\">\\:</span>\n        <span class=\"p\">(</span><span class=\"nb\">format</span> <span class=\"no\">t</span> <span class=\"s\">&quot;case 2~%&quot;</span><span class=\"p\">)</span> <span class=\"nv\">\\;</span>\n        <span class=\"p\">(</span><span class=\"nb\">format</span> <span class=\"no\">t</span> <span class=\"s\">&quot;fall-though 2-&gt;3~%&quot;</span><span class=\"p\">)</span> <span class=\"nv\">\\;</span>\n      <span class=\"nb\">case</span> <span class=\"mi\">3</span> <span class=\"nv\">\\:</span>\n        <span class=\"p\">(</span><span class=\"nb\">format</span> <span class=\"no\">t</span> <span class=\"s\">&quot;case 3~%&quot;</span><span class=\"p\">)</span> <span class=\"nv\">\\;</span>\n        <span class=\"nb\">break</span> <span class=\"nv\">\\;</span>\n      <span class=\"nb\">case</span> <span class=\"mi\">4</span> <span class=\"nv\">\\:</span>\n        <span class=\"p\">(</span><span class=\"nb\">format</span> <span class=\"no\">t</span> <span class=\"s\">&quot;case 4~%&quot;</span><span class=\"p\">)</span> <span class=\"nv\">\\;</span>\n        <span class=\"nb\">break</span> <span class=\"nv\">\\;</span>\n      <span class=\"nv\">default</span> <span class=\"nv\">\\:</span>\n        <span class=\"p\">(</span><span class=\"nb\">format</span> <span class=\"no\">t</span> <span class=\"s\">&quot;default~%&quot;</span><span class=\"p\">)</span> <span class=\"nv\">\\;</span>\n      <span class=\"nv\">}</span>\n    <span class=\"nv\">}</span><span class=\"p\">)))</span>\n    <span class=\"p\">(</span><span class=\"nb\">loop</span> <span class=\"nv\">for</span> <span class=\"nv\">i</span> <span class=\"nv\">from</span> <span class=\"mi\">0</span> <span class=\"nv\">to</span> <span class=\"mi\">5</span>\n       <span class=\"nb\">do</span> <span class=\"p\">(</span><span class=\"nv\">fun</span> <span class=\"nv\">i</span><span class=\"p\">))))</span>\n\n<span class=\"p\">(</span><span class=\"nv\">test-switch</span><span class=\"p\">)</span>\n<span class=\"c1\">;; 以下のように印字される</span>\n<span class=\"cm\">#|</span>\n<span class=\"cm\">[0] default</span>\n<span class=\"cm\">[1] case 1</span>\n<span class=\"cm\">[2] case 2</span>\n<span class=\"cm\">fall-though 2-&gt;3</span>\n<span class=\"cm\">case 3</span>\n<span class=\"cm\">[3] case 3</span>\n<span class=\"cm\">[4] case 4</span>\n<span class=\"cm\">[5] default</span>\n<span class=\"cm\">|#</span>\n</pre></div></div><p><code>switch</code> - <code>case</code> もそのままに。 <code>switch</code> 文で <code>break</code> を忘れると fall through しちゃうのもそのまま再現!!</p>\n<h2>\n        <span id=\"2-6\" class=\"fragment\"></span>\n        <a href=\"#2-6\"><i class=\"fa fa-link\"></i></a>goto 無双\n      </h2><div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">test-goto</span> <span class=\"p\">()</span>\n  <span class=\"p\">(</span><span class=\"nv\">with-c-syntax</span> <span class=\"p\">()</span>\n    <span class=\"nv\">{</span>\n      <span class=\"nv\">goto</span> <span class=\"nv\">d</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">a</span> <span class=\"nv\">\\:</span>\n      <span class=\"nb\">princ</span> <span class=\"nv\">\\(</span> <span class=\"s\">&quot;a&quot;</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">b</span> <span class=\"nv\">\\:</span>\n      <span class=\"nb\">princ</span> <span class=\"nv\">\\(</span> <span class=\"s\">&quot;b&quot;</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n      <span class=\"nv\">goto</span> <span class=\"nv\">e</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">c</span> <span class=\"nv\">\\:</span>\n      <span class=\"nb\">princ</span> <span class=\"nv\">\\(</span> <span class=\"s\">&quot;c&quot;</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n      <span class=\"nb\">return</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">d</span> <span class=\"nv\">\\:</span>\n      <span class=\"nb\">princ</span> <span class=\"nv\">\\(</span> <span class=\"s\">&quot;d&quot;</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n      <span class=\"nv\">goto</span> <span class=\"nv\">a</span> <span class=\"nv\">\\;</span>  \n    <span class=\"nv\">e</span> <span class=\"nv\">\\:</span>\n      <span class=\"nb\">princ</span> <span class=\"nv\">\\(</span> <span class=\"s\">&quot;e&quot;</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n      <span class=\"nv\">goto</span> <span class=\"nv\">c</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">}</span><span class=\"p\">)</span>\n  <span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"nv\">test-goto</span><span class=\"p\">)</span>\n<span class=\"c1\">;; 以下のように印字される</span>\n<span class=\"cm\">#|</span>\n<span class=\"cm\">dabec</span>\n<span class=\"cm\">|#</span>\n</pre></div></div><p>Common Lisp においても、 <code>goto</code> はとても重要な制御構文です。</p>\n<h2>\n        <span id=\"2-7\" class=\"fragment\"></span>\n        <a href=\"#2-7\"><i class=\"fa fa-link\"></i></a>Duff&#39;s Device\n      </h2><div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">test-duff-device</span> <span class=\"p\">(</span><span class=\"nv\">to-seq</span> <span class=\"nv\">from-seq</span> <span class=\"nv\">cnt</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nv\">with-c-syntax</span> <span class=\"p\">((</span><span class=\"nv\">to-seq</span> <span class=\"nv\">to-seq</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">from-seq</span> <span class=\"nv\">from-seq</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">cnt</span> <span class=\"nv\">cnt</span><span class=\"p\">)</span>\n                  <span class=\"nv\">to</span> <span class=\"nv\">from</span> <span class=\"nv\">n</span><span class=\"p\">)</span>\n    <span class=\"nv\">{</span>\n    <span class=\"nv\">to</span> <span class=\"nb\">=</span> <span class=\"nv\">&amp;</span> <span class=\"nv\">to-seq</span> <span class=\"nv\">\\;</span>          <span class=\"c1\">; produces a pointer</span>\n    <span class=\"nv\">from</span> <span class=\"nb\">=</span> <span class=\"nv\">&amp;</span> <span class=\"nv\">from-seq</span> <span class=\"nv\">\\;</span>      <span class=\"c1\">; (same as above)</span>\n\n    <span class=\"nv\">n</span> <span class=\"nb\">=</span> <span class=\"nv\">\\(</span> <span class=\"nv\">cnt</span> <span class=\"nb\">+</span> <span class=\"mi\">7</span> <span class=\"nv\">\\)</span> <span class=\"nb\">/</span> <span class=\"mi\">8</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">n</span> <span class=\"nb\">=</span> <span class=\"nb\">floor</span> <span class=\"nv\">\\(</span> <span class=\"nv\">n</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>                <span class=\"c1\">; CL:/ produces rational. cast it.</span>\n    <span class=\"nv\">switch</span> <span class=\"nv\">\\(</span> <span class=\"nv\">cnt</span> <span class=\"nv\">%</span> <span class=\"mi\">8</span> <span class=\"nv\">\\)</span> <span class=\"nv\">{</span>\n    <span class=\"nb\">case</span> <span class=\"mi\">0</span> <span class=\"nv\">\\:</span>   <span class=\"nb\">do</span> <span class=\"nv\">{</span>    <span class=\"nb\">*</span> <span class=\"nv\">to</span> <span class=\"nv\">++</span> <span class=\"nb\">=</span> <span class=\"nb\">*</span> <span class=\"nv\">from</span> <span class=\"nv\">++</span> <span class=\"nv\">\\;</span>\n    <span class=\"nb\">case</span> <span class=\"mi\">7</span> <span class=\"nv\">\\:</span>       <span class=\"nb\">*</span> <span class=\"nv\">to</span> <span class=\"nv\">++</span> <span class=\"nb\">=</span> <span class=\"nb\">*</span> <span class=\"nv\">from</span> <span class=\"nv\">++</span> <span class=\"nv\">\\;</span>\n    <span class=\"nb\">case</span> <span class=\"mi\">6</span> <span class=\"nv\">\\:</span>       <span class=\"nb\">*</span> <span class=\"nv\">to</span> <span class=\"nv\">++</span> <span class=\"nb\">=</span> <span class=\"nb\">*</span> <span class=\"nv\">from</span> <span class=\"nv\">++</span> <span class=\"nv\">\\;</span>\n    <span class=\"nb\">case</span> <span class=\"mi\">5</span> <span class=\"nv\">\\:</span>       <span class=\"nb\">*</span> <span class=\"nv\">to</span> <span class=\"nv\">++</span> <span class=\"nb\">=</span> <span class=\"nb\">*</span> <span class=\"nv\">from</span> <span class=\"nv\">++</span> <span class=\"nv\">\\;</span>\n    <span class=\"nb\">case</span> <span class=\"mi\">4</span> <span class=\"nv\">\\:</span>       <span class=\"nb\">*</span> <span class=\"nv\">to</span> <span class=\"nv\">++</span> <span class=\"nb\">=</span> <span class=\"nb\">*</span> <span class=\"nv\">from</span> <span class=\"nv\">++</span> <span class=\"nv\">\\;</span>\n    <span class=\"nb\">case</span> <span class=\"mi\">3</span> <span class=\"nv\">\\:</span>       <span class=\"nb\">*</span> <span class=\"nv\">to</span> <span class=\"nv\">++</span> <span class=\"nb\">=</span> <span class=\"nb\">*</span> <span class=\"nv\">from</span> <span class=\"nv\">++</span> <span class=\"nv\">\\;</span>\n    <span class=\"nb\">case</span> <span class=\"mi\">2</span> <span class=\"nv\">\\:</span>       <span class=\"nb\">*</span> <span class=\"nv\">to</span> <span class=\"nv\">++</span> <span class=\"nb\">=</span> <span class=\"nb\">*</span> <span class=\"nv\">from</span> <span class=\"nv\">++</span> <span class=\"nv\">\\;</span>\n    <span class=\"nb\">case</span> <span class=\"mi\">1</span> <span class=\"nv\">\\:</span>       <span class=\"nb\">*</span> <span class=\"nv\">to</span> <span class=\"nv\">++</span> <span class=\"nb\">=</span> <span class=\"nb\">*</span> <span class=\"nv\">from</span> <span class=\"nv\">++</span> <span class=\"nv\">\\;</span>\n      <span class=\"nv\">}</span> <span class=\"nv\">while</span> <span class=\"nv\">\\(</span> <span class=\"nv\">--</span> <span class=\"nv\">n</span> <span class=\"nb\">&gt;</span> <span class=\"mi\">0</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">}</span>\n    <span class=\"nv\">}</span><span class=\"p\">)</span>\n  <span class=\"nv\">to-seq</span><span class=\"p\">)</span>\n\n<span class=\"cm\">#| </span>\n<span class=\"cm\">実行例</span>\n\n<span class=\"cm\">CL-USER&gt; (setf arr1 (make-array 20 :initial-element 1))</span>\n<span class=\"cm\">#(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)</span>\n<span class=\"cm\">CL-USER&gt; (setf arr2 (make-array 20 :initial-element 2))</span>\n<span class=\"cm\">#(2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2)</span>\n<span class=\"cm\">CL-USER&gt; (test-duff-device arr1 arr2 10)</span>\n<span class=\"cm\">#(2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1)</span>\n<span class=\"cm\">CL-USER&gt; arr1</span>\n<span class=\"cm\">#(2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1)</span>\n</pre></div></div><p>こんな <em>とんでもなく曲がりくねった</em> コードだって使えてしまいます。</p>\n<h1>\n        <span id=\"1-4\" class=\"fragment\"></span>\n        <a href=\"#1-4\"><i class=\"fa fa-link\"></i></a>現在の実装の進捗\n      </h1><p>式 (Expression) と、文 (statement) は、ほぼ何でも処理できます。未対応なのは、 <code>sizeof</code> と, キャスト演算だけです。</p>\n<p>一方、宣言 (declaration) は一切使えません。そのため、 <code>with-c-syntax</code> 内部で変数を作れないという重大な制限があります。これは直します。</p>\n<p>また、 Lisp リーダが独自の解釈をする文字にはエスケープが必要だったり、くっついてしまう文字には空白を入れて離す必要があったりします。これは適切なリーダーマクロを用意することによって解決できる予定です。</p>\n<h1>\n        <span id=\"1-5\" class=\"fragment\"></span>\n        <a href=\"#1-5\"><i class=\"fa fa-link\"></i></a>コード\n      </h1><p>コードはこちら</p>\n<p><a href=\"https://github.com/y2q-actionman/with-c-syntax.git\" title=\"https://github.com/y2q-actionman/with-c-syntax.git\" target=\"_blank\">https://github.com/y2q-actionman/with-c-syntax.git</a></p>\n<h1>\n        <span id=\"1-6\" class=\"fragment\"></span>\n        <a href=\"#1-6\"><i class=\"fa fa-link\"></i></a>蛇足: 実装詳細\n      </h1><h2>\n        <span id=\"2-8\" class=\"fragment\"></span>\n        <a href=\"#2-8\"><i class=\"fa fa-link\"></i></a>大枠\n      </h2>\n<ol>\n<li>C の BNF を拾う</li>\n<li><code>cl-yacc</code> に掛けて、パーザを作る。</li>\n<li>パーザを使い、 C 言語的シンボル列を Lisp 式に変換して吐かせる。</li>\n<li>マクロでユーザの渡した式を受けとれるようにする。</li>\n</ol>\n<p>以下、変換例とともに、実装を解説します。</p>\n<h2>\n        <span id=\"2-9\" class=\"fragment\"></span>\n        <a href=\"#2-9\"><i class=\"fa fa-link\"></i></a>式 (expression) の変換\n      </h2><h3>\n        <span id=\"3-1\" class=\"fragment\"></span>\n        <a href=\"#3-1\"><i class=\"fa fa-link\"></i></a>単純な式\n      </h3><p>単項演算子や二項演算子について、その文法の読みかえをすることが大部分の仕事です。<br>\nそしてこれは、 <code>cl-yacc</code> にちょっとアクションを仕込むだけで終わりです。</p>\n<p>以下のような感じです:</p>\n<div class=\"code-frame\" data-lang=\"c\"><div class=\"highlight\"><pre><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span>     <span class=\"c1\">// -&gt; (+ x y)</span>\n<span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"n\">y</span>     <span class=\"c1\">// -&gt; (&lt; x y)</span>\n<span class=\"n\">x</span> <span class=\"o\">||</span> <span class=\"n\">y</span>    <span class=\"c1\">// -&gt; (or x y)   ;; CL:or も短絡的なのでそのまま使用</span>\n\n<span class=\"n\">x</span> <span class=\"o\">?</span> <span class=\"nl\">y</span> <span class=\"p\">:</span> <span class=\"n\">z</span> <span class=\"c1\">// -&gt; (if x y z) ;; CL:if をそのまま使用</span>\n\n<span class=\"o\">!</span><span class=\"n\">x</span>        <span class=\"c1\">// -&gt; (not x)</span>\n\n<span class=\"n\">x</span><span class=\"p\">[</span><span class=\"n\">y</span><span class=\"p\">]</span>      <span class=\"c1\">// -&gt; (aref x y) </span>\n<span class=\"n\">x</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>      <span class=\"c1\">// -&gt; (x y)      ;; x を関数だと思って呼び出し</span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">y</span>       <span class=\"c1\">// -&gt; (y x)      ;; y を構造体の reader function と思って呼び出し</span>\n</pre></div></div><h3>\n        <span id=\"3-2\" class=\"fragment\"></span>\n        <a href=\"#3-2\"><i class=\"fa fa-link\"></i></a>代入演算子, インクリメント, デクリメント\n      </h3><p>これらは、 <em>代入先は <code>setf</code> 可能な場所である</em> と決め打ちして、 <code>setf</code> に展開しています。</p>\n<div class=\"code-frame\" data-lang=\"c\"><div class=\"highlight\"><pre><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>     <span class=\"c1\">// -&gt; (setf x 2)</span>\n<span class=\"n\">x</span><span class=\"o\">++</span>       <span class=\"c1\">// -&gt; (incf x)</span>\n</pre></div></div><p><code>+=</code> などは、 <code>let</code> で中間結果をバインドするように展開します:</p>\n<div class=\"code-frame\" data-lang=\"c\"><div class=\"highlight\"><pre><span class=\"n\">x</span> <span class=\"o\">+=</span> <span class=\"mi\">2</span>    <span class=\"c1\">// -&gt; (LET ((#:G1016 X)) (SETF X (+ #:G1016 2)))</span>\n</pre></div></div><p>これについては、 <code>define-modify-macro</code> を使って、もっと実装上の記述を簡単にする手段はありそうです。</p>\n<p>インクリメントとデクリメントには、それぞれ <code>incf</code>, <code>decf</code> を使用しています。<br>\nしかしいわゆる post-increment は、 <code>let</code> を使用する形で展開しています。</p>\n<div class=\"code-frame\" data-lang=\"c\"><div class=\"highlight\"><pre><span class=\"o\">++</span><span class=\"n\">x</span>       <span class=\"c1\">// -&gt; (incf x)</span>\n<span class=\"n\">x</span><span class=\"o\">++</span>       <span class=\"c1\">// -&gt;  (LET ((#:G1017 X)) (SETF X (+ #:G1017 1))</span>\n</pre></div></div><h3>\n        <span id=\"3-3\" class=\"fragment\"></span>\n        <a href=\"#3-3\"><i class=\"fa fa-link\"></i></a>ポインタ\n      </h3><p>私の知るかぎり、 Common Lisp には、任意の場所を指すことが出来て、しかも整数型を同じような演算が出来るような型がありません。</p>\n<p>仕方がないので、 <code>pseudo-pointer</code> なるものを自作しています。<br>\n詳細は、稿を改めて書く予定です。</p>\n<h3>\n        <span id=\"3-4\" class=\"fragment\"></span>\n        <a href=\"#3-4\"><i class=\"fa fa-link\"></i></a>キャスト, sizeof\n      </h3><p>これらは、現在は実装できていません。</p>\n<p>キャストの実装には、 C 言語の宣言の構文を解釈し、対応する型を引き出す必要があります。<br>\n<code>sizeof</code> の実装には、さらにそれらが占めるメモリ領域を知る必要があります。</p>\n<p>宣言の構文を解釈することが出来れば、キャストは実装できるでしょう。<br>\nしかし、 <code>sizeof</code> は面倒そうです。</p>\n<h2>\n        <span id=\"2-10\" class=\"fragment\"></span>\n        <a href=\"#2-10\"><i class=\"fa fa-link\"></i></a>文 (statement) の変換\n      </h2><h3>\n        <span id=\"3-5\" class=\"fragment\"></span>\n        <a href=\"#3-5\"><i class=\"fa fa-link\"></i></a><code>goto</code>\n      </h3><p>いきなり <code>goto</code> からです。これをサポートすることが、この実装の大枠に影響しています。</p>\n<p>Common Lisp で <code>goto</code> といえば、 <code>tagbody</code> と <code>go</code> であり、今回の実装もそれを使っています。<br>\n<code>tagbody</code> では、 lexical に見えている go tag に <code>go</code> して飛ぶことが出来ます。</p>\n<p>さて、 C 言語の goto ラベルは、恐るべきことに関数全体にスコープがあります。そのため、 <code>goto</code> は複文の中でもどこにでも飛べなければなりません。つまりこれを <code>tagbody</code> で実装するには、全ての複文をフラットに展開して、 go tag が <code>tagbody</code> から見えるようにする必要があるのです! これが、この後の全てに影響しています。</p>\n<p>例:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nv\">with-c-syntax</span> <span class=\"p\">()</span>\n  <span class=\"nv\">{</span>\n    <span class=\"nv\">goto</span> <span class=\"nv\">d</span> <span class=\"nv\">\\;</span>\n\n  <span class=\"nv\">a</span> <span class=\"nv\">\\:</span>\n    <span class=\"nb\">princ</span> <span class=\"nv\">\\(</span> <span class=\"s\">&quot;a&quot;</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n\n  <span class=\"nv\">b</span> <span class=\"nv\">\\:</span>\n    <span class=\"nb\">princ</span> <span class=\"nv\">\\(</span> <span class=\"s\">&quot;b&quot;</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">goto</span> <span class=\"nv\">e</span> <span class=\"nv\">\\;</span>\n\n  <span class=\"nv\">c</span> <span class=\"nv\">\\:</span>\n    <span class=\"nb\">princ</span> <span class=\"nv\">\\(</span> <span class=\"s\">&quot;c&quot;</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n    <span class=\"nb\">return</span> <span class=\"nv\">\\;</span>\n\n  <span class=\"nv\">d</span> <span class=\"nv\">\\:</span>\n    <span class=\"nb\">princ</span> <span class=\"nv\">\\(</span> <span class=\"s\">&quot;d&quot;</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">goto</span> <span class=\"nv\">a</span> <span class=\"nv\">\\;</span>  \n\n  <span class=\"nv\">e</span> <span class=\"nv\">\\:</span>\n    <span class=\"nb\">princ</span> <span class=\"nv\">\\(</span> <span class=\"s\">&quot;e&quot;</span> <span class=\"nv\">\\)</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">goto</span> <span class=\"nv\">c</span> <span class=\"nv\">\\;</span>\n  <span class=\"nv\">}</span><span class=\"p\">)</span>\n</pre></div></div><p>展開結果では、暗黙的な <code>tagbody</code> を含む <code>prog</code> を使っています。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nv\">PROG</span> <span class=\"p\">()</span>\n   <span class=\"p\">(</span><span class=\"nv\">GO</span> <span class=\"nv\">D</span><span class=\"p\">)</span>\n  <span class=\"nv\">A</span>\n   <span class=\"p\">(</span><span class=\"nv\">PRINC</span> <span class=\"s\">&quot;a&quot;</span><span class=\"p\">)</span>\n  <span class=\"nv\">B</span>\n   <span class=\"p\">(</span><span class=\"nv\">PRINC</span> <span class=\"s\">&quot;b&quot;</span><span class=\"p\">)</span>\n   <span class=\"p\">(</span><span class=\"nv\">GO</span> <span class=\"nv\">E</span><span class=\"p\">)</span>\n  <span class=\"nv\">C</span>\n   <span class=\"p\">(</span><span class=\"nv\">PRINC</span> <span class=\"s\">&quot;c&quot;</span><span class=\"p\">)</span>\n   <span class=\"p\">(</span><span class=\"nv\">RETURN</span> <span class=\"p\">(</span><span class=\"nv\">VALUES</span><span class=\"p\">))</span>\n  <span class=\"nv\">D</span>\n   <span class=\"p\">(</span><span class=\"nv\">PRINC</span> <span class=\"s\">&quot;d&quot;</span><span class=\"p\">)</span>\n   <span class=\"p\">(</span><span class=\"nv\">GO</span> <span class=\"nv\">A</span><span class=\"p\">)</span>\n  <span class=\"nv\">E</span>\n   <span class=\"p\">(</span><span class=\"nv\">PRINC</span> <span class=\"s\">&quot;e&quot;</span><span class=\"p\">)</span>\n   <span class=\"p\">(</span><span class=\"nv\">GO</span> <span class=\"nv\">C</span><span class=\"p\">))</span>\n</pre></div></div><h3>\n        <span id=\"3-6\" class=\"fragment\"></span>\n        <a href=\"#3-6\"><i class=\"fa fa-link\"></i></a><code>if</code>\n      </h3><p><code>if</code> は、そのまま Common Lisp の <code>if</code> にすればいいかと思われますが、 <code>if</code> の節の中に goto ラベルが含まれていることが考えられるため、 <code>tagbody</code> を使う形に展開されます。<br>\nthen 節 と else 節のそれぞれについて <code>gensym</code> で go tag を付け、冒頭でそこへの <code>go</code> をします。</p>\n<p>例:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nv\">with-c-syntax</span> <span class=\"p\">()</span>\n  <span class=\"nv\">{</span>\n  <span class=\"k\">if</span> <span class=\"nv\">\\(</span> <span class=\"nv\">x</span> <span class=\"nv\">\\)</span> <span class=\"nv\">{</span>\n    <span class=\"mi\">1</span> <span class=\"nb\">+</span> <span class=\"mi\">2</span> <span class=\"nv\">\\;</span>\n  <span class=\"nv\">}</span> <span class=\"nv\">else</span> <span class=\"nv\">{</span>\n    <span class=\"mi\">2</span> <span class=\"nb\">+</span> <span class=\"mi\">4</span> <span class=\"nv\">\\;</span>\n  <span class=\"nv\">}</span>\n  <span class=\"nv\">}</span><span class=\"p\">)</span>\n</pre></div></div><p>展開結果:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nv\">PROG</span> <span class=\"p\">()</span>\n  <span class=\"p\">(</span><span class=\"nv\">IF</span> <span class=\"nv\">X</span>\n      <span class=\"p\">(</span><span class=\"nv\">GO</span> <span class=\"ss\">#:|(if then)1053|</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">GO</span> <span class=\"ss\">#:|(if else)1054|</span><span class=\"p\">))</span>\n <span class=\"ss\">#:|(if then)1053|</span>\n  <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nv\">GO</span> <span class=\"ss\">#:|(if end)1055|</span><span class=\"p\">)</span>\n <span class=\"ss\">#:|(if else)1054|</span>\n  <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"mi\">2</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nv\">GO</span> <span class=\"ss\">#:|(if end)1055|</span><span class=\"p\">)</span>\n <span class=\"ss\">#:|(if end)1055|</span><span class=\"p\">))))</span>\n</pre></div></div><h3>\n        <span id=\"3-7\" class=\"fragment\"></span>\n        <a href=\"#3-7\"><i class=\"fa fa-link\"></i></a>ループ構文\n      </h3><p>ループも <code>tagbody</code> を使う形に展開します。以下の場所に飛ぶ可能性があるので、 go tag を仕込んで展開します:</p>\n\n<ul>\n<li>ループの条件節 (ループの本体から、もしくは <code>while</code>, <code>for</code> ループの初回と、 <code>continue</code>)</li>\n<li>ループの本体 (ループの条件節から、もしくは <code>do</code>-<code>while</code> の初回)</li>\n<li>ループの出口 (ループの条件節から、もしくは <code>break</code>)</li>\n</ul>\n<p>(展開結果は、長いので略)</p>\n<h3>\n        <span id=\"3-8\" class=\"fragment\"></span>\n        <a href=\"#3-8\"><i class=\"fa fa-link\"></i></a><code>switch</code> と <code>case</code>\n      </h3><p>こんな感じです:</p>\n\n<ul>\n<li><code>case</code> や <code>default</code> を見つけたら、 go tag を <code>gensym</code> する。それをスペシャル変数に貯めておく。</li>\n<li><code>switch</code> を見つけたら、値を計算して <code>go</code> するジャンプテーブルを作る。</li>\n<li><code>break</code> での飛び先を <code>gensym</code> して展開する。</li>\n</ul>\n<p>(展開結果は、長いので略)</p>\n<h3>\n        <span id=\"3-9\" class=\"fragment\"></span>\n        <a href=\"#3-9\"><i class=\"fa fa-link\"></i></a>return\n      </h3><p>これには、 Common Lisp の <code>return</code> をそのまま使っています。展開された構文全体を、名前が <code>nil</code> の <code>block</code> で囲うことで、 <code>return</code> で脱出できます。</p>\n<p>ここでは、 <code>tagbody</code> と 名前が <code>nil</code> の <code>block</code> で囲うことの両方の機能を持つ <code>prog</code> を使っています。</p>\n<p>例:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>  <span class=\"p\">(</span><span class=\"nv\">with-c-syntax</span> <span class=\"p\">()</span>\n    <span class=\"nv\">{</span>\n    <span class=\"nb\">return</span> <span class=\"mi\">1</span> <span class=\"nb\">+</span> <span class=\"mi\">2</span> <span class=\"nv\">\\;</span>\n    <span class=\"nv\">}</span><span class=\"p\">)</span>\n</pre></div></div><p>展開結果:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nv\">PROG</span> <span class=\"p\">()</span> <span class=\"p\">(</span><span class=\"nv\">RETURN</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)))</span>\n</pre></div></div>",
        "stock_users": [
            "_billabel",
            "katochar",
            "kou_tana77",
            "ytsunetsune",
            "digitalbot@github",
            "JunSuzukiJapan@github",
            "youxkei"
        ]
    },
    {
        "id": 111911,
        "uuid": "c53f20c6fc5002833d3c",
        "user": {
            "id": 6090,
            "url_name": "guicho271828",
            "profile_image_url": "https://pbs.twimg.com/profile_images/378800000809306716/dbd9008f86c426eb255aadb7fb0b9769_normal.jpeg"
        },
        "title": "gitattributes に lisp用正規表現を入れて diff を見やすくした",
        "created_at": "2014-08-16 22:48:14 +0900",
        "updated_at": "2014-08-16 22:48:35 +0900",
        "created_at_in_words": "約1ヶ月",
        "updated_at_in_words": "約1ヶ月",
        "tags": [
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "Git",
                "url_name": "git",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/5d9ff7508a0c2d5bfa9536b6a0fe1864c11cee89/medium.jpg?1387912380",
                "versions": []
            }
        ],
        "stock_count": 3,
        "comment_count": 0,
        "url": "http://qiita.com/guicho271828/items/c53f20c6fc5002833d3c",
        "created_at_as_seconds": 1408196894,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "\nこれとか\n\nhttps://github.com/gonzojive/iolib/blob/master/.gitconfig\n\nこれとか(scala)\n\nhttp://akiomik.hatenablog.jp/entry/2013/12/20/004111\n\nこれとか(各種正規表現詰め合わせ) を参考に。\n\nhttps://gist.github.com/ruediger/5647207\n\n結局自分で使ったのはこれ\n\n```\n[diff \"lisp\"]\n# xfuncname = \"^(\\\\(.*)$\"\n# xfuncname = \"^(\\\\((cl-)?def(un|macro|method).*)$\"\nxfuncname = \"^(\\\\((def|.*let|with-).*)$\"\n```\n\n結果、diffはこうなります。いいね。defpackage/defvar/defun で区切られてる。\n\n![Screenshot_from_2014-08-16 22:46:35.png](https://qiita-image-store.s3.amazonaws.com/0/6090/8024c935-bfbf-05df-a1bf-96d9e03d36ba.png)\n\n",
        "body": "<p>これとか</p>\n<p><a href=\"https://github.com/gonzojive/iolib/blob/master/.gitconfig\" title=\"https://github.com/gonzojive/iolib/blob/master/.gitconfig\" target=\"_blank\">https://github.com/gonzojive/iolib/blob/master/.gitconfig</a></p>\n<p>これとか(scala)</p>\n<p><a href=\"http://akiomik.hatenablog.jp/entry/2013/12/20/004111\" title=\"http://akiomik.hatenablog.jp/entry/2013/12/20/004111\" target=\"_blank\">http://akiomik.hatenablog.jp/entry/2013/12/20/004111</a></p>\n<p>これとか(各種正規表現詰め合わせ) を参考に。</p>\n<p><a href=\"https://gist.github.com/ruediger/5647207\" title=\"https://gist.github.com/ruediger/5647207\" target=\"_blank\">https://gist.github.com/ruediger/5647207</a></p>\n<p>結局自分で使ったのはこれ</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>[diff &quot;lisp&quot;]\n# xfuncname = &quot;^(\\\\(.*)$&quot;\n# xfuncname = &quot;^(\\\\((cl-)?def(un|macro|method).*)$&quot;\nxfuncname = &quot;^(\\\\((def|.*let|with-).*)$&quot;\n</pre></div></div><p>結果、diffはこうなります。いいね。defpackage/defvar/defun で区切られてる。</p>\n<p><img src=\"https://qiita-image-store.s3.amazonaws.com/0/6090/8024c935-bfbf-05df-a1bf-96d9e03d36ba.png\" title=\"\" alt=\"Screenshot_from_2014-08-16 22:46:35.png\"></img></p>\n",
        "stock_users": [
            "kenbeese",
            "kasumani",
            "Reds"
        ]
    },
    {
        "id": 108644,
        "uuid": "6e8de68cc1b7295de3a6",
        "user": {
            "id": 12490,
            "url_name": "derui@github",
            "profile_image_url": "https://secure.gravatar.com/avatar/4652ce7ea075507613d7b982283f0c18?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png"
        },
        "title": "そうか、JavaScriptはLispだったのか！",
        "created_at": "2014-08-11 13:18:50 +0900",
        "updated_at": "2014-08-11 13:18:50 +0900",
        "created_at_in_words": "約1ヶ月",
        "updated_at_in_words": "約1ヶ月",
        "tags": [
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "JavaScript",
                "url_name": "javascript",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/c01023cf926d47b711747c9d00b00fd18dc6638a/medium.jpg?1364837881",
                "versions": []
            }
        ],
        "stock_count": 15,
        "comment_count": 0,
        "url": "http://qiita.com/derui@github/items/6e8de68cc1b7295de3a6",
        "created_at_as_seconds": 1407730730,
        "tweet": false,
        "gist_url": null,
        "private": false,
        "raw_body": "\n久々に盆休み含めて一週間ちょっとの休みをとれました。若干業務が不安ではありますがまぁそれはそれで。休みということもあるので、たまにはちょっとした記事を書きましょう。\n\n### なぜJavaScriptはわかりづらいのか、それはLispだから\n現場でそれまでJavaScriptを利用したことが無い人に、JavaScriptを説明すると大抵???という顔をされるケースが多いです。\n\n特に、クロージャや変数のスコープの話をすると特に？？？とされます。スコープとかは、JavaScriptがそもそも小規模のスクリプトのために開発された、という点もあるのだと思いますが、今回の記事で書かれている点も結構関係あるんじゃないかと思います。\n\nですが、以降の内容と（ソースはどこかでみたんですが）JavaScriptはそもそもLispを作りたかった人が、現代的？な記法でかけるようにしたもの、ということで、Lispの概念とか書き方になじみが無いからわかりにくいんじゃないか？という風に最近思ってきました。\n\nなお、私はLispといっても基本的にEmacs Lispですので、その辺よろしくお願いします。Emacs Lispも24以降はlexical letが導入されているので、ここからの話はそれを前提にしていきます。\n\n### Lispと対比すればわかりやすい・・・わけはない\nそもそもSIerやっていてEmacs使っている人を探す方が難しいので、それを抜きにしてLispを利用している人を捜すなんて何をいわんや、というところです。\n\nただ、言語の理解は、一種類のパラダイムだけではなく、複数のパラダイムによる重ね合わせをすると、非常に早く理解できると思います。\n\nではここからはLispとJavaScriptの構文＆仕様の対比を始めます。・・・オブジェクト指向とかはよくわかんないので勘弁してください。\n\n### Lisp == JavaScript\nLispをやったことないとか括弧が多い言語とだけ聞いたことがある人向けに、簡単にLispの記法を書いておきます。\n\n```\n(関数 引数...)\n\n上記の関数の部分には関数のシンボル、引数は対象の関数に対する任意の引数です。引数間はスペースで区切ります。\n関数の戻り値は、最後に実行された式の結果です。そのため、「戻り値の無い関数」というのは厳密にはありません。\n\n基本的なデータ型は以下です。\n\n\"文字列\"\n1 2.5 -1\nt\nnil\n'symbol\n\n重要なのは '（シングルクォート）です。これはクォートする、と言われ、'がついている式を書いてある通りに解釈することができます。このへんが多分Lispで一番わかりづらいです。私も未だにわかってるようなわかってないような。\n```\n\n#### トップレベル変数\n```emacslisp\n(defvar hoge 1) ;; => hoge\n```\n\n```javascript\nvar hoge = 1;\n```\n\nそのまんまですね。\nなお、それぞれ定義されていない変数にアクセスしようとするとundefied errorが発生します。\n\n#### 関数定義\n```emacslisp\n(defun square (s) \n  (* s s))\n\n(square 2) ;; => 4\n```\n\n```javascript\nfunction square(s) {\n  return s * s;\n}\n\nsquare(2); // => 4\n```\n\nこれも大体そのまんまですね。javascriptのfunctionキーワードは長すぎると思います。\n\n#### if/for/while\n```emacslisp\n(if (< 1 2)\n    \"foobar\"\n  \"hoge\") ;; => \"foobar\"\n\n(while t\n  (print 1))\n;; 無限ループ\n\n;; forループは構文（フォーム）として用意されていないので、loopマクロで。\n(loop for x in '(1 2 3 4 5)\n      when (cl-evenp x)\n      collect x) ;; => (2 4)\n```\n\n```javascript\nif (1 < 2) {\n  return 'foobar';\n} else {\n  return 'hoge';\n}\n\nwhile (true) {\n  console.log('1');\n}\n\nvar r = [];\nfor (var i = 0, s = [1,2,3,4,5];i < s.length;i++) {\n  if (s[i] / 2 === 0) {\n    r.push(s[i]);\n  }\n}\n```\n\nemacs lispにはfor文というのは存在しないので、ここではそのかわりにloopマクロを使っています。それ以外は大体わかりますね。\n\nただ、こういった構文は、C系統のシンタックスとLisp系統とでは大きく違う部分なので、さらっといきます。\n\n#### 無名関数\n```emacslisp\n(lambda (x) (= (/ x 2) 0))\n```\n\n```javascript\nfunction(x) {return x / 2 === 0;}\n```\n\nキーワードと括弧の使い方が違うくらいで大体一緒ですね。Lispでは上記の関数を実行するとt/nilが、JavaScriptではtrue/falseが返ってきます。\n\n#### true/false/null\n```emacslisp\nt   ;; => t\nnil ;; => nil\n```\n\n```javascript\ntrue\nfalse\nnull\nundefined\n```\nLispでは、nullとかfalseとかはほぼすべてnilで表されます。undefinedというものは基本的にない（はず）です。if文などでは、 **nilかそれ以外**で分岐するため、このへんはJavaScriptのtrue/falseの判定とは違います。false/nullが大体同じにみられるのはにてますね。\n\n#### 変数のスコープとローカル変数\n```elisp\n;; 同じ名前の変数はより内側のスコープで閉じられる\n(defvar x 1)\n(defun hoge (x) \n   (+ x x))\n(hoge 3) ;; => 6\n\n(defun hoge (x) \n  (let ((y 4))\n    (/ (* x x) y)))\n(hoge 10) ;; => 25\ny ;; => void-variableなエラー\n```\n注)なんかシンタックスがうまくついてくれないんですが、とりあえず。。。\n\n```javascript\nvar x = 1;\nfunction hoge(x) {\n  return x + x;\n}\nhoge(3);\n\nfunction hoge(x) {\n  var y = 4;\n  return x * x / y;\n}\nhoge(x);\ny // undefinedでエラー\n```\n\nこのへんからなんか似ている空気が漂ってきます。Lispのローカル変数は、原則としてlet（とその仲間）でのみ定義ができます。\n\nさて、ここがLispとJavaScriptが似ている点の一つです。JavaScriptを説明するとき、「なんでブロックスコープがないの？」と聞かれて、そう決まってるからそうだ、というしか無かった記憶があります。\nしかし、JavaScript ≒ Lispと考えて、上を対比させてみると、一つ気づきます。\n\nJavaScriptの仕様として、関数内のvarは **すべて関数の先頭で宣言されたこと**になります。これ、ちょうど上の例でいう二つ目のhoge関数の中身そのものになります。正確にいえばlet*だとは思いますが、それは細かい点なのでおいておきます。\n\nつまり、 **varが先頭に移動されるのは、functionの直後にletが一つしかおけないから** と考えると、この仕様は自明になります。\n\nなんで内側でlet作れなかったの、という点はありますが、まぁそれはそれで。\nそして、JavaScriptが関数スコープしかない、というのも、letが作れるのは関数の中だけ、という制限（Lispにはそんな制限ありません）があるのだと想像すれば容易いです。\n\n#### 関数の実行\n```emacslisp\n(let ((f (lambda (x) (* x x))))\n  (apply f '(2))\n  (funcall f 2))\n;; 結果はどちらも同じ\n```\n\n```javascript\nfunction f(x) {\n  return x * x;\n}\nf.apply(this, [2]);\nf.call(this, 2);\n```\nここがおそらく一番LispとJavaScriptで似ている点だと思います。なんでcall/applyという二種類の実行形式があるのか、という答えはここにあります。要はLispにあるからだと。\n\nLispでは配列とリストの区別があるため、Lispのapplyに渡している '(2)というのはあくまで **リスト**です。JavaScriptにはそんな区別はありませんが、その辺は些末な感じです。\n\n強いていえば、JavaScriptには関数の実行コンテキストを渡すことができますが、Lispの場合はその関数が定義された時点のコンテキストが保存されているため、そういったものがない、という点で、そういう意味ではJavaScriptのほうが柔軟（そしてわかりづらい）ですね。\n\n#### オブジェクト\n```emacslisp\n(let ((s '(\n           (foo . \"bar\")\n           (bar . \"foo\")\n           (numbers . 1))))\n  (cdr (assoc 'foo s)))\n;; => \"bar\"\n```\n\n```javascript\nvar s = {\n  foo : \"bar\",\n  bar : \"foo\",\n  numbers : 1\n};\ns.foo;\n```\nLispの方がかなりわかりづらいですが、このへんはちょっと割愛します。ですが、JavaScriptの連想配列とオブジェクトが同一である、というのは、Lispでいうリストと連想リストの関係みたいなもんじゃないかなー、と思います。オブジェクトのネストや関数の設定なども、連想リストに対して値を設定したりなんだりというのとほぼ変わりません。\n\n#### クロージャ\n```emacslisp\n(defun hoge (x)\n  (lambda (y)\n    (let ((w (* x y)))\n      (setq x (1+ x))\n      w)))\n\n(let ((f (hoge 2)))\n  (funcall f 4) ;; => 8\n  (funcall f 4) ;; => 12\n  )\n```\n注）lexical-letが有効になっていないと正しく動きません。\n\n```JavaScript\nfunction hoge(x) {\n  return funcation(y) {\n    var w = x * y;\n    x += 1;\n    return w;\n  }\n}\n\nvar f = hoge(2);\nf(4) ;; => 8\nf(4) ;; => 12\n```\n\nクロージャは、おそらくJavaScriptを誰かに伝えるときに一番？？？って顔をされるものだと思います（経験談）。これについては、LispでもJavaScriptでもあまり変わりません。\n\n### 結論：LispとJavaScriptは概念だけ似ている\n当然の結論ではありますが、文法とかはLispとJavaScriptは似ても似つかないものです。ただ、JavaScriptの根底の概念、特に関数やスコープといった部分では、JavaScriptは確かにLispに似ている、というかだいたい一緒、といえるんじゃ無いでしょうか。\n\n無理矢理感半端ないのはわかっていますが、ときにはこんなのもありということで。\n",
        "body": "<p>久々に盆休み含めて一週間ちょっとの休みをとれました。若干業務が不安ではありますがまぁそれはそれで。休みということもあるので、たまにはちょっとした記事を書きましょう。</p>\n<h3>\n        <span id=\"3-1\" class=\"fragment\"></span>\n        <a href=\"#3-1\"><i class=\"fa fa-link\"></i></a>なぜJavaScriptはわかりづらいのか、それはLispだから\n      </h3><p>現場でそれまでJavaScriptを利用したことが無い人に、JavaScriptを説明すると大抵???という顔をされるケースが多いです。</p>\n<p>特に、クロージャや変数のスコープの話をすると特に？？？とされます。スコープとかは、JavaScriptがそもそも小規模のスクリプトのために開発された、という点もあるのだと思いますが、今回の記事で書かれている点も結構関係あるんじゃないかと思います。</p>\n<p>ですが、以降の内容と（ソースはどこかでみたんですが）JavaScriptはそもそもLispを作りたかった人が、現代的？な記法でかけるようにしたもの、ということで、Lispの概念とか書き方になじみが無いからわかりにくいんじゃないか？という風に最近思ってきました。</p>\n<p>なお、私はLispといっても基本的にEmacs Lispですので、その辺よろしくお願いします。Emacs Lispも24以降はlexical letが導入されているので、ここからの話はそれを前提にしていきます。</p>\n<h3>\n        <span id=\"3-2\" class=\"fragment\"></span>\n        <a href=\"#3-2\"><i class=\"fa fa-link\"></i></a>Lispと対比すればわかりやすい・・・わけはない\n      </h3><p>そもそもSIerやっていてEmacs使っている人を探す方が難しいので、それを抜きにしてLispを利用している人を捜すなんて何をいわんや、というところです。</p>\n<p>ただ、言語の理解は、一種類のパラダイムだけではなく、複数のパラダイムによる重ね合わせをすると、非常に早く理解できると思います。</p>\n<p>ではここからはLispとJavaScriptの構文＆仕様の対比を始めます。・・・オブジェクト指向とかはよくわかんないので勘弁してください。</p>\n<h3>\n        <span id=\"3-3\" class=\"fragment\"></span>\n        <a href=\"#3-3\"><i class=\"fa fa-link\"></i></a>Lisp == JavaScript\n      </h3><p>Lispをやったことないとか括弧が多い言語とだけ聞いたことがある人向けに、簡単にLispの記法を書いておきます。</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>(関数 引数...)\n\n上記の関数の部分には関数のシンボル、引数は対象の関数に対する任意の引数です。引数間はスペースで区切ります。\n関数の戻り値は、最後に実行された式の結果です。そのため、「戻り値の無い関数」というのは厳密にはありません。\n\n基本的なデータ型は以下です。\n\n&quot;文字列&quot;\n1 2.5 -1\nt\nnil\n&#39;symbol\n\n重要なのは &#39;（シングルクォート）です。これはクォートする、と言われ、&#39;がついている式を書いてある通りに解釈することができます。このへんが多分Lispで一番わかりづらいです。私も未だにわかってるようなわかってないような。\n</pre></div></div><h4>\n        <span id=\"4-1\" class=\"fragment\"></span>\n        <a href=\"#4-1\"><i class=\"fa fa-link\"></i></a>トップレベル変数\n      </h4><div class=\"code-frame\" data-lang=\"emacslisp\"><div class=\"highlight\"><pre>(defvar hoge 1) ;; =&gt; hoge\n</pre></div></div><div class=\"code-frame\" data-lang=\"javascript\"><div class=\"highlight\"><pre><span class=\"kd\">var</span> <span class=\"nx\">hoge</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n</pre></div></div><p>そのまんまですね。<br>\nなお、それぞれ定義されていない変数にアクセスしようとするとundefied errorが発生します。</p>\n<h4>\n        <span id=\"4-2\" class=\"fragment\"></span>\n        <a href=\"#4-2\"><i class=\"fa fa-link\"></i></a>関数定義\n      </h4><div class=\"code-frame\" data-lang=\"emacslisp\"><div class=\"highlight\"><pre>(defun square (s) \n  (* s s))\n\n(square 2) ;; =&gt; 4\n</pre></div></div><div class=\"code-frame\" data-lang=\"javascript\"><div class=\"highlight\"><pre><span class=\"kd\">function</span> <span class=\"nx\">square</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"nx\">s</span> <span class=\"o\">*</span> <span class=\"nx\">s</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">square</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span> <span class=\"c1\">// =&gt; 4</span>\n</pre></div></div><p>これも大体そのまんまですね。javascriptのfunctionキーワードは長すぎると思います。</p>\n<h4>\n        <span id=\"4-3\" class=\"fragment\"></span>\n        <a href=\"#4-3\"><i class=\"fa fa-link\"></i></a>if/for/while\n      </h4><div class=\"code-frame\" data-lang=\"emacslisp\"><div class=\"highlight\"><pre>(if (&lt; 1 2)\n    &quot;foobar&quot;\n  &quot;hoge&quot;) ;; =&gt; &quot;foobar&quot;\n\n(while t\n  (print 1))\n;; 無限ループ\n\n;; forループは構文（フォーム）として用意されていないので、loopマクロで。\n(loop for x in &#39;(1 2 3 4 5)\n      when (cl-evenp x)\n      collect x) ;; =&gt; (2 4)\n</pre></div></div><div class=\"code-frame\" data-lang=\"javascript\"><div class=\"highlight\"><pre><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"s1\">&#39;foobar&#39;</span><span class=\"p\">;</span>\n<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"s1\">&#39;hoge&#39;</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;1&#39;</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">r</span> <span class=\"o\">=</span> <span class=\"p\">[];</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">var</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">s</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">];</span><span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span><span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]</span> <span class=\"o\">/</span> <span class=\"mi\">2</span> <span class=\"o\">===</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">r</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div></div><p>emacs lispにはfor文というのは存在しないので、ここではそのかわりにloopマクロを使っています。それ以外は大体わかりますね。</p>\n<p>ただ、こういった構文は、C系統のシンタックスとLisp系統とでは大きく違う部分なので、さらっといきます。</p>\n<h4>\n        <span id=\"4-4\" class=\"fragment\"></span>\n        <a href=\"#4-4\"><i class=\"fa fa-link\"></i></a>無名関数\n      </h4><div class=\"code-frame\" data-lang=\"emacslisp\"><div class=\"highlight\"><pre>(lambda (x) (= (/ x 2) 0))\n</pre></div></div><div class=\"code-frame\" data-lang=\"javascript\"><div class=\"highlight\"><pre><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nx\">x</span> <span class=\"o\">/</span> <span class=\"mi\">2</span> <span class=\"o\">===</span> <span class=\"mi\">0</span><span class=\"p\">;}</span>\n</pre></div></div><p>キーワードと括弧の使い方が違うくらいで大体一緒ですね。Lispでは上記の関数を実行するとt/nilが、JavaScriptではtrue/falseが返ってきます。</p>\n<h4>\n        <span id=\"4-5\" class=\"fragment\"></span>\n        <a href=\"#4-5\"><i class=\"fa fa-link\"></i></a>true/false/null\n      </h4><div class=\"code-frame\" data-lang=\"emacslisp\"><div class=\"highlight\"><pre>t   ;; =&gt; t\nnil ;; =&gt; nil\n</pre></div></div><div class=\"code-frame\" data-lang=\"javascript\"><div class=\"highlight\"><pre><span class=\"kc\">true</span>\n<span class=\"kc\">false</span>\n<span class=\"kc\">null</span>\n<span class=\"kc\">undefined</span>\n</pre></div></div><p>Lispでは、nullとかfalseとかはほぼすべてnilで表されます。undefinedというものは基本的にない（はず）です。if文などでは、 <strong>nilかそれ以外</strong>で分岐するため、このへんはJavaScriptのtrue/falseの判定とは違います。false/nullが大体同じにみられるのはにてますね。</p>\n<h4>\n        <span id=\"4-6\" class=\"fragment\"></span>\n        <a href=\"#4-6\"><i class=\"fa fa-link\"></i></a>変数のスコープとローカル変数\n      </h4><div class=\"code-frame\" data-lang=\"elisp\"><div class=\"highlight\"><pre><span class=\"c1\">;; 同じ名前の変数はより内側のスコープで閉じられる</span>\n<span class=\"p\">(</span><span class=\"nb\">defvar</span> <span class=\"nv\">x</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">hoge</span> <span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">)</span> \n   <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"nv\">x</span> <span class=\"nv\">x</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"nv\">hoge</span> <span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"c1\">;; =&gt; 6</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">hoge</span> <span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">)</span> \n  <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">y</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n    <span class=\"p\">(</span><span class=\"nb\">/</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"nv\">x</span> <span class=\"nv\">x</span><span class=\"p\">)</span> <span class=\"nv\">y</span><span class=\"p\">)))</span>\n<span class=\"p\">(</span><span class=\"nv\">hoge</span> <span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"c1\">;; =&gt; 25</span>\n<span class=\"nv\">y</span> <span class=\"c1\">;; =&gt; void-variableなエラー</span>\n</pre></div></div><p>注)なんかシンタックスがうまくついてくれないんですが、とりあえず。。。</p>\n<div class=\"code-frame\" data-lang=\"javascript\"><div class=\"highlight\"><pre><span class=\"kd\">var</span> <span class=\"nx\">x</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"kd\">function</span> <span class=\"nx\">hoge</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"nx\">x</span> <span class=\"o\">+</span> <span class=\"nx\">x</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">hoge</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">hoge</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kd\">var</span> <span class=\"nx\">y</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n  <span class=\"k\">return</span> <span class=\"nx\">x</span> <span class=\"o\">*</span> <span class=\"nx\">x</span> <span class=\"o\">/</span> <span class=\"nx\">y</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">hoge</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">);</span>\n<span class=\"nx\">y</span> <span class=\"c1\">// undefinedでエラー</span>\n</pre></div></div><p>このへんからなんか似ている空気が漂ってきます。Lispのローカル変数は、原則としてlet（とその仲間）でのみ定義ができます。</p>\n<p>さて、ここがLispとJavaScriptが似ている点の一つです。JavaScriptを説明するとき、「なんでブロックスコープがないの？」と聞かれて、そう決まってるからそうだ、というしか無かった記憶があります。<br>\nしかし、JavaScript ≒ Lispと考えて、上を対比させてみると、一つ気づきます。</p>\n<p>JavaScriptの仕様として、関数内のvarは <strong>すべて関数の先頭で宣言されたこと</strong>になります。これ、ちょうど上の例でいう二つ目のhoge関数の中身そのものになります。正確にいえばlet*だとは思いますが、それは細かい点なのでおいておきます。</p>\n<p>つまり、 <strong>varが先頭に移動されるのは、functionの直後にletが一つしかおけないから</strong> と考えると、この仕様は自明になります。</p>\n<p>なんで内側でlet作れなかったの、という点はありますが、まぁそれはそれで。<br>\nそして、JavaScriptが関数スコープしかない、というのも、letが作れるのは関数の中だけ、という制限（Lispにはそんな制限ありません）があるのだと想像すれば容易いです。</p>\n<h4>\n        <span id=\"4-7\" class=\"fragment\"></span>\n        <a href=\"#4-7\"><i class=\"fa fa-link\"></i></a>関数の実行\n      </h4><div class=\"code-frame\" data-lang=\"emacslisp\"><div class=\"highlight\"><pre>(let ((f (lambda (x) (* x x))))\n  (apply f &#39;(2))\n  (funcall f 2))\n;; 結果はどちらも同じ\n</pre></div></div><div class=\"code-frame\" data-lang=\"javascript\"><div class=\"highlight\"><pre><span class=\"kd\">function</span> <span class=\"nx\">f</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"nx\">x</span> <span class=\"o\">*</span> <span class=\"nx\">x</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">f</span><span class=\"p\">.</span><span class=\"nx\">apply</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]);</span>\n<span class=\"nx\">f</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n</pre></div></div><p>ここがおそらく一番LispとJavaScriptで似ている点だと思います。なんでcall/applyという二種類の実行形式があるのか、という答えはここにあります。要はLispにあるからだと。</p>\n<p>Lispでは配列とリストの区別があるため、Lispのapplyに渡している &#39;(2)というのはあくまで <strong>リスト</strong>です。JavaScriptにはそんな区別はありませんが、その辺は些末な感じです。</p>\n<p>強いていえば、JavaScriptには関数の実行コンテキストを渡すことができますが、Lispの場合はその関数が定義された時点のコンテキストが保存されているため、そういったものがない、という点で、そういう意味ではJavaScriptのほうが柔軟（そしてわかりづらい）ですね。</p>\n<h4>\n        <span id=\"4-8\" class=\"fragment\"></span>\n        <a href=\"#4-8\"><i class=\"fa fa-link\"></i></a>オブジェクト\n      </h4><div class=\"code-frame\" data-lang=\"emacslisp\"><div class=\"highlight\"><pre>(let ((s &#39;(\n           (foo . &quot;bar&quot;)\n           (bar . &quot;foo&quot;)\n           (numbers . 1))))\n  (cdr (assoc &#39;foo s)))\n;; =&gt; &quot;bar&quot;\n</pre></div></div><div class=\"code-frame\" data-lang=\"javascript\"><div class=\"highlight\"><pre><span class=\"kd\">var</span> <span class=\"nx\">s</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"nx\">foo</span> <span class=\"o\">:</span> <span class=\"s2\">&quot;bar&quot;</span><span class=\"p\">,</span>\n  <span class=\"nx\">bar</span> <span class=\"o\">:</span> <span class=\"s2\">&quot;foo&quot;</span><span class=\"p\">,</span>\n  <span class=\"nx\">numbers</span> <span class=\"o\">:</span> <span class=\"mi\">1</span>\n<span class=\"p\">};</span>\n<span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">foo</span><span class=\"p\">;</span>\n</pre></div></div><p>Lispの方がかなりわかりづらいですが、このへんはちょっと割愛します。ですが、JavaScriptの連想配列とオブジェクトが同一である、というのは、Lispでいうリストと連想リストの関係みたいなもんじゃないかなー、と思います。オブジェクトのネストや関数の設定なども、連想リストに対して値を設定したりなんだりというのとほぼ変わりません。</p>\n<h4>\n        <span id=\"4-9\" class=\"fragment\"></span>\n        <a href=\"#4-9\"><i class=\"fa fa-link\"></i></a>クロージャ\n      </h4><div class=\"code-frame\" data-lang=\"emacslisp\"><div class=\"highlight\"><pre>(defun hoge (x)\n  (lambda (y)\n    (let ((w (* x y)))\n      (setq x (1+ x))\n      w)))\n\n(let ((f (hoge 2)))\n  (funcall f 4) ;; =&gt; 8\n  (funcall f 4) ;; =&gt; 12\n  )\n</pre></div></div><p>注）lexical-letが有効になっていないと正しく動きません。</p>\n<div class=\"code-frame\" data-lang=\"JavaScript\"><div class=\"highlight\"><pre><span class=\"kd\">function</span> <span class=\"nx\">hoge</span><span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"nx\">funcation</span><span class=\"p\">(</span><span class=\"nx\">y</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">w</span> <span class=\"o\">=</span> <span class=\"nx\">x</span> <span class=\"o\">*</span> <span class=\"nx\">y</span><span class=\"p\">;</span>\n    <span class=\"nx\">x</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"nx\">w</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">f</span> <span class=\"o\">=</span> <span class=\"nx\">hoge</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n<span class=\"nx\">f</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"p\">;;</span> <span class=\"o\">=&gt;</span> <span class=\"mi\">8</span>\n<span class=\"nx\">f</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"p\">;;</span> <span class=\"o\">=&gt;</span> <span class=\"mi\">12</span>\n</pre></div></div><p>クロージャは、おそらくJavaScriptを誰かに伝えるときに一番？？？って顔をされるものだと思います（経験談）。これについては、LispでもJavaScriptでもあまり変わりません。</p>\n<h3>\n        <span id=\"3-4\" class=\"fragment\"></span>\n        <a href=\"#3-4\"><i class=\"fa fa-link\"></i></a>結論：LispとJavaScriptは概念だけ似ている\n      </h3><p>当然の結論ではありますが、文法とかはLispとJavaScriptは似ても似つかないものです。ただ、JavaScriptの根底の概念、特に関数やスコープといった部分では、JavaScriptは確かにLispに似ている、というかだいたい一緒、といえるんじゃ無いでしょうか。</p>\n<p>無理矢理感半端ないのはわかっていますが、ときにはこんなのもありということで。</p>\n",
        "stock_users": [
            "hterada",
            "kuriya0909",
            "kasumani",
            "Reds",
            "tmysz",
            "ClubRefuse",
            "kk2170",
            "umanoda",
            "riocampos",
            "makyos",
            "nyarla",
            "SuperAlloyZZ",
            "ozw_sei",
            "koh-taka@github",
            "hakuro"
        ]
    },
    {
        "id": 92571,
        "uuid": "da8a405ab3f663182ba5",
        "user": {
            "id": 46637,
            "url_name": "aki426",
            "profile_image_url": "https://pbs.twimg.com/profile_images/427469601811619840/kQSq4Cue_normal.jpeg"
        },
        "title": "Gaucheのオンラインヘルプをオフライン化した",
        "created_at": "2014-07-14 15:18:16 +0900",
        "updated_at": "2014-07-14 15:18:16 +0900",
        "created_at_in_words": "2ヶ月",
        "updated_at_in_words": "2ヶ月",
        "tags": [
            {
                "name": "Gauche",
                "url_name": "gauche",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "Scheme",
                "url_name": "scheme",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/b1fb74e3610feb2020a403cd0eab2cebdd217f10/medium.jpg?1399021725",
                "versions": []
            }
        ],
        "stock_count": 3,
        "comment_count": 3,
        "url": "http://qiita.com/aki426/items/da8a405ab3f663182ba5",
        "created_at_as_seconds": 1405318696,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "まあタイトルの通りなんですけど、ぶっこ抜いてCHMファイルにまとめました。\n\n[DLはこちらから。](https://github.com/aki426/GaucheOfflineHelp/blob/master/README.md)\n\nライセンス的にも問題ありませんし、手元に置いておけるので不慮のネットワークトラブルなどに見舞われた時にも安心。もちろん全文検索できるので便利。\nただ、CHMファイルってWindows向けの物なので、他のOSユーザの方（そしてGauche使ってる方はLunuxが多そう）に恩恵があるかどうかわかりませんが、公開しておきます。\n\nおわり。\n",
        "body": "<p>まあタイトルの通りなんですけど、ぶっこ抜いてCHMファイルにまとめました。</p>\n<p><a href=\"https://github.com/aki426/GaucheOfflineHelp/blob/master/README.md\" title=\"\" target=\"_blank\">DLはこちらから。</a></p>\n<p>ライセンス的にも問題ありませんし、手元に置いておけるので不慮のネットワークトラブルなどに見舞われた時にも安心。もちろん全文検索できるので便利。<br>\nただ、CHMファイルってWindows向けの物なので、他のOSユーザの方（そしてGauche使ってる方はLunuxが多そう）に恩恵があるかどうかわかりませんが、公開しておきます。</p>\n<p>おわり。</p>\n",
        "stock_users": [
            "kasumani",
            "Reds",
            "Noboruhi"
        ]
    },
    {
        "id": 90284,
        "uuid": "c7ab1b401722a1fc01ef",
        "user": {
            "id": 46637,
            "url_name": "aki426",
            "profile_image_url": "https://pbs.twimg.com/profile_images/427469601811619840/kQSq4Cue_normal.jpeg"
        },
        "title": "Windows上でSublime TextからCLISPのREPLを呼ぶ方法",
        "created_at": "2014-07-09 16:57:09 +0900",
        "updated_at": "2014-07-09 21:10:56 +0900",
        "created_at_in_words": "3ヶ月",
        "updated_at_in_words": "3ヶ月",
        "tags": [
            {
                "name": "SublimeText",
                "url_name": "sublimetext",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/f3182741ed4ee870c40648c5226d5de094785886/medium.jpg?1398661821",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "Windows",
                "url_name": "windows",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/a9ad076b2063a3ffdae6d3d1ff23eb702662bd6e/medium.jpg?1395329690",
                "versions": []
            }
        ],
        "stock_count": 4,
        "comment_count": 0,
        "url": "http://qiita.com/aki426/items/c7ab1b401722a1fc01ef",
        "created_at_as_seconds": 1404892629,
        "tweet": true,
        "gist_url": "https://gist.github.com/71045e7e7a6f1e092e94",
        "private": false,
        "raw_body": "時は西暦2014年、人類は広大な宇宙空間の中に、新たなLisp開発環境を求めて旅を続けていた－－。\n（訳：EclipseでGaucheの環境構築が面倒というかうまくいかなかったので、新しい開発環境を探していました）\n\nそしたら、Sublime REPLの選択項目にCLISPがあったんですよ。おっ、これは！　と思って実行してみたのにろくろく動かないんですよ。仕方ないのでちょっとハックして動くようにしました。以下、初心者向けに「WindowsでCLISPのREPLをSublime Textから使う方法」を解説。\n\n#下準備\n\n##CLISPのインストール\n\nなにはともあれ、CLISPが無いと話が始まりません。\n\nCLISPはWindows版が無く、Cygwin版しか無いので、まずはCygwinを入れるのと一緒にCLISPを入れます。この辺は[前に書いた記事の「やること」](http://qiita.com/aki426/items/bfd17b901f5fd2df656c)あたりを参照してください。\n\nんで、Cygwinのターミナルから「CLISP」と打って実行できるようになったら、今度はコマンドプロンプトから実行できるようにします。\n\n##コマンドプロンプトからCLISPを使えるようにする\n\nSublime Textからはコマンドプロンプト経由でCLISPを呼ぶので、Cygwinから実行できるだけではやりたいことができません（Cygwinのターミナルから実行させる方法もあるのかもしれませんが、労多くして益少ないと思います）。というわけで、コマンドプロンプトからCLISPを実行できるように設定します。\n\nこの設定はCLISPに限らず、コマンドプロンプトからすべてのCygwinコマンドが使えるようにパスを通す方法なのですが、まあとりあえずやっておいて損は無いです。やりましょう。\n\n[ゼロからはじめる「Cygwin」 - コマンドプロンプトでUNIXコマンドを使う編](http://news.mynavi.jp/articles/2013/11/25/zerokaracygwin/)に画像付きで詳しく書いてありますが、要点だけまとめると、\n\n0. C:\\cygwin\\bin\\cygwin1.dll を C:\\Windows\\System32 にコピーする\n0. 環境変数「PATH」に ;C:\\cygwin\\bin;C:\\cygwin\\usr\\bin;C:\\cygwin\\usr\\local\\bin を追加する\n1. 環境変数「LD_LIBRARY_PATH」に C:\\cygwin\\lib;C:\\cygwin\\lib\\w32api;C:\\cygwin\\usr\\local\\lib を追加、作成する。\n\nこの3つです。システム環境変数なら再起動が必要ですが、ユーザ環境変数だったら再起動せずにすぐ反映されます。\n\n試しにWinキー押して、「cmd」と打って、Enter押して、出てきたコマンドプロンプトに「CLISP」と打って、Enter押してみてください。CLISPが走ったらOK、ペリー……成功です。\n\n#Sublime Text 2側でやること\n\n##Sublime Text 2のインストール\n\nまずSublime Text 2（以下ST2）をインストールしましょう。[公式サイト](http://www.sublimetext.com/2)からWindows向けのインストーラをダウンロード＆実行、インストールします。この辺は説明不要のはず。\n\n##Package Cotrolのインストール\n\n素の状態のST2にいろいろプラグインを入れたいわけですが、プラグイン管理の便利なプラグインがあるのでそれをまず最初に入れます。\n\nST2を立ち上げて、Ctrl+@（下記の公式サイトでは「Ctrl+`」と書かれていますが要はPの右にあるキーをCtrlキーと同時に押せってことです）を押すと、コンソールと何やら一行入力欄が出てくるので、[公式サイト](https://sublime.wbond.net/installation#st2)に書かれている「import～」から始まるやけに長い謎の呪文をコピペして、Enterを押します。\n\n特に何事も起こらずPackage Cotrolのインストールが完了するはずです。\n\n##Sublime REPLをインストールする\n\nPackage Cotrolを使って、Sublime REPLをインストールします。Ctrl+Shift+Pキーを押すと、入力欄が出てくるので、そこに「install」と打つと、補完されて`Package Control: Install Package`と出てきます。ちょっと経つとまた入力できるようになるので、今度は「Sublime REPL」と打つと、また補完されるので、「Sublime REPL」を選択し、Enterを押します。インストール手順はこれだけです。\n\nこいつはCLISPに限らず、REPL（GaucheのREPLとか）をST2内で動かすための物で、実はCLISPも標準設定が入っています。ST2のメニューからToolsを選んで、一番下の「Sublime REPL」を選択、出てきたドロップダウンの一番上から4番目あたりに「Clisp」とあります。選択してみましょう。すると、下記のような結果が返ってきます。\n\n```\nGNU CLISP: invalid argument: '-disable-readline'\nGNU CLISP: use '-h' for help\n\n***Repl Closed***\n```\n\nどうやらSublime REPLの標準だと、CLISPに変な引数を与えてしまっているためにまともに動かないようです。なので、ここんとこを修正してやります。\n\n##設定ファイルの修正\n\nSublime REPLのCLISP用の設定ファイルは、`C:\\Users\\(ユーザ名)\\AppData\\Roaming\\Sublime Text 2\\Packages\\SublimeREPL\\config\\Clisp`の`Main.sublime-menu`に書かれています。関係するところだけ抜き出すと、\n\n```\n...\n\"encoding\": \"utf8\",\n\"cmd\": [\"clisp\", \"-disable-readline\"],\n\"cwd\": \"$file_path\",\n...\n```\n\n17行目あたりにCLISPの実行時引数にさっきのエラー表示にもあった`-disable-readline`が渡されているのがわかります。原因はこれなので、消してやります。\n\n```\n...\n\"encoding\": \"utf8\",\n\"cmd\": [\"clisp\"],\n\"cwd\": \"$file_path\",\n...\n```\n\n修正したら、保存して、念のためST2も再起動しておきましょう。\n\n#結果\n\n何か適当なLispのコードを書いて、.lispファイルとして保存、さらにTools->Sublime REPL->ClispでCLISPのREPLを実行します。Lispコードのウィンドウ上で「Ctrl+,」を押した直後にFを押してみてください。すると、REPL上で評価が走ります。\n\n![st2_clisp.jpg](https://qiita-image-store.s3.amazonaws.com/0/46637/13efa09a-0a5d-3c37-d7d4-f782b324e116.jpeg)\nこんなかんじ。\n\nちなみにSublime REPLのコマンドとキーバインディングは下記のようになっています（すごくべんり）。\n\n* Ctrl+,押した直後にF：ファイル丸ごと評価\n* Ctrl+,押した直後にS：選択範囲を評価\n* Ctrl+,押した直後にB：コードブロック（？）を評価\n* Ctrl+,押した直後にL：行（？）を評価\n\nTools->Sublime REPLと辿って行った先の上の方にも表示されていますが、これが最初わかんなくて混乱したので書いておきます。\n\n#追記\n\n##1\n\n意気揚々と書いてみたものの、なんかうまく動かないですねこれ。新規ファイルを作ってそこで簡単なコードを書いて読み込ませる、というのだと動くんですが、すでにあるソースファイルを開いて読み込ませる、という処理ができない。何ででしょうかねぇ？　文字コード？　特にイジってないGaucheのREPLでも動かなかったりするし。\n\nこの辺、ST2に詳しい人に調査をお願いしたいところです。もし使ってて何かわかったら教えてくださいお願いします。\n\nまでも、上で書いたコードを下のREPL窓にコピペして動かす、というのは問題なく使える範疇ってことで、この記事はこのまま置いときます。\n\n♯♯2\n\n[ここの「３．SublimeText2とのコンビネーション」](http://kamaita.wordpress.com/2013/06/16/python%E3%81%A7%E7%B5%8C%E6%B8%88%E5%AD%A6%EF%BC%88spyder%E3%81%A8ipython%E7%AB%8B%E3%81%A1%E4%B8%8A%E3%81%92-%E7%B7%A8%EF%BC%89/)を参考に、Sublime REPLを再インストールした。が、やっぱり動かない。また、再インストールの際にはやはり\"-disable-readline\"を消す必要があった。\n\n結果的に、再起動したら動いた。また動かなくなる可能性があるが、再現性がよくわからない。Windowsだから再起動したら直る、というのはWindows8.1でも同じなのだろうか……はてさて。\n\n#蛇足\n\n他にpareditとかlispindentとか入れておくと幸せになれると思います。\n\n#参考文献\n\n参考にした（してる）とこなど一覧。\nhttp://nomnel.net/blog/st2-gauche/\nhttp://nomnel.net/blog/st2-scheme-repl/\nhttp://nomnel.net/blog/st2-scheme-syntax/\nhttp://blog.segu.jp/2012/05/windows-sublime-text-2.html\nhttp://www.sigesaba.com/2012/10/sublime-text2-package-control.php\nhttp://blog.8arrow.org/entry/2013/12/19/183508\n\n",
        "body": "<p>時は西暦2014年、人類は広大な宇宙空間の中に、新たなLisp開発環境を求めて旅を続けていた－－。<br>\n（訳：EclipseでGaucheの環境構築が面倒というかうまくいかなかったので、新しい開発環境を探していました）</p>\n<p>そしたら、Sublime REPLの選択項目にCLISPがあったんですよ。おっ、これは！　と思って実行してみたのにろくろく動かないんですよ。仕方ないのでちょっとハックして動くようにしました。以下、初心者向けに「WindowsでCLISPのREPLをSublime Textから使う方法」を解説。</p>\n<h1>\n        <span id=\"1-1\" class=\"fragment\"></span>\n        <a href=\"#1-1\"><i class=\"fa fa-link\"></i></a>下準備\n      </h1><h2>\n        <span id=\"2-1\" class=\"fragment\"></span>\n        <a href=\"#2-1\"><i class=\"fa fa-link\"></i></a>CLISPのインストール\n      </h2><p>なにはともあれ、CLISPが無いと話が始まりません。</p>\n<p>CLISPはWindows版が無く、Cygwin版しか無いので、まずはCygwinを入れるのと一緒にCLISPを入れます。この辺は<a href=\"http://qiita.com/aki426/items/bfd17b901f5fd2df656c\" title=\"\">前に書いた記事の「やること」</a>あたりを参照してください。</p>\n<p>んで、Cygwinのターミナルから「CLISP」と打って実行できるようになったら、今度はコマンドプロンプトから実行できるようにします。</p>\n<h2>\n        <span id=\"2-2\" class=\"fragment\"></span>\n        <a href=\"#2-2\"><i class=\"fa fa-link\"></i></a>コマンドプロンプトからCLISPを使えるようにする\n      </h2><p>Sublime Textからはコマンドプロンプト経由でCLISPを呼ぶので、Cygwinから実行できるだけではやりたいことができません（Cygwinのターミナルから実行させる方法もあるのかもしれませんが、労多くして益少ないと思います）。というわけで、コマンドプロンプトからCLISPを実行できるように設定します。</p>\n<p>この設定はCLISPに限らず、コマンドプロンプトからすべてのCygwinコマンドが使えるようにパスを通す方法なのですが、まあとりあえずやっておいて損は無いです。やりましょう。</p>\n<p><a href=\"http://news.mynavi.jp/articles/2013/11/25/zerokaracygwin/\" title=\"\" target=\"_blank\">ゼロからはじめる「Cygwin」 - コマンドプロンプトでUNIXコマンドを使う編</a>に画像付きで詳しく書いてありますが、要点だけまとめると、</p>\n\n<ol>\n<li>C:\\cygwin\\bin\\cygwin1.dll を C:\\Windows\\System32 にコピーする</li>\n<li>環境変数「PATH」に ;C:\\cygwin\\bin;C:\\cygwin\\usr\\bin;C:\\cygwin\\usr\\local\\bin を追加する</li>\n<li>環境変数「LD_LIBRARY_PATH」に C:\\cygwin\\lib;C:\\cygwin\\lib\\w32api;C:\\cygwin\\usr\\local\\lib を追加、作成する。</li>\n</ol>\n<p>この3つです。システム環境変数なら再起動が必要ですが、ユーザ環境変数だったら再起動せずにすぐ反映されます。</p>\n<p>試しにWinキー押して、「cmd」と打って、Enter押して、出てきたコマンドプロンプトに「CLISP」と打って、Enter押してみてください。CLISPが走ったらOK、ペリー……成功です。</p>\n<h1>\n        <span id=\"1-2\" class=\"fragment\"></span>\n        <a href=\"#1-2\"><i class=\"fa fa-link\"></i></a>Sublime Text 2側でやること\n      </h1><h2>\n        <span id=\"2-3\" class=\"fragment\"></span>\n        <a href=\"#2-3\"><i class=\"fa fa-link\"></i></a>Sublime Text 2のインストール\n      </h2><p>まずSublime Text 2（以下ST2）をインストールしましょう。<a href=\"http://www.sublimetext.com/2\" title=\"\" target=\"_blank\">公式サイト</a>からWindows向けのインストーラをダウンロード＆実行、インストールします。この辺は説明不要のはず。</p>\n<h2>\n        <span id=\"2-4\" class=\"fragment\"></span>\n        <a href=\"#2-4\"><i class=\"fa fa-link\"></i></a>Package Cotrolのインストール\n      </h2><p>素の状態のST2にいろいろプラグインを入れたいわけですが、プラグイン管理の便利なプラグインがあるのでそれをまず最初に入れます。</p>\n<p>ST2を立ち上げて、Ctrl+@（下記の公式サイトでは「Ctrl+`」と書かれていますが要はPの右にあるキーをCtrlキーと同時に押せってことです）を押すと、コンソールと何やら一行入力欄が出てくるので、<a href=\"https://sublime.wbond.net/installation#st2\" title=\"\" target=\"_blank\">公式サイト</a>に書かれている「import～」から始まるやけに長い謎の呪文をコピペして、Enterを押します。</p>\n<p>特に何事も起こらずPackage Cotrolのインストールが完了するはずです。</p>\n<h2>\n        <span id=\"2-5\" class=\"fragment\"></span>\n        <a href=\"#2-5\"><i class=\"fa fa-link\"></i></a>Sublime REPLをインストールする\n      </h2><p>Package Cotrolを使って、Sublime REPLをインストールします。Ctrl+Shift+Pキーを押すと、入力欄が出てくるので、そこに「install」と打つと、補完されて<code>Package Control: Install Package</code>と出てきます。ちょっと経つとまた入力できるようになるので、今度は「Sublime REPL」と打つと、また補完されるので、「Sublime REPL」を選択し、Enterを押します。インストール手順はこれだけです。</p>\n<p>こいつはCLISPに限らず、REPL（GaucheのREPLとか）をST2内で動かすための物で、実はCLISPも標準設定が入っています。ST2のメニューからToolsを選んで、一番下の「Sublime REPL」を選択、出てきたドロップダウンの一番上から4番目あたりに「Clisp」とあります。選択してみましょう。すると、下記のような結果が返ってきます。</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>GNU CLISP: invalid argument: &#39;-disable-readline&#39;\nGNU CLISP: use &#39;-h&#39; for help\n\n***Repl Closed***\n</pre></div></div><p>どうやらSublime REPLの標準だと、CLISPに変な引数を与えてしまっているためにまともに動かないようです。なので、ここんとこを修正してやります。</p>\n<h2>\n        <span id=\"2-6\" class=\"fragment\"></span>\n        <a href=\"#2-6\"><i class=\"fa fa-link\"></i></a>設定ファイルの修正\n      </h2><p>Sublime REPLのCLISP用の設定ファイルは、<code>C:\\Users\\(ユーザ名)\\AppData\\Roaming\\Sublime Text 2\\Packages\\SublimeREPL\\config\\Clisp</code>の<code>Main.sublime-menu</code>に書かれています。関係するところだけ抜き出すと、</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>...\n&quot;encoding&quot;: &quot;utf8&quot;,\n&quot;cmd&quot;: [&quot;clisp&quot;, &quot;-disable-readline&quot;],\n&quot;cwd&quot;: &quot;$file_path&quot;,\n...\n</pre></div></div><p>17行目あたりにCLISPの実行時引数にさっきのエラー表示にもあった<code>-disable-readline</code>が渡されているのがわかります。原因はこれなので、消してやります。</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>...\n&quot;encoding&quot;: &quot;utf8&quot;,\n&quot;cmd&quot;: [&quot;clisp&quot;],\n&quot;cwd&quot;: &quot;$file_path&quot;,\n...\n</pre></div></div><p>修正したら、保存して、念のためST2も再起動しておきましょう。</p>\n<h1>\n        <span id=\"1-3\" class=\"fragment\"></span>\n        <a href=\"#1-3\"><i class=\"fa fa-link\"></i></a>結果\n      </h1><p>何か適当なLispのコードを書いて、.lispファイルとして保存、さらにTools->Sublime REPL->ClispでCLISPのREPLを実行します。Lispコードのウィンドウ上で「Ctrl+,」を押した直後にFを押してみてください。すると、REPL上で評価が走ります。</p>\n<p><img src=\"https://qiita-image-store.s3.amazonaws.com/0/46637/13efa09a-0a5d-3c37-d7d4-f782b324e116.jpeg\" alt=\"st2_clisp.jpg\"><br>\nこんなかんじ。</p>\n<p>ちなみにSublime REPLのコマンドとキーバインディングは下記のようになっています（すごくべんり）。</p>\n\n<ul>\n<li>Ctrl+,押した直後にF：ファイル丸ごと評価</li>\n<li>Ctrl+,押した直後にS：選択範囲を評価</li>\n<li>Ctrl+,押した直後にB：コードブロック（？）を評価</li>\n<li>Ctrl+,押した直後にL：行（？）を評価</li>\n</ul>\n<p>Tools->Sublime REPLと辿って行った先の上の方にも表示されていますが、これが最初わかんなくて混乱したので書いておきます。</p>\n<h1>\n        <span id=\"1-4\" class=\"fragment\"></span>\n        <a href=\"#1-4\"><i class=\"fa fa-link\"></i></a>追記\n      </h1><h2>\n        <span id=\"2-7\" class=\"fragment\"></span>\n        <a href=\"#2-7\"><i class=\"fa fa-link\"></i></a>1\n      </h2><p>意気揚々と書いてみたものの、なんかうまく動かないですねこれ。新規ファイルを作ってそこで簡単なコードを書いて読み込ませる、というのだと動くんですが、すでにあるソースファイルを開いて読み込ませる、という処理ができない。何ででしょうかねぇ？　文字コード？　特にイジってないGaucheのREPLでも動かなかったりするし。</p>\n<p>この辺、ST2に詳しい人に調査をお願いしたいところです。もし使ってて何かわかったら教えてくださいお願いします。</p>\n<p>までも、上で書いたコードを下のREPL窓にコピペして動かす、というのは問題なく使える範疇ってことで、この記事はこのまま置いときます。</p>\n<p>♯♯2</p>\n<p><a href=\"http://kamaita.wordpress.com/2013/06/16/python%E3%81%A7%E7%B5%8C%E6%B8%88%E5%AD%A6%EF%BC%88spyder%E3%81%A8ipython%E7%AB%8B%E3%81%A1%E4%B8%8A%E3%81%92-%E7%B7%A8%EF%BC%89/\" title=\"\" target=\"_blank\">ここの「３．SublimeText2とのコンビネーション」</a>を参考に、Sublime REPLを再インストールした。が、やっぱり動かない。また、再インストールの際にはやはり&quot;-disable-readline&quot;を消す必要があった。</p>\n<p>結果的に、再起動したら動いた。また動かなくなる可能性があるが、再現性がよくわからない。Windowsだから再起動したら直る、というのはWindows8.1でも同じなのだろうか……はてさて。</p>\n<h1>\n        <span id=\"1-5\" class=\"fragment\"></span>\n        <a href=\"#1-5\"><i class=\"fa fa-link\"></i></a>蛇足\n      </h1><p>他にpareditとかlispindentとか入れておくと幸せになれると思います。</p>\n<h1>\n        <span id=\"1-6\" class=\"fragment\"></span>\n        <a href=\"#1-6\"><i class=\"fa fa-link\"></i></a>参考文献\n      </h1><p>参考にした（してる）とこなど一覧。<br>\n<a href=\"http://nomnel.net/blog/st2-gauche/\" title=\"http://nomnel.net/blog/st2-gauche/\" target=\"_blank\">http://nomnel.net/blog/st2-gauche/</a><br>\n<a href=\"http://nomnel.net/blog/st2-scheme-repl/\" title=\"http://nomnel.net/blog/st2-scheme-repl/\" target=\"_blank\">http://nomnel.net/blog/st2-scheme-repl/</a><br>\n<a href=\"http://nomnel.net/blog/st2-scheme-syntax/\" title=\"http://nomnel.net/blog/st2-scheme-syntax/\" target=\"_blank\">http://nomnel.net/blog/st2-scheme-syntax/</a><br>\n<a href=\"http://blog.segu.jp/2012/05/windows-sublime-text-2.html\" title=\"http://blog.segu.jp/2012/05/windows-sublime-text-2.html\" target=\"_blank\">http://blog.segu.jp/2012/05/windows-sublime-text-2.html</a><br>\n<a href=\"http://www.sigesaba.com/2012/10/sublime-text2-package-control.php\" title=\"http://www.sigesaba.com/2012/10/sublime-text2-package-control.php\" target=\"_blank\">http://www.sigesaba.com/2012/10/sublime-text2-package-control.php</a><br>\n<a href=\"http://blog.8arrow.org/entry/2013/12/19/183508\" title=\"http://blog.8arrow.org/entry/2013/12/19/183508\" target=\"_blank\">http://blog.8arrow.org/entry/2013/12/19/183508</a></p>\n",
        "stock_users": [
            "kasumani",
            "akmiyoshi",
            "Noboruhi",
            "TalesofFox"
        ]
    },
    {
        "id": 88574,
        "uuid": "b56e43f6119fca86869c",
        "user": {
            "id": 46637,
            "url_name": "aki426",
            "profile_image_url": "https://pbs.twimg.com/profile_images/427469601811619840/kQSq4Cue_normal.jpeg"
        },
        "title": "EclipseでLispを書くときEditBoxを使うと見やすい",
        "created_at": "2014-07-05 14:26:20 +0900",
        "updated_at": "2014-07-05 14:36:10 +0900",
        "created_at_in_words": "3ヶ月",
        "updated_at_in_words": "3ヶ月",
        "tags": [
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "Eclipse",
                "url_name": "eclipse",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/ccf32cbcb30733164a0ea2331e24dacf1c2a3cf1/medium.jpg?1398264070",
                "versions": []
            },
            {
                "name": "Eclipseプラグイン",
                "url_name": "eclipse%e3%83%97%e3%83%a9%e3%82%b0%e3%82%a4%e3%83%b3",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            }
        ],
        "stock_count": 7,
        "comment_count": 0,
        "url": "http://qiita.com/aki426/items/b56e43f6119fca86869c",
        "created_at_as_seconds": 1404537980,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "また日本語で情報の無いプラグインを見つけて使ってみたらすごい使いやすかったのでQiitaに書いておく。\n\n![EditBox.jpg](https://qiita-image-store.s3.amazonaws.com/0/46637/804627de-d7bf-f8a0-011f-0b74f0484e65.jpeg)\n\nすごい！　()のネスティングが色分けされててすごい見やすい！　すごいofすごい！\n\nというわけでEditBoxを使おう。\n\n#インストール\n\n[EditBox公式](http://editbox.sourceforge.net/)\n\n本来はJavaとPython、あとNodeclipse用のプラグインらしいが、Common Lispでも十分動く。[以前書いたエントリ](http://qiita.com/aki426/items/bfd17b901f5fd2df656c)のDandelionと組み合わせると良い。\n\n#設定\n\n設定はこんな感じ。\n\n![editbox_setting.jpg](https://qiita-image-store.s3.amazonaws.com/0/46637/937fd40c-7a6a-258f-0e15-3a80ef149b75.jpeg)\n\n[設定ファイル](https://github.com/aki426/Eclipse/blob/master/lisp.eb)\n\n「構文」という項目がどれを選んでも変化が無いあたり、よくわからないが無難に「Text」にしてある。色は下記のような感じ。上記設定ファイル「lisp.eb」のインポートで設定できるが。\n\n開始色　RGB:184,184,184\n末端色　RGB:255,255,184\n",
        "body": "<p>また日本語で情報の無いプラグインを見つけて使ってみたらすごい使いやすかったのでQiitaに書いておく。</p>\n<p><img src=\"https://qiita-image-store.s3.amazonaws.com/0/46637/804627de-d7bf-f8a0-011f-0b74f0484e65.jpeg\" alt=\"EditBox.jpg\"></p>\n<p>すごい！　()のネスティングが色分けされててすごい見やすい！　すごいofすごい！</p>\n<p>というわけでEditBoxを使おう。</p>\n<h1>\n        <span id=\"1-1\" class=\"fragment\"></span>\n        <a href=\"#1-1\"><i class=\"fa fa-link\"></i></a>インストール\n      </h1><p><a href=\"http://editbox.sourceforge.net/\" title=\"\" target=\"_blank\">EditBox公式</a></p>\n<p>本来はJavaとPython、あとNodeclipse用のプラグインらしいが、Common Lispでも十分動く。<a href=\"http://qiita.com/aki426/items/bfd17b901f5fd2df656c\" title=\"\">以前書いたエントリ</a>のDandelionと組み合わせると良い。</p>\n<h1>\n        <span id=\"1-2\" class=\"fragment\"></span>\n        <a href=\"#1-2\"><i class=\"fa fa-link\"></i></a>設定\n      </h1><p>設定はこんな感じ。</p>\n<p><img src=\"https://qiita-image-store.s3.amazonaws.com/0/46637/937fd40c-7a6a-258f-0e15-3a80ef149b75.jpeg\" alt=\"editbox_setting.jpg\"></p>\n<p><a href=\"https://github.com/aki426/Eclipse/blob/master/lisp.eb\" title=\"\" target=\"_blank\">設定ファイル</a></p>\n<p>「構文」という項目がどれを選んでも変化が無いあたり、よくわからないが無難に「Text」にしてある。色は下記のような感じ。上記設定ファイル「lisp.eb」のインポートで設定できるが。</p>\n<p>開始色　RGB:184,184,184<br>\n末端色　RGB:255,255,184</p>\n",
        "stock_users": [
            "RPG",
            "kasumani",
            "akmiyoshi",
            "hakomo",
            "lambdasakura@github",
            "JunSuzukiJapan@github",
            "Noboruhi"
        ]
    },
    {
        "id": 86853,
        "uuid": "2319f53b4fd585a67ae5",
        "user": {
            "id": 46637,
            "url_name": "aki426",
            "profile_image_url": "https://pbs.twimg.com/profile_images/427469601811619840/kQSq4Cue_normal.jpeg"
        },
        "title": "HyperSpecをヘルプファイルに変換して幸せになる方法",
        "created_at": "2014-07-01 22:04:31 +0900",
        "updated_at": "2014-07-06 20:50:27 +0900",
        "created_at_in_words": "3ヶ月",
        "updated_at_in_words": "3ヶ月",
        "tags": [
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            }
        ],
        "stock_count": 1,
        "comment_count": 0,
        "url": "http://qiita.com/aki426/items/2319f53b4fd585a67ae5",
        "created_at_as_seconds": 1404219871,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "さてまたLispネタである。\n\n#経緯\n\nCommon Lispのリファレンスが欲しい！　という場合、下記2つの選択肢がある。\n\n0. [Franz Inc.社のAnsi Common Lisp仕様書のHTML Helpファイル](http://tech.nitoyon.com/ja/blog/2009/02/03/ansicl-chm/)\n1. [Lisp Works社のAnsi Common Lisp仕様書「HyperSpec」のHTMLファイル](http://www.lispworks.com/downloads/documentation.html)\n\n1のFranz社の方はありがたいことにヘルプファイルにまとめてくださっている方がいたので、ありがたく使わせてもらうこととして。問題は2の方である。LispWorksやEmacsのLisp開発環境Slimeからは検索機能などが整備されているのだが、私のようにEclipse＋Cygwinから使っているような場合はその恩恵にあずかれない。というわけで何とかしてみた。\n\n#やること\n\n##HyperSpecのダウンロード\n\n[HyperSpecサイト](http://www.lispworks.com/downloads/documentation.html)の「There is a downloadable archive of the HyperSpec here.」の末尾「here」のリンクからHTMLファイルを一括ダウンロードできる。\n\n解凍してでてきた「HyperSpec」フォルダを適当なところに置く。\n\n##hhhlpのダウンロード＆インストール＆プロジェクトファイル生成\n\n[hhhlp](http://www.vector.co.jp/soft/winnt/prog/se496197.html)をダウンロード＆インストール＆実行。「HTML Helpのタイトル」に適当な名前（HyperSpecHelpとか）を入れて、先ほど解凍した「HyperSpec」フォルダをぶっこんで「実行」。\n\n「HyperSpec」フォルダの下に.hhpファイルが生成されていることを確認。\n\n※追記：hhhlpが生成してくれるindex.html（hhpファイルと同じ場所に作られる）は「Hyperspec」とだけ表示されるだけなので、HyperSpecの標準のindex.htmlの内容をコピペする。ちなみにコピペした後のファイルがこちらです（3分クッキング風に）。\n\n[HyperSpecHelpファイル用index.html](https://github.com/aki426/scripts/blob/master/Hyperspec_index.html)\n\n\n\n##HTML Help Workshopのダウンロード＆インストール＆コンパイル\n\n[Microsoft HTML Help Downloads](http://msdn.microsoft.com/en-us/library/ms669985.aspx)からHTML Help Workshopをダウンロード＆インストール＆実行。先ほどのhhpファイルをロードしてコンパイル。\n\nすると先ほどと同じ場所に.chmファイルが生成されている。開いてみよう。こんな風になってたら成功。\n\n![hs_index.jpg](https://qiita-image-store.s3.amazonaws.com/0/46637/2cbe5b08-776d-c8f4-2746-b6dfbfa59eac.jpeg)\n\n#おしまい\n\nあとはAlt+Nで好きなだけ検索してね！\n（HyperSpecのヘルプファイルの再配布はなんかライセンス的にマズいような気がするのでしません。）\n\nめでたしめでたし。\n",
        "body": "<p>さてまたLispネタである。</p>\n<h1>\n        <span id=\"1-1\" class=\"fragment\"></span>\n        <a href=\"#1-1\"><i class=\"fa fa-link\"></i></a>経緯\n      </h1><p>Common Lispのリファレンスが欲しい！　という場合、下記2つの選択肢がある。</p>\n\n<ol>\n<li><a href=\"http://tech.nitoyon.com/ja/blog/2009/02/03/ansicl-chm/\" title=\"\" target=\"_blank\">Franz Inc.社のAnsi Common Lisp仕様書のHTML Helpファイル</a></li>\n<li><a href=\"http://www.lispworks.com/downloads/documentation.html\" title=\"\" target=\"_blank\">Lisp Works社のAnsi Common Lisp仕様書「HyperSpec」のHTMLファイル</a></li>\n</ol>\n<p>1のFranz社の方はありがたいことにヘルプファイルにまとめてくださっている方がいたので、ありがたく使わせてもらうこととして。問題は2の方である。LispWorksやEmacsのLisp開発環境Slimeからは検索機能などが整備されているのだが、私のようにEclipse＋Cygwinから使っているような場合はその恩恵にあずかれない。というわけで何とかしてみた。</p>\n<h1>\n        <span id=\"1-2\" class=\"fragment\"></span>\n        <a href=\"#1-2\"><i class=\"fa fa-link\"></i></a>やること\n      </h1><h2>\n        <span id=\"2-1\" class=\"fragment\"></span>\n        <a href=\"#2-1\"><i class=\"fa fa-link\"></i></a>HyperSpecのダウンロード\n      </h2><p><a href=\"http://www.lispworks.com/downloads/documentation.html\" title=\"\" target=\"_blank\">HyperSpecサイト</a>の「There is a downloadable archive of the HyperSpec here.」の末尾「here」のリンクからHTMLファイルを一括ダウンロードできる。</p>\n<p>解凍してでてきた「HyperSpec」フォルダを適当なところに置く。</p>\n<h2>\n        <span id=\"2-2\" class=\"fragment\"></span>\n        <a href=\"#2-2\"><i class=\"fa fa-link\"></i></a>hhhlpのダウンロード＆インストール＆プロジェクトファイル生成\n      </h2><p><a href=\"http://www.vector.co.jp/soft/winnt/prog/se496197.html\" title=\"\" target=\"_blank\">hhhlp</a>をダウンロード＆インストール＆実行。「HTML Helpのタイトル」に適当な名前（HyperSpecHelpとか）を入れて、先ほど解凍した「HyperSpec」フォルダをぶっこんで「実行」。</p>\n<p>「HyperSpec」フォルダの下に.hhpファイルが生成されていることを確認。</p>\n<p>※追記：hhhlpが生成してくれるindex.html（hhpファイルと同じ場所に作られる）は「Hyperspec」とだけ表示されるだけなので、HyperSpecの標準のindex.htmlの内容をコピペする。ちなみにコピペした後のファイルがこちらです（3分クッキング風に）。</p>\n<p><a href=\"https://github.com/aki426/scripts/blob/master/Hyperspec_index.html\" title=\"\" target=\"_blank\">HyperSpecHelpファイル用index.html</a></p>\n<h2>\n        <span id=\"2-3\" class=\"fragment\"></span>\n        <a href=\"#2-3\"><i class=\"fa fa-link\"></i></a>HTML Help Workshopのダウンロード＆インストール＆コンパイル\n      </h2><p><a href=\"http://msdn.microsoft.com/en-us/library/ms669985.aspx\" title=\"\" target=\"_blank\">Microsoft HTML Help Downloads</a>からHTML Help Workshopをダウンロード＆インストール＆実行。先ほどのhhpファイルをロードしてコンパイル。</p>\n<p>すると先ほどと同じ場所に.chmファイルが生成されている。開いてみよう。こんな風になってたら成功。</p>\n<p><img src=\"https://qiita-image-store.s3.amazonaws.com/0/46637/2cbe5b08-776d-c8f4-2746-b6dfbfa59eac.jpeg\" alt=\"hs_index.jpg\"></p>\n<h1>\n        <span id=\"1-3\" class=\"fragment\"></span>\n        <a href=\"#1-3\"><i class=\"fa fa-link\"></i></a>おしまい\n      </h1><p>あとはAlt+Nで好きなだけ検索してね！<br>\n（HyperSpecのヘルプファイルの再配布はなんかライセンス的にマズいような気がするのでしません。）</p>\n<p>めでたしめでたし。</p>\n",
        "stock_users": [
            "akmiyoshi"
        ]
    },
    {
        "id": 84635,
        "uuid": "aa5705978d6a13753fe2",
        "user": {
            "id": 27560,
            "url_name": "kenokabe",
            "profile_image_url": "https://secure.gravatar.com/avatar/81fb914aee4a2bc01df64be9ee830337?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png"
        },
        "title": "LISPデータ構造の問題点と抜本的な解法としての新プログラミング言語の策定　純粋関数型言語「SpaceTime」 ドラフト",
        "created_at": "2014-06-26 11:56:40 +0900",
        "updated_at": "2014-06-29 00:05:37 +0900",
        "created_at_in_words": "3ヶ月",
        "updated_at_in_words": "3ヶ月",
        "tags": [
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "JavaScript",
                "url_name": "javascript",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/c01023cf926d47b711747c9d00b00fd18dc6638a/medium.jpg?1364837881",
                "versions": []
            },
            {
                "name": "Node.js",
                "url_name": "node.js",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/99671b12d7d2688f35c262552f16c7cc9d10b873/medium.jpg?1390767445",
                "versions": []
            },
            {
                "name": "関数型言語",
                "url_name": "%e9%96%a2%e6%95%b0%e5%9e%8b%e8%a8%80%e8%aa%9e",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            },
            {
                "name": "FRP",
                "url_name": "frp",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            }
        ],
        "stock_count": 21,
        "comment_count": 8,
        "url": "http://qiita.com/kenokabe/items/aa5705978d6a13753fe2",
        "created_at_as_seconds": 1403751400,
        "tweet": false,
        "gist_url": "https://gist.github.com/9ece017fb1e7d14973c7",
        "private": false,
        "raw_body": "#### KenOKABE tech blog\n####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)\n\n#記事シリーズ\n#### [Swiftで脱アルゴリズム！iOS開発を関数型（宣言型）プログラミングへパラダイムシフトしてみる【脱アルゴリズム宣言①】](http://qiita.com/kenokabe/items/41189c45001321c9e283)\n####  [関数リアクティブプログラミング（FRP）で分断された2つの世界を繋ぐ【脱アルゴリズム宣言②】](http://qiita.com/kenokabe/items/a8477694a499ca869cde)\n#### [関数型（宣言型）プログラミングで無限をコーディングする「遅延評価」のわかりやすい解説【脱アルゴリズム宣言③】](http://qiita.com/kenokabe/items/821ce4020644372b648c)\n\n#### [LISPデータ構造の問題点と抜本的な解法としての新プログラミング言語の策定　純粋関数型言語「SpaceTime」 ドラフト](http://qiita.com/kenokabe/items/aa5705978d6a13753fe2)\n\n#### [遅延評価(Lazy.js)とFRP(Bacon.js)とJavaScriptで時空なんでもマッピング！【時空プログラミング①】](http://qiita.com/kenokabe/items/b04e3d8d49b0ffc7a78b)\n\n#### [タイマーを無限個作り、データとして取り回す【時空プログラミング②】](http://qiita.com/kenokabe/items/8c970d2b0dfa98187998)\n\n#### [自然数と自然数+1 で偶数と奇数を作る【時空プログラミング③】]( http://qiita.com/kenokabe/items/f6172df8d8416429656a)\n\n#### [数学と別離したプログラミング、時間を抽象化し数学を取り戻すプログラミング【時空プログラミング④】](http://qiita.com/kenokabe/items/b81c7aa8af86314551a0)\n\n# LISPデータ構造の問題点と抜本的な解法としての新プログラミング言語の策定　純粋関数型言語「SpaceTime」 ドラフト\n\nジョン・マッカーシーが開発したLISPは\n\n(関数 引数 引数 引数)\n\nという\n\n[S式](http://ja.wikipedia.org/wiki/S%E5%BC%8F)\nで表記され、プログラミング構文が存在しません。\n\n```\n> (+ 1 2)\n3\n```\n\n\nデータ=コード\nコード＝データ\nという（一見）美しい構造で、コードを変更するにはデータを変更すればよい、というコード自身を第一級（ファーストクラス）オブジェクトとして扱うことができます。\n\n最近、巷で若干注目を集めている、Javaでも実装されはじめた [リフレクション](http://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3_(%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6))\nの最上級機能を言語構造として先天的に実装しているようなもので、自己定義する人工知能研究の分野（マッカーシーの専門分野）でよく使われてきたようです。\n　\nしかし、私がLISPを関数型言語の大御所として試すなかで問題だと思った事をざっくばらんに書きます。\n\nすでに【脱アルゴリズム宣言】シリーズで述べたように、関数型パラダイムは、まず最初にデータをまるごと用意し、そこに関数操作を加えていくという宣言をするという思考・指向でした。\n\nこういうデータをまるごと用意する、データのコレクション、リストという発想は、LISPのリストがオリジナルなのですが、遺憾なことに\n\n(関数 引数 引数 引数)\n\nっていうのが命令型パラダイムであるのに気づくでしょうか？\n\n(Do what what what)\n\nという構造になっている。\n\n関数型パラダイムであるならば、こう書くべきでしょう。\n\n(What Do Do Do)\n\n(データ 関数 関数 関数)\n\nそして、実際のところ\n\n(関数 引数 引数 引数)\n\nというデータ構造のために様々な目に見える弊害がLISP/Schemeにはあります。\n\n(関数 引数 引数 引数)とS式の最初が（データでなく）関数と決め打ちしているので、\n\n(データ　データ　データ)　たとえば\n\n```\n(1 2 3)\n```\n\nというデータをそのまま書くとエラーになるんですね。だってまず `1`を関数として実行しようとするけど、関数ではないので。\n\n\nすべてがデータでありコードであり、コード自身を第一級（ファーストクラス）オブジェクトとして扱うことができる、という看板の割にあまりにもお粗末な結果です。\n\nこれを回避するために、\n\n```\n>(list 1 2 3)\n(1 2 3)\n```\n\nという、見た目、カッコの位置がずれてデータ構造が変わってしまう方法\nだったり\n\nカッコの位置が一緒のデータ構造を維持しようと思えば、\n\n```\n> (quote (1 2 3))\n(1 2 3)\n```\nあるいは、quoteのショートカット記号を用いて\n\n```\n> '(1 2 3)\n(1 2 3)\n```\n\nと書く必要があります。このクオート記号すぐ打つの忘れるんですよね。非常に面倒くさい。美しくない。\n\nそしてよく考えてみると、S式の要件定義によれば、\n\n(関数 引数 引数 引数)\n\nなので、\n\nこの\n\n```\n(quote (1 2 3))\n```\nの中身のかっこ(1 2 3)\nはS式じゃないだろ！ってことになります。\n\nそもそも(1 2 3)ってそのまま書いたらエラーになるから、quote付けたけど、定義どうりならばどっちにせよ無理で、\n\n最初の\n\n(list 1 2 3)\n\nって書くしか整合性を保つ方法がない！ってことになります。\nどうなってるのか？\n\n実は、\n\n(quote (1 2 3))\n\nの場合、引数である\n(1 2 3)\nっていうのは、S式として評価されません。\n\nS式でない評価しない特別なデータとして扱います。例外です。\n\n例外、美しくないですね。余剰なルールが追加されるわけで単純さが損なわれるからです。\n\nこんな調子では、\n\n「すべてがデータでありコードであり、コード自身を第一級（ファーストクラス）オブジェクトとして扱うことができる」\n\nと鵜呑みにして統一的に操作できると突き進んでも、いろいろ面倒なパッチを加えながらやるしかない未来が待ち受けているのは明々白々な状況です。\n\n- 命令型オリエンテッドなS式の表記\n\n- 破綻したデータ表現\n\nどうにか回避策は無いものか？と試行錯誤しましたが\n\n「ありませんでした」\n\n「そして根本的な理由がわかりました」\n\nS式のリストは、\n[Singly_linked_list](http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_list)\nというリスト構造になっています。\n![](http://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)\n\nLISPのすべてを束縛するS式の表記は、この[Singly_linked_list](http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_list)\nというリスト構造と等価であり、問題を解決するにはここからどうにかしないといけない。\n\n\nLISPのリストで\n((a b c)(d e f)(g h i))\nは、\nhttp://www.ki.nu/OHP/dot.emacs/list-drawing.html\n（ToDo　図作成）\n\nのようになっており、データの末尾を示すため終端にnilという空データをにつけます。\n\nこれは美しくない。\n\n- データの末尾を示すため終端にnilという空データをにつける\n\nというのもルールの一つです。\n\nこのルールどおりのものをPureList（純リスト）とし、LISPのS式はそれで構成されているのですが、このルールをぶちやぶって、任意のアトムを終端につけることだって可能です。この場合は\nPureListじゃないので各種操作は破綻する。\n\nセルを自由自在に組み合わせられる、柔軟な表現方法だとおもいきや、こういうルールがある。\nそしてルールどおりにするならば、新たなリストを既存のリストに結合する際には、終端のnilを一旦外し、そこに接続するという２ステップの置換になる。\n自由に接続じゃなくて、置換です。\n\n何かがおかしい、何もかもがしっくりこない、と思ったので、思案の上、自分が理想とする純粋関数型言語をJavaScript上で書きました。\n\nLISPを純粋関数型言語として全面的に書きなおす。\n\nLISPと逆方向のリスト構造を基盤とする。\n\nリストは`EmplyPair`という無限再帰構造をもつ`0`に相当するペアから始まる任意の構造である。\n\n終端に特別な操作がない、特別ルールがないのですべての構造がPureである。\n\n遅延評価であり、必要な構造のみ随時評価されていく。\n\n関数はファーストクラスオブジェクトであり、さらにLISPのように関数とデータの区別はしない\n\nすべての関数はデータである。\n\nすべてのデータは関数である。\n\n`(1 2 3)`というデータは`(1 2 3)`とクオート無しでクリーンにデータどおり表記され遅延評価される。。\n\nもはやLISPとは別物の新言語である。\n\nJSで書かれている、JSで動作する。\n\n#SpaceTime Programming Language\nThe Spacetime Operating Language\n\n![](http://kenokabe.github.io/stability-badges/dist/experimental.svg)\n\n***SpaceTime***\n#### - is a Functional Reactive Programming (FRP) language\n#### - employs Lazy evaluation strategy\n#### - runs on JavaScript Engines (browsers & node.js)\n#### - is written in JavaScript\n\n##Hello world\n---\n\n###Qiitaではスクリプトが許可されていないので\n###[動作デモはプロジェクトサイト](http://spacetimeprogramminglanguage.github.io/)\n\n\n##Foundation\n---\n\n*Inspired by John McCarthy's LISP*\n\n*SpaceTime* is founded on an inverted data structure of\n[Singly linked list](http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_list) and [S-expression](http://en.wikipedia.org/wiki/S-expression).\n\n###Pair\n\n![001](http://spacetimeprogramminglanguage.github.io/contents/img/001.svg)\n\nThis is the fundamental unit of *SpaceTime*.\n`Pair` has a pair of hands to point a pair of any objects.\n\n---\n###Pair points a pair of objects\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/002.svg)\n\nNow, a `Pair` points objects: `a` and `b`.\n\n---\n###Pair notation\n![](http://spacetimeprogramminglanguage.github.io/contents/img/003.svg)\n\nWhen a `Pair` points objects: `a` and `b`, it's expressed as **{a b}** in `Pair notation`.\n\n---\n###Pair can point itself\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/004.svg)\n\n---\n###Empty Pair\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/005.svg)\n\n\n\nWhen a Pair points itself, since it's a form of [Self-reference](http://en.wikipedia.org/wiki/Self-reference), an  [Infinite recursion](http://en.wikipedia.org/wiki/Infinite_loop#Infinite_recursion) occurs.\n\nAccordingly, the `Pair notaion` is { { {...} {...} } { {...} {...} } }, so we simply express the entity as **{ }**, and let's call it `Empty Pair`.\n\n---\n###Push Pair\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/006.svg)\n\nA `Pair` can point another `Pair` so that we can joint `Pair`s.\n\nNow let a `pair` point another `Pair` and `5` by each hands.\nLet's call this special action `Push`.\n\nIn this case, we `push` 5 to an `Empty Pair`.\n\nThe `Pair notation` is **{ {} 5 }**.\n\n\n---\n###Push another Pair\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/007.svg)\n\nIn the same manner, we can `push` another `Pair`.\n\nWe `push` `2` to the previous sequence.\n\nThe `Pair notation` is **{ { {} 5 } 2 }**.\n\n---\n###Push to any sequence\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/008.svg)\n\n---\n###Sequence\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/009.svg)\n\nHere, *SpaceTime* explicitly defines a term `Sequence` for this form.\nPlease note this is the same term and meaning of [Sequence](http://en.wikipedia.org/wiki/Sequence) in Mathematics.\n\nAt the same time, instead of `Pair notation` : { { { {} 5 } 2 } 7 }, it can be simply expressed as **( 5 2 7 )**.\n\n---\n###Push function\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/010.svg)\n\nA `Pair` can point `function`.\n\nAccordingly, we can `push` `function` to any `Sequence`.\n\nIn this case, we `push` a `function` to **(5)**.\n\n---\n###A case of Push function\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/011.svg)\n\nWhen we push a `function` : `plus2` to **(5)**, the result is **(7)**.\n\n---\n###Function is Sequence\nThe `function` : `plus2` is fundamentally some `Sequence`.\n\n`plus2` consists of a `Sequence` : **( plus (2) )**.\n\n**(2)** is an `attribute Sequence` of the `function`.\n\n**( 5 (plus (2)) )** is equivalent to **(7)**.\n\n---\n### Everything is a function and Sequence\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/012.svg)\n\n\nEverything is `function` in *SpaceTime*.\n\nIn this case, `3` is a `function` that maps a source : **( 5 )** to a target : **( 5 3 )**.\n\nConsequently, since `function` is `Sequence` in *SpaceTime*, everything is `Sequence` in *SpaceTime*.\n\nTherefore, `3` is a `function` and at the same time, is a `Sequence`.\n\nHowever, `3` is `3`. There is no other way to express than just `3` in *SpaceTime*.\n\n\n\n---\n###Every Sequence is a result of function to `Empty Pair`\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/013.svg)\n\n---\n###Function composition\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/014.svg)\n\n[Function composition](http://en.wikipedia.org/wiki/Function_composition) is naturally expressed in a form :\n**( *source function fucnction )** in *SpaceTime*.\n\nPlease note the `source` = **( 1 )** as a `Sequence`, not 1.\n\n---\n###1 +2 +3 = 6\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/015.svg)\n\n*SpaceTime* has a short-cut notation : **+** corresponding to `plus` function.\n\n---\n###1 +(2 +3) = 6\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/016.svg)\n\n( 1 (+ ( 2 (+ ( 3 ) ) ) ) )  =  ( 6 )\n\n---\n###Indefinite sequence\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/017.svg)\n\n*SpaceTime* employes an [evaluation strategy](http://en.wikipedia.org/wiki/Evaluation_strategy) : [lazy evaluation, or call-by-need](http://en.wikipedia.org/wiki/Lazy_evaluation).\n\nAccordingly, *SpaceTime* can deal with Indefinite sequence such as [Natural number](http://en.wikipedia.org/wiki/Natural_number).\n\n---\n###I/O (Input and Output)\n\n![](http://spacetimeprogramminglanguage.github.io/contents/img/018.svg)\n\n[I/O](http://en.wikipedia.org/wiki/Input/output) does not affect the evaluation context of *SpaceTime* directly, so that it can preserve [Functional programming](http://en.wikipedia.org/wiki/Functional_programming) paradigm.\n\n*SpaceTime* employes [FRP](http://en.wikipedia.org/wiki/Functional_reactive_programming) or `SpaceTime Programming paradigm`.\n\n---\n\n\n##Basic\n---\n###Hello world\n`Code`\n```\n(\n  \"hello World\"\n  (map (CONSOLE))\n)\n```\n`Evaluation`\n```\n(\"hello World\")\n```\n`Console`\n```\nhello World\n```\n---\n###Hello world twice\n\n`Code`\n```\n(\n  \"hello World\"\n  (map (CONSOLE))\n  (map (CONSOLE))\n)\n```\n`Evaluation`\n```\n(\"hello World\")\n```\n`Console`\n```\nhello World\nhello World\n```\n\n---\n###Boolean\n\n`Code`\n```\n(3 (== (3)) )\n```\n`Evaluation`\n```\n(true)\n```\n\n\n`Code`\n```\n(3 (== (5)) )\n```\n`Evaluation`\n```\n(false)\n```\n\n\n`Code`\n```\n(2 (> (1)) )\n```\n`Evaluation`\n```\n(true)\n```\n\n\n`Code`\n```\n(2 (< (1)) )\n```\n`Evaluation`\n```\n(false)\n```\n\n\n---\n###Conditional\n\n`Code`\n```\n(\n　　3 (==(3))　\n   (\n     if (\n           (\"match\")\n           (\"mismatch\")\n        )\n   )\n)\n```\n`Evaluation`\n```\n(\"match\")\n```\n\n\n`Code`\n```\n(\n　　3 (==(5))　\n   (\n     if (\n           (\"match\")\n           (\"mismatch\")\n        )\n   )\n)\n```\n`Evaluation`\n```\n(\"mismatch\")\n```\n\n\n`Code`\n```\n(\n　　3 (==(5))　\n   (\n     if (\n           (\"case1\")\n           (\n           　　3 (==(3))　\n              (\n                if (\n                      (\"case2\")\n                      (\n                      　　3 (==(3))　\n                         (\n                           if (\n                                 (\"case3\")\n                                 (\"mismatch\")\n                              )\n                         )\n                      )\n                   )\n              )\n           )\n        )\n   )\n)\n\n```\n`Evaluation`\n```\n(\"case2\")\n```\n\n\n`Code`\n```\n(\n　　3 (==(5))　\n   (\n     if (\n           (\"case1\")\n           (\n           　　3 (==(1))　\n              (\n                if (\n                      (\"case2\")\n                      (\n                      　　3 (==(3))　\n                         (\n                           if (\n                                 (\"case3\")\n                                 (\"mismatch\")\n                              )\n                         )\n                      )\n                   )\n              )\n           )\n        )\n   )\n)\n\n```\n\n`Evaluation`\n\n```\n(\"case3\")\n```\n\n\n\n\n\n\n---\n\n\n\n\n\n#### KenOKABE tech blog\n####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)\n",
        "body": "<h4>\n        <span id=\"4-1\" class=\"fragment\"></span>\n        <a href=\"#4-1\"><i class=\"fa fa-link\"></i></a>KenOKABE tech blog\n      </h4><h4>\n        <span id=\"4-2\" class=\"fragment\"></span>\n        <a href=\"#4-2\"><i class=\"fa fa-link\"></i></a><a href=\"http://kenokabe.github.io/contents/entries/entry0/entry.html\" title=\"\">←ブログコンテンツ</a>\n      </h4><h1>\n        <span id=\"1-1\" class=\"fragment\"></span>\n        <a href=\"#1-1\"><i class=\"fa fa-link\"></i></a>記事シリーズ\n      </h1><h4>\n        <span id=\"4-3\" class=\"fragment\"></span>\n        <a href=\"#4-3\"><i class=\"fa fa-link\"></i></a><a href=\"http://qiita.com/kenokabe/items/41189c45001321c9e283\" title=\"\">Swiftで脱アルゴリズム！iOS開発を関数型（宣言型）プログラミングへパラダイムシフトしてみる【脱アルゴリズム宣言①】</a>\n      </h4><h4>\n        <span id=\"4-4\" class=\"fragment\"></span>\n        <a href=\"#4-4\"><i class=\"fa fa-link\"></i></a><a href=\"http://qiita.com/kenokabe/items/a8477694a499ca869cde\" title=\"\">関数リアクティブプログラミング（FRP）で分断された2つの世界を繋ぐ【脱アルゴリズム宣言②】</a>\n      </h4><h4>\n        <span id=\"4-5\" class=\"fragment\"></span>\n        <a href=\"#4-5\"><i class=\"fa fa-link\"></i></a><a href=\"http://qiita.com/kenokabe/items/821ce4020644372b648c\" title=\"\">関数型（宣言型）プログラミングで無限をコーディングする「遅延評価」のわかりやすい解説【脱アルゴリズム宣言③】</a>\n      </h4><h4>\n        <span id=\"4-6\" class=\"fragment\"></span>\n        <a href=\"#4-6\"><i class=\"fa fa-link\"></i></a><a href=\"http://qiita.com/kenokabe/items/aa5705978d6a13753fe2\" title=\"\">LISPデータ構造の問題点と抜本的な解法としての新プログラミング言語の策定　純粋関数型言語「SpaceTime」 ドラフト</a>\n      </h4><h4>\n        <span id=\"4-7\" class=\"fragment\"></span>\n        <a href=\"#4-7\"><i class=\"fa fa-link\"></i></a><a href=\"http://qiita.com/kenokabe/items/b04e3d8d49b0ffc7a78b\" title=\"\">遅延評価(Lazy.js)とFRP(Bacon.js)とJavaScriptで時空なんでもマッピング！【時空プログラミング①】</a>\n      </h4><h4>\n        <span id=\"4-8\" class=\"fragment\"></span>\n        <a href=\"#4-8\"><i class=\"fa fa-link\"></i></a><a href=\"http://qiita.com/kenokabe/items/8c970d2b0dfa98187998\" title=\"\">タイマーを無限個作り、データとして取り回す【時空プログラミング②】</a>\n      </h4><h4>\n        <span id=\"4-9\" class=\"fragment\"></span>\n        <a href=\"#4-9\"><i class=\"fa fa-link\"></i></a><a href=\"http://qiita.com/kenokabe/items/f6172df8d8416429656a\" title=\"\">自然数と自然数+1 で偶数と奇数を作る【時空プログラミング③】</a>\n      </h4><h4>\n        <span id=\"4-10\" class=\"fragment\"></span>\n        <a href=\"#4-10\"><i class=\"fa fa-link\"></i></a><a href=\"http://qiita.com/kenokabe/items/b81c7aa8af86314551a0\" title=\"\">数学と別離したプログラミング、時間を抽象化し数学を取り戻すプログラミング【時空プログラミング④】</a>\n      </h4><h1>\n        <span id=\"1-2\" class=\"fragment\"></span>\n        <a href=\"#1-2\"><i class=\"fa fa-link\"></i></a>LISPデータ構造の問題点と抜本的な解法としての新プログラミング言語の策定　純粋関数型言語「SpaceTime」 ドラフト\n      </h1><p>ジョン・マッカーシーが開発したLISPは</p>\n<p>(関数 引数 引数 引数)</p>\n<p>という</p>\n<p><a href=\"http://ja.wikipedia.org/wiki/S%E5%BC%8F\" title=\"\" target=\"_blank\">S式</a><br>\nで表記され、プログラミング構文が存在しません。</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>&gt; (+ 1 2)\n3\n</pre></div></div><p>データ=コード<br>\nコード＝データ<br>\nという（一見）美しい構造で、コードを変更するにはデータを変更すればよい、というコード自身を第一級（ファーストクラス）オブジェクトとして扱うことができます。</p>\n<p>最近、巷で若干注目を集めている、Javaでも実装されはじめた <a href=\"http://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3_(%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6)\" title=\"\" target=\"_blank\">リフレクション</a><br>\nの最上級機能を言語構造として先天的に実装しているようなもので、自己定義する人工知能研究の分野（マッカーシーの専門分野）でよく使われてきたようです。<br>\n　<br>\nしかし、私がLISPを関数型言語の大御所として試すなかで問題だと思った事をざっくばらんに書きます。</p>\n<p>すでに【脱アルゴリズム宣言】シリーズで述べたように、関数型パラダイムは、まず最初にデータをまるごと用意し、そこに関数操作を加えていくという宣言をするという思考・指向でした。</p>\n<p>こういうデータをまるごと用意する、データのコレクション、リストという発想は、LISPのリストがオリジナルなのですが、遺憾なことに</p>\n<p>(関数 引数 引数 引数)</p>\n<p>っていうのが命令型パラダイムであるのに気づくでしょうか？</p>\n<p>(Do what what what)</p>\n<p>という構造になっている。</p>\n<p>関数型パラダイムであるならば、こう書くべきでしょう。</p>\n<p>(What Do Do Do)</p>\n<p>(データ 関数 関数 関数)</p>\n<p>そして、実際のところ</p>\n<p>(関数 引数 引数 引数)</p>\n<p>というデータ構造のために様々な目に見える弊害がLISP/Schemeにはあります。</p>\n<p>(関数 引数 引数 引数)とS式の最初が（データでなく）関数と決め打ちしているので、</p>\n<p>(データ　データ　データ)　たとえば</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>(1 2 3)\n</pre></div></div><p>というデータをそのまま書くとエラーになるんですね。だってまず <code>1</code>を関数として実行しようとするけど、関数ではないので。</p>\n<p>すべてがデータでありコードであり、コード自身を第一級（ファーストクラス）オブジェクトとして扱うことができる、という看板の割にあまりにもお粗末な結果です。</p>\n<p>これを回避するために、</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>&gt;(list 1 2 3)\n(1 2 3)\n</pre></div></div><p>という、見た目、カッコの位置がずれてデータ構造が変わってしまう方法<br>\nだったり</p>\n<p>カッコの位置が一緒のデータ構造を維持しようと思えば、</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>&gt; (quote (1 2 3))\n(1 2 3)\n</pre></div></div><p>あるいは、quoteのショートカット記号を用いて</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>&gt; &#39;(1 2 3)\n(1 2 3)\n</pre></div></div><p>と書く必要があります。このクオート記号すぐ打つの忘れるんですよね。非常に面倒くさい。美しくない。</p>\n<p>そしてよく考えてみると、S式の要件定義によれば、</p>\n<p>(関数 引数 引数 引数)</p>\n<p>なので、</p>\n<p>この</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>(quote (1 2 3))\n</pre></div></div><p>の中身のかっこ(1 2 3)<br>\nはS式じゃないだろ！ってことになります。</p>\n<p>そもそも(1 2 3)ってそのまま書いたらエラーになるから、quote付けたけど、定義どうりならばどっちにせよ無理で、</p>\n<p>最初の</p>\n<p>(list 1 2 3)</p>\n<p>って書くしか整合性を保つ方法がない！ってことになります。<br>\nどうなってるのか？</p>\n<p>実は、</p>\n<p>(quote (1 2 3))</p>\n<p>の場合、引数である<br>\n(1 2 3)<br>\nっていうのは、S式として評価されません。</p>\n<p>S式でない評価しない特別なデータとして扱います。例外です。</p>\n<p>例外、美しくないですね。余剰なルールが追加されるわけで単純さが損なわれるからです。</p>\n<p>こんな調子では、</p>\n<p>「すべてがデータでありコードであり、コード自身を第一級（ファーストクラス）オブジェクトとして扱うことができる」</p>\n<p>と鵜呑みにして統一的に操作できると突き進んでも、いろいろ面倒なパッチを加えながらやるしかない未来が待ち受けているのは明々白々な状況です。</p>\n\n<ul>\n<li><p>命令型オリエンテッドなS式の表記</p></li>\n<li><p>破綻したデータ表現</p></li>\n</ul>\n<p>どうにか回避策は無いものか？と試行錯誤しましたが</p>\n<p>「ありませんでした」</p>\n<p>「そして根本的な理由がわかりました」</p>\n<p>S式のリストは、<br>\n<a href=\"http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_list\" title=\"\" target=\"_blank\">Singly_linked_list</a><br>\nというリスト構造になっています。<br>\n<img src=\"http://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg\" alt=\"\"></p>\n<p>LISPのすべてを束縛するS式の表記は、この<a href=\"http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_list\" title=\"\" target=\"_blank\">Singly_linked_list</a><br>\nというリスト構造と等価であり、問題を解決するにはここからどうにかしないといけない。</p>\n<p>LISPのリストで<br>\n((a b c)(d e f)(g h i))<br>\nは、<br>\n<a href=\"http://www.ki.nu/OHP/dot.emacs/list-drawing.html\" title=\"http://www.ki.nu/OHP/dot.emacs/list-drawing.html\" target=\"_blank\">http://www.ki.nu/OHP/dot.emacs/list-drawing.html</a><br>\n（ToDo　図作成）</p>\n<p>のようになっており、データの末尾を示すため終端にnilという空データをにつけます。</p>\n<p>これは美しくない。</p>\n\n<ul>\n<li>データの末尾を示すため終端にnilという空データをにつける</li>\n</ul>\n<p>というのもルールの一つです。</p>\n<p>このルールどおりのものをPureList（純リスト）とし、LISPのS式はそれで構成されているのですが、このルールをぶちやぶって、任意のアトムを終端につけることだって可能です。この場合は<br>\nPureListじゃないので各種操作は破綻する。</p>\n<p>セルを自由自在に組み合わせられる、柔軟な表現方法だとおもいきや、こういうルールがある。<br>\nそしてルールどおりにするならば、新たなリストを既存のリストに結合する際には、終端のnilを一旦外し、そこに接続するという２ステップの置換になる。<br>\n自由に接続じゃなくて、置換です。</p>\n<p>何かがおかしい、何もかもがしっくりこない、と思ったので、思案の上、自分が理想とする純粋関数型言語をJavaScript上で書きました。</p>\n<p>LISPを純粋関数型言語として全面的に書きなおす。</p>\n<p>LISPと逆方向のリスト構造を基盤とする。</p>\n<p>リストは<code>EmplyPair</code>という無限再帰構造をもつ<code>0</code>に相当するペアから始まる任意の構造である。</p>\n<p>終端に特別な操作がない、特別ルールがないのですべての構造がPureである。</p>\n<p>遅延評価であり、必要な構造のみ随時評価されていく。</p>\n<p>関数はファーストクラスオブジェクトであり、さらにLISPのように関数とデータの区別はしない</p>\n<p>すべての関数はデータである。</p>\n<p>すべてのデータは関数である。</p>\n<p><code>(1 2 3)</code>というデータは<code>(1 2 3)</code>とクオート無しでクリーンにデータどおり表記され遅延評価される。。</p>\n<p>もはやLISPとは別物の新言語である。</p>\n<p>JSで書かれている、JSで動作する。</p>\n<h1>\n        <span id=\"1-3\" class=\"fragment\"></span>\n        <a href=\"#1-3\"><i class=\"fa fa-link\"></i></a>SpaceTime Programming Language\n      </h1><p>The Spacetime Operating Language</p>\n<p><img src=\"http://kenokabe.github.io/stability-badges/dist/experimental.svg\" alt=\"\"></p>\n<p><strong><em>SpaceTime</em></strong></p>\n<h4>\n        <span id=\"4-11\" class=\"fragment\"></span>\n        <a href=\"#4-11\"><i class=\"fa fa-link\"></i></a>- is a Functional Reactive Programming (FRP) language\n      </h4><h4>\n        <span id=\"4-12\" class=\"fragment\"></span>\n        <a href=\"#4-12\"><i class=\"fa fa-link\"></i></a>- employs Lazy evaluation strategy\n      </h4><h4>\n        <span id=\"4-13\" class=\"fragment\"></span>\n        <a href=\"#4-13\"><i class=\"fa fa-link\"></i></a>- runs on JavaScript Engines (browsers &amp; node.js)\n      </h4><h4>\n        <span id=\"4-14\" class=\"fragment\"></span>\n        <a href=\"#4-14\"><i class=\"fa fa-link\"></i></a>- is written in JavaScript\n      </h4><h2>\n        <span id=\"2-1\" class=\"fragment\"></span>\n        <a href=\"#2-1\"><i class=\"fa fa-link\"></i></a>Hello world\n      </h2>\n<hr>\n<h3>\n        <span id=\"3-1\" class=\"fragment\"></span>\n        <a href=\"#3-1\"><i class=\"fa fa-link\"></i></a>Qiitaではスクリプトが許可されていないので\n      </h3><h3>\n        <span id=\"3-2\" class=\"fragment\"></span>\n        <a href=\"#3-2\"><i class=\"fa fa-link\"></i></a><a href=\"http://spacetimeprogramminglanguage.github.io/\" title=\"\">動作デモはプロジェクトサイト</a>\n      </h3><h2>\n        <span id=\"2-2\" class=\"fragment\"></span>\n        <a href=\"#2-2\"><i class=\"fa fa-link\"></i></a>Foundation\n      </h2>\n<hr>\n<p><em>Inspired by John McCarthy&#39;s LISP</em></p>\n<p><em>SpaceTime</em> is founded on an inverted data structure of<br>\n<a href=\"http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_list\" title=\"\" target=\"_blank\">Singly linked list</a> and <a href=\"http://en.wikipedia.org/wiki/S-expression\" title=\"\" target=\"_blank\">S-expression</a>.</p>\n<h3>\n        <span id=\"3-3\" class=\"fragment\"></span>\n        <a href=\"#3-3\"><i class=\"fa fa-link\"></i></a>Pair\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/001.svg\" alt=\"001\"></p>\n<p>This is the fundamental unit of <em>SpaceTime</em>.<br>\n<code>Pair</code> has a pair of hands to point a pair of any objects.</p>\n\n<hr>\n<h3>\n        <span id=\"3-4\" class=\"fragment\"></span>\n        <a href=\"#3-4\"><i class=\"fa fa-link\"></i></a>Pair points a pair of objects\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/002.svg\" alt=\"\"></p>\n<p>Now, a <code>Pair</code> points objects: <code>a</code> and <code>b</code>.</p>\n\n<hr>\n<h3>\n        <span id=\"3-5\" class=\"fragment\"></span>\n        <a href=\"#3-5\"><i class=\"fa fa-link\"></i></a>Pair notation\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/003.svg\" alt=\"\"></p>\n<p>When a <code>Pair</code> points objects: <code>a</code> and <code>b</code>, it&#39;s expressed as <strong>{a b}</strong> in <code>Pair notation</code>.</p>\n\n<hr>\n<h3>\n        <span id=\"3-6\" class=\"fragment\"></span>\n        <a href=\"#3-6\"><i class=\"fa fa-link\"></i></a>Pair can point itself\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/004.svg\" alt=\"\"></p>\n\n<hr>\n<h3>\n        <span id=\"3-7\" class=\"fragment\"></span>\n        <a href=\"#3-7\"><i class=\"fa fa-link\"></i></a>Empty Pair\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/005.svg\" alt=\"\"></p>\n<p>When a Pair points itself, since it&#39;s a form of <a href=\"http://en.wikipedia.org/wiki/Self-reference\" title=\"\" target=\"_blank\">Self-reference</a>, an  <a href=\"http://en.wikipedia.org/wiki/Infinite_loop#Infinite_recursion\" title=\"\" target=\"_blank\">Infinite recursion</a> occurs.</p>\n<p>Accordingly, the <code>Pair notaion</code> is { { {...} {...} } { {...} {...} } }, so we simply express the entity as <strong>{ }</strong>, and let&#39;s call it <code>Empty Pair</code>.</p>\n\n<hr>\n<h3>\n        <span id=\"3-8\" class=\"fragment\"></span>\n        <a href=\"#3-8\"><i class=\"fa fa-link\"></i></a>Push Pair\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/006.svg\" alt=\"\"></p>\n<p>A <code>Pair</code> can point another <code>Pair</code> so that we can joint <code>Pair</code>s.</p>\n<p>Now let a <code>pair</code> point another <code>Pair</code> and <code>5</code> by each hands.<br>\nLet&#39;s call this special action <code>Push</code>.</p>\n<p>In this case, we <code>push</code> 5 to an <code>Empty Pair</code>.</p>\n<p>The <code>Pair notation</code> is <strong>{ {} 5 }</strong>.</p>\n\n<hr>\n<h3>\n        <span id=\"3-9\" class=\"fragment\"></span>\n        <a href=\"#3-9\"><i class=\"fa fa-link\"></i></a>Push another Pair\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/007.svg\" alt=\"\"></p>\n<p>In the same manner, we can <code>push</code> another <code>Pair</code>.</p>\n<p>We <code>push</code> <code>2</code> to the previous sequence.</p>\n<p>The <code>Pair notation</code> is <strong>{ { {} 5 } 2 }</strong>.</p>\n\n<hr>\n<h3>\n        <span id=\"3-10\" class=\"fragment\"></span>\n        <a href=\"#3-10\"><i class=\"fa fa-link\"></i></a>Push to any sequence\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/008.svg\" alt=\"\"></p>\n\n<hr>\n<h3>\n        <span id=\"3-11\" class=\"fragment\"></span>\n        <a href=\"#3-11\"><i class=\"fa fa-link\"></i></a>Sequence\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/009.svg\" alt=\"\"></p>\n<p>Here, <em>SpaceTime</em> explicitly defines a term <code>Sequence</code> for this form.<br>\nPlease note this is the same term and meaning of <a href=\"http://en.wikipedia.org/wiki/Sequence\" title=\"\" target=\"_blank\">Sequence</a> in Mathematics.</p>\n<p>At the same time, instead of <code>Pair notation</code> : { { { {} 5 } 2 } 7 }, it can be simply expressed as <strong>( 5 2 7 )</strong>.</p>\n\n<hr>\n<h3>\n        <span id=\"3-12\" class=\"fragment\"></span>\n        <a href=\"#3-12\"><i class=\"fa fa-link\"></i></a>Push function\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/010.svg\" alt=\"\"></p>\n<p>A <code>Pair</code> can point <code>function</code>.</p>\n<p>Accordingly, we can <code>push</code> <code>function</code> to any <code>Sequence</code>.</p>\n<p>In this case, we <code>push</code> a <code>function</code> to <strong>(5)</strong>.</p>\n\n<hr>\n<h3>\n        <span id=\"3-13\" class=\"fragment\"></span>\n        <a href=\"#3-13\"><i class=\"fa fa-link\"></i></a>A case of Push function\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/011.svg\" alt=\"\"></p>\n<p>When we push a <code>function</code> : <code>plus2</code> to <strong>(5)</strong>, the result is <strong>(7)</strong>.</p>\n\n<hr>\n<h3>\n        <span id=\"3-14\" class=\"fragment\"></span>\n        <a href=\"#3-14\"><i class=\"fa fa-link\"></i></a>Function is Sequence\n      </h3><p>The <code>function</code> : <code>plus2</code> is fundamentally some <code>Sequence</code>.</p>\n<p><code>plus2</code> consists of a <code>Sequence</code> : <strong>( plus (2) )</strong>.</p>\n<p><strong>(2)</strong> is an <code>attribute Sequence</code> of the <code>function</code>.</p>\n<p><strong>( 5 (plus (2)) )</strong> is equivalent to <strong>(7)</strong>.</p>\n\n<hr>\n<h3>\n        <span id=\"3-15\" class=\"fragment\"></span>\n        <a href=\"#3-15\"><i class=\"fa fa-link\"></i></a>Everything is a function and Sequence\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/012.svg\" alt=\"\"></p>\n<p>Everything is <code>function</code> in <em>SpaceTime</em>.</p>\n<p>In this case, <code>3</code> is a <code>function</code> that maps a source : <strong>( 5 )</strong> to a target : <strong>( 5 3 )</strong>.</p>\n<p>Consequently, since <code>function</code> is <code>Sequence</code> in <em>SpaceTime</em>, everything is <code>Sequence</code> in <em>SpaceTime</em>.</p>\n<p>Therefore, <code>3</code> is a <code>function</code> and at the same time, is a <code>Sequence</code>.</p>\n<p>However, <code>3</code> is <code>3</code>. There is no other way to express than just <code>3</code> in <em>SpaceTime</em>.</p>\n\n<hr>\n<h3>\n        <span id=\"3-16\" class=\"fragment\"></span>\n        <a href=\"#3-16\"><i class=\"fa fa-link\"></i></a>Every Sequence is a result of function to <code>Empty Pair</code>\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/013.svg\" alt=\"\"></p>\n\n<hr>\n<h3>\n        <span id=\"3-17\" class=\"fragment\"></span>\n        <a href=\"#3-17\"><i class=\"fa fa-link\"></i></a>Function composition\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/014.svg\" alt=\"\"></p>\n<p><a href=\"http://en.wikipedia.org/wiki/Function_composition\" title=\"\" target=\"_blank\">Function composition</a> is naturally expressed in a form :<br>\n<strong>( *source function fucnction )</strong> in <em>SpaceTime</em>.</p>\n<p>Please note the <code>source</code> = <strong>( 1 )</strong> as a <code>Sequence</code>, not 1.</p>\n\n<hr>\n<h3>\n        <span id=\"3-18\" class=\"fragment\"></span>\n        <a href=\"#3-18\"><i class=\"fa fa-link\"></i></a>1 +2 +3 = 6\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/015.svg\" alt=\"\"></p>\n<p><em>SpaceTime</em> has a short-cut notation : <strong>+</strong> corresponding to <code>plus</code> function.</p>\n\n<hr>\n<h3>\n        <span id=\"3-19\" class=\"fragment\"></span>\n        <a href=\"#3-19\"><i class=\"fa fa-link\"></i></a>1 +(2 +3) = 6\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/016.svg\" alt=\"\"></p>\n<p>( 1 (+ ( 2 (+ ( 3 ) ) ) ) )  =  ( 6 )</p>\n\n<hr>\n<h3>\n        <span id=\"3-20\" class=\"fragment\"></span>\n        <a href=\"#3-20\"><i class=\"fa fa-link\"></i></a>Indefinite sequence\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/017.svg\" alt=\"\"></p>\n<p><em>SpaceTime</em> employes an <a href=\"http://en.wikipedia.org/wiki/Evaluation_strategy\" title=\"\" target=\"_blank\">evaluation strategy</a> : <a href=\"http://en.wikipedia.org/wiki/Lazy_evaluation\" title=\"\" target=\"_blank\">lazy evaluation, or call-by-need</a>.</p>\n<p>Accordingly, <em>SpaceTime</em> can deal with Indefinite sequence such as <a href=\"http://en.wikipedia.org/wiki/Natural_number\" title=\"\" target=\"_blank\">Natural number</a>.</p>\n\n<hr>\n<h3>\n        <span id=\"3-21\" class=\"fragment\"></span>\n        <a href=\"#3-21\"><i class=\"fa fa-link\"></i></a>I/O (Input and Output)\n      </h3><p><img src=\"http://spacetimeprogramminglanguage.github.io/contents/img/018.svg\" alt=\"\"></p>\n<p><a href=\"http://en.wikipedia.org/wiki/Input/output\" title=\"\" target=\"_blank\">I/O</a> does not affect the evaluation context of <em>SpaceTime</em> directly, so that it can preserve <a href=\"http://en.wikipedia.org/wiki/Functional_programming\" title=\"\" target=\"_blank\">Functional programming</a> paradigm.</p>\n<p><em>SpaceTime</em> employes <a href=\"http://en.wikipedia.org/wiki/Functional_reactive_programming\" title=\"\" target=\"_blank\">FRP</a> or <code>SpaceTime Programming paradigm</code>.</p>\n\n<hr>\n<h2>\n        <span id=\"2-3\" class=\"fragment\"></span>\n        <a href=\"#2-3\"><i class=\"fa fa-link\"></i></a>Basic\n      </h2>\n<hr>\n<h3>\n        <span id=\"3-22\" class=\"fragment\"></span>\n        <a href=\"#3-22\"><i class=\"fa fa-link\"></i></a>Hello world\n      </h3><p><code>Code</code><br>\n<code><br>\n(<br>\n  &quot;hello World&quot;<br>\n  (map (CONSOLE))<br>\n)<br>\n</code><br>\n<code>Evaluation</code><br>\n<code><br>\n(&quot;hello World&quot;)<br>\n</code><br>\n<code>Console</code><br>\n```<br>\nhello World</p>\n<h2>\n        <span id=\"2-4\" class=\"fragment\"></span>\n        <a href=\"#2-4\"><i class=\"fa fa-link\"></i></a>```\n      </h2><h3>\n        <span id=\"3-23\" class=\"fragment\"></span>\n        <a href=\"#3-23\"><i class=\"fa fa-link\"></i></a>Hello world twice\n      </h3><p><code>Code</code><br>\n<code><br>\n(<br>\n  &quot;hello World&quot;<br>\n  (map (CONSOLE))<br>\n  (map (CONSOLE))<br>\n)<br>\n</code><br>\n<code>Evaluation</code><br>\n<code><br>\n(&quot;hello World&quot;)<br>\n</code><br>\n<code>Console</code><br>\n<code><br>\nhello World<br>\nhello World<br>\n</code></p>\n\n<hr>\n<h3>\n        <span id=\"3-24\" class=\"fragment\"></span>\n        <a href=\"#3-24\"><i class=\"fa fa-link\"></i></a>Boolean\n      </h3><p><code>Code</code><br>\n<code><br>\n(3 (== (3)) )<br>\n</code><br>\n<code>Evaluation</code><br>\n<code><br>\n(true)<br>\n</code></p>\n<p><code>Code</code><br>\n<code><br>\n(3 (== (5)) )<br>\n</code><br>\n<code>Evaluation</code><br>\n<code><br>\n(false)<br>\n</code></p>\n<p><code>Code</code><br>\n<code><br>\n(2 (&gt; (1)) )<br>\n</code><br>\n<code>Evaluation</code><br>\n<code><br>\n(true)<br>\n</code></p>\n<p><code>Code</code><br>\n<code><br>\n(2 (&lt; (1)) )<br>\n</code><br>\n<code>Evaluation</code><br>\n<code><br>\n(false)<br>\n</code></p>\n\n<hr>\n<h3>\n        <span id=\"3-25\" class=\"fragment\"></span>\n        <a href=\"#3-25\"><i class=\"fa fa-link\"></i></a>Conditional\n      </h3><p><code>Code</code><br>\n<code><br>\n(<br>\n　　3 (==(3))　<br>\n   (<br>\n     if (<br>\n           (&quot;match&quot;)<br>\n           (&quot;mismatch&quot;)<br>\n        )<br>\n   )<br>\n)<br>\n</code><br>\n<code>Evaluation</code><br>\n<code><br>\n(&quot;match&quot;)<br>\n</code></p>\n<p><code>Code</code><br>\n<code><br>\n(<br>\n　　3 (==(5))　<br>\n   (<br>\n     if (<br>\n           (&quot;match&quot;)<br>\n           (&quot;mismatch&quot;)<br>\n        )<br>\n   )<br>\n)<br>\n</code><br>\n<code>Evaluation</code><br>\n<code><br>\n(&quot;mismatch&quot;)<br>\n</code></p>\n<p><code>Code</code><br>\n```<br>\n(<br>\n　　3 (==(5))　<br>\n   (<br>\n     if (<br>\n           (&quot;case1&quot;)<br>\n           (<br>\n           　　3 (==(3))　<br>\n              (<br>\n                if (<br>\n                      (&quot;case2&quot;)<br>\n                      (<br>\n                      　　3 (==(3))　<br>\n                         (<br>\n                           if (<br>\n                                 (&quot;case3&quot;)<br>\n                                 (&quot;mismatch&quot;)<br>\n                              )<br>\n                         )<br>\n                      )<br>\n                   )<br>\n              )<br>\n           )<br>\n        )<br>\n   )<br>\n)</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>`Evaluation`\n</pre></div></div><p>(&quot;case2&quot;)<br>\n```</p>\n<p><code>Code</code><br>\n```<br>\n(<br>\n　　3 (==(5))　<br>\n   (<br>\n     if (<br>\n           (&quot;case1&quot;)<br>\n           (<br>\n           　　3 (==(1))　<br>\n              (<br>\n                if (<br>\n                      (&quot;case2&quot;)<br>\n                      (<br>\n                      　　3 (==(3))　<br>\n                         (<br>\n                           if (<br>\n                                 (&quot;case3&quot;)<br>\n                                 (&quot;mismatch&quot;)<br>\n                              )<br>\n                         )<br>\n                      )<br>\n                   )<br>\n              )<br>\n           )<br>\n        )<br>\n   )<br>\n)</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>`Evaluation`\n</pre></div></div><p>(&quot;case3&quot;)<br>\n```</p>\n\n<hr>\n<h4>\n        <span id=\"4-15\" class=\"fragment\"></span>\n        <a href=\"#4-15\"><i class=\"fa fa-link\"></i></a>KenOKABE tech blog\n      </h4><h4>\n        <span id=\"4-16\" class=\"fragment\"></span>\n        <a href=\"#4-16\"><i class=\"fa fa-link\"></i></a><a href=\"http://kenokabe.github.io/contents/entries/entry0/entry.html\" title=\"\">←ブログコンテンツ</a>\n      </h4>",
        "stock_users": [
            "satoshi-kubota",
            "HirofumiYashima",
            "ykominami",
            "LightSpeedC",
            "mikio_kun",
            "te20",
            "slowrider924",
            "mkamotsu",
            "houseim",
            "naoya",
            "riocampos",
            "hkoba@github",
            "kuwa72",
            "00AmeliaMary00",
            "kasumani",
            "kohyama",
            "tazakih",
            "aRyoKajiwara",
            "magicant",
            "kou_tana77",
            "akmiyoshi"
        ]
    },
    {
        "id": 79992,
        "uuid": "bfd17b901f5fd2df656c",
        "user": {
            "id": 46637,
            "url_name": "aki426",
            "profile_image_url": "https://pbs.twimg.com/profile_images/427469601811619840/kQSq4Cue_normal.jpeg"
        },
        "title": "EclipseでLispプラグインを使って幸せになる方法",
        "created_at": "2014-06-16 10:38:07 +0900",
        "updated_at": "2014-06-16 17:41:40 +0900",
        "created_at_in_words": "3ヶ月",
        "updated_at_in_words": "3ヶ月",
        "tags": [
            {
                "name": "Eclipse",
                "url_name": "eclipse",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/ccf32cbcb30733164a0ea2331e24dacf1c2a3cf1/medium.jpg?1398264070",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "Eclipseプラグイン",
                "url_name": "eclipse%e3%83%97%e3%83%a9%e3%82%b0%e3%82%a4%e3%83%b3",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            },
            {
                "name": "dandelion",
                "url_name": "dandelion",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            }
        ],
        "stock_count": 5,
        "comment_count": 1,
        "url": "http://qiita.com/aki426/items/bfd17b901f5fd2df656c",
        "created_at_as_seconds": 1402882687,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "結論を先に書くと「dandelion」というプラグインがあるからそれを使おう、だ。以下簡単に解説。\n\n#経緯\n\n通常Lisp/Schemeでコーディングしようと思ったら、Emacsを使うことになる。理由はいくつかあるが、EmacsはLispと相性が良いからだ。ただ、Emacsのキーバインディングにいつまで経っても慣れない私のような人もいる。\nそんな私（とあなた）のために、Eclipse上で動くLisp用プラグイン「dandelion」がある。\n\nしかしこのdandelion、日本語の情報が全く無いばかりか、英語の情報すらロクロク見当たらない。おまけにEclipseのLispプラグインでググると、「cusp」というプラグインばかりがヒットする（こちらはメンテされておらず、最新のEclipseではまともに動かなくなってしまっているので、余計始末が悪い）。\nせっかくこんな素晴らしいものがあるのだから、いろんな人に知ってもらいたい、そしてあわよくばLisperが増えればいい、と思ってQiitaアカウントまで取ってしまったのだった。\n\nさて経緯はこれくらいにして本題。\n\n#ターゲット環境\n\n- Windows7 64bit or Windows8.1\n- Eclipse 4.3 Kepler or Pleiades All in One 64bit（バージョンは同じ4.3 Kepler）\n- dandelion (http://sourceforge.net/projects/dandelion-ecl/)\n- Cygwin 32bit\n- CLISP 2.48(Cygwin向けパッケージ)\n\n基本的に私の手元にはWin7とWin8.1しか無いので上記のようなセットになった。LinuxやUNIX、Macの場合はCygwin無しでCLISPのパッケージをインストールすれば良いはずだ。また、Eclipseも64bitどころかPleiadesでも普通に動いているので、Eclipseが原因で詰まることは無いだろう。\n\n#やること\n\n0. Cygwinをインストールする。このあたりはCygwinの指南サイトをググってほしい。ちなみに32bit版でないと、CLISPがインストールできないので注意。\n0. Cygwin-setupからCLISPをインストールする。Interpreterカテゴリの中にある。（clisp: An ANSI Common Lisp implementation だけのインストールでも動く）\n0. Eclipseをインストールする。ちなみに[Pleiades](http://mergedoc.sourceforge.jp/)の64bit版で使っているがなんら問題ない。\n0. dandelionプラグインをインストールする。Eclipseのプラグインインストール機能を使って、http://dandelion-ecl.sourceforge.net/update/ からWindowsのCLISP版を入れれば良い。SBCL版もあるみたいだが、こちらはバージョン表記が古く、アップデートされていない模様。\n\nそうするとあら不思議、下記の画像のような画面とご対面できる。\n\n![dandelion.jpg](https://qiita-image-store.s3.amazonaws.com/0/46637/e2c5017b-e7c4-0269-0719-2cfff63bc373.jpeg)\n\n\n#できること\n\n- 入力補完※（Ctrl+Space）\n- 関数の評価（Ctrl+E,Ctrl+Shift+E,F8）\n- マクロ展開\n- インデント整形（範囲選択後Ctrl+I。ネスティングに対応したインデント）\n- REPL窓の利用\n- 処理系の変更（設定から変更できるようだが、まだ試していない。Gaucheなんかもdandelionで使えるかも？）\n\n※なお、入力補完機能は起動した直後は動作しない。一度何らかの評価をしてやるとREPLが起動し、入力補完が効くようになるので注意が必要だ。\n\n#できないこと\n\n- シンタクスハイライトの変更\n- コーディングスタイルを指定したコード整形\n- リファクタリング機能\n\nなお、dandelionはSourceforgeでコードが公開されているので、我こそはと思う人がいたら拡張してほしい。\n（シンタクスハイライトの色が変更できないので黒背景にできないのよね……）\n\nおわり。\n",
        "body": "<p>結論を先に書くと「dandelion」というプラグインがあるからそれを使おう、だ。以下簡単に解説。</p>\n<h1>\n        <span id=\"1-1\" class=\"fragment\"></span>\n        <a href=\"#1-1\"><i class=\"fa fa-link\"></i></a>経緯\n      </h1><p>通常Lisp/Schemeでコーディングしようと思ったら、Emacsを使うことになる。理由はいくつかあるが、EmacsはLispと相性が良いからだ。ただ、Emacsのキーバインディングにいつまで経っても慣れない私のような人もいる。<br>\nそんな私（とあなた）のために、Eclipse上で動くLisp用プラグイン「dandelion」がある。</p>\n<p>しかしこのdandelion、日本語の情報が全く無いばかりか、英語の情報すらロクロク見当たらない。おまけにEclipseのLispプラグインでググると、「cusp」というプラグインばかりがヒットする（こちらはメンテされておらず、最新のEclipseではまともに動かなくなってしまっているので、余計始末が悪い）。<br>\nせっかくこんな素晴らしいものがあるのだから、いろんな人に知ってもらいたい、そしてあわよくばLisperが増えればいい、と思ってQiitaアカウントまで取ってしまったのだった。</p>\n<p>さて経緯はこれくらいにして本題。</p>\n<h1>\n        <span id=\"1-2\" class=\"fragment\"></span>\n        <a href=\"#1-2\"><i class=\"fa fa-link\"></i></a>ターゲット環境\n      </h1>\n<ul>\n<li>Windows7 64bit or Windows8.1</li>\n<li>Eclipse 4.3 Kepler or Pleiades All in One 64bit（バージョンは同じ4.3 Kepler）</li>\n<li>dandelion (<a href=\"http://sourceforge.net/projects/dandelion-ecl/\" title=\"http://sourceforge.net/projects/dandelion-ecl/\" target=\"_blank\">http://sourceforge.net/projects/dandelion-ecl/</a>)</li>\n<li>Cygwin 32bit</li>\n<li>CLISP 2.48(Cygwin向けパッケージ)</li>\n</ul>\n<p>基本的に私の手元にはWin7とWin8.1しか無いので上記のようなセットになった。LinuxやUNIX、Macの場合はCygwin無しでCLISPのパッケージをインストールすれば良いはずだ。また、Eclipseも64bitどころかPleiadesでも普通に動いているので、Eclipseが原因で詰まることは無いだろう。</p>\n<h1>\n        <span id=\"1-3\" class=\"fragment\"></span>\n        <a href=\"#1-3\"><i class=\"fa fa-link\"></i></a>やること\n      </h1>\n<ol>\n<li>Cygwinをインストールする。このあたりはCygwinの指南サイトをググってほしい。ちなみに32bit版でないと、CLISPがインストールできないので注意。</li>\n<li>Cygwin-setupからCLISPをインストールする。Interpreterカテゴリの中にある。（clisp: An ANSI Common Lisp implementation だけのインストールでも動く）</li>\n<li>Eclipseをインストールする。ちなみに<a href=\"http://mergedoc.sourceforge.jp/\" title=\"\" target=\"_blank\">Pleiades</a>の64bit版で使っているがなんら問題ない。</li>\n<li>dandelionプラグインをインストールする。Eclipseのプラグインインストール機能を使って、<a href=\"http://dandelion-ecl.sourceforge.net/update/\" title=\"http://dandelion-ecl.sourceforge.net/update/\" target=\"_blank\">http://dandelion-ecl.sourceforge.net/update/</a> からWindowsのCLISP版を入れれば良い。SBCL版もあるみたいだが、こちらはバージョン表記が古く、アップデートされていない模様。</li>\n</ol>\n<p>そうするとあら不思議、下記の画像のような画面とご対面できる。</p>\n<p><img src=\"https://qiita-image-store.s3.amazonaws.com/0/46637/e2c5017b-e7c4-0269-0719-2cfff63bc373.jpeg\" alt=\"dandelion.jpg\"></p>\n<h1>\n        <span id=\"1-4\" class=\"fragment\"></span>\n        <a href=\"#1-4\"><i class=\"fa fa-link\"></i></a>できること\n      </h1>\n<ul>\n<li>入力補完※（Ctrl+Space）</li>\n<li>関数の評価（Ctrl+E,Ctrl+Shift+E,F8）</li>\n<li>マクロ展開</li>\n<li>インデント整形（範囲選択後Ctrl+I。ネスティングに対応したインデント）</li>\n<li>REPL窓の利用</li>\n<li>処理系の変更（設定から変更できるようだが、まだ試していない。Gaucheなんかもdandelionで使えるかも？）</li>\n</ul>\n<p>※なお、入力補完機能は起動した直後は動作しない。一度何らかの評価をしてやるとREPLが起動し、入力補完が効くようになるので注意が必要だ。</p>\n<h1>\n        <span id=\"1-5\" class=\"fragment\"></span>\n        <a href=\"#1-5\"><i class=\"fa fa-link\"></i></a>できないこと\n      </h1>\n<ul>\n<li>シンタクスハイライトの変更</li>\n<li>コーディングスタイルを指定したコード整形</li>\n<li>リファクタリング機能</li>\n</ul>\n<p>なお、dandelionはSourceforgeでコードが公開されているので、我こそはと思う人がいたら拡張してほしい。<br>\n（シンタクスハイライトの色が変更できないので黒背景にできないのよね……）</p>\n<p>おわり。</p>\n",
        "stock_users": [
            "elbowroomer",
            "Noboruhi",
            "kasumani",
            "Reds",
            "akmiyoshi"
        ]
    },
    {
        "id": 72401,
        "uuid": "ff4df934a5a89aaafbcb",
        "user": {
            "id": 32879,
            "url_name": "akmiyoshi",
            "profile_image_url": "https://avatars.githubusercontent.com/u/24079?"
        },
        "title": "「プログラムでシダを描画する」をEmacs Lispで描画する",
        "created_at": "2014-05-28 02:37:56 +0900",
        "updated_at": "2014-06-24 14:32:03 +0900",
        "created_at_in_words": "4ヶ月",
        "updated_at_in_words": "3ヶ月",
        "tags": [
            {
                "name": "Emacs",
                "url_name": "emacs",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/2920f41f5aefd36267c6c04183d7e6197b4d2b99/medium.jpg?1364837723",
                "versions": [
                    "24.3.1"
                ]
            },
            {
                "name": "emacs-lisp",
                "url_name": "emacs-lisp",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "オブジェクト指向",
                "url_name": "%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e6%8c%87%e5%90%91",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            },
            {
                "name": "プログラミング",
                "url_name": "%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%9f%e3%83%b3%e3%82%b0",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            }
        ],
        "stock_count": 21,
        "comment_count": 0,
        "url": "http://qiita.com/akmiyoshi/items/ff4df934a5a89aaafbcb",
        "created_at_as_seconds": 1401212276,
        "tweet": false,
        "gist_url": null,
        "private": false,
        "raw_body": "* [プログラムでシダを描画する - 強火で進め](http://d.hatena.ne.jp/nakamura001/20140505/1399316565)\n* [「プログラムでシダを描画する」をDartで描画する - Qiita](http://qiita.com/zukkun/items/08b72c9934d3c0c09936)\n* [「プログラムでシダを描画する」をGoで描画する - Qiita](http://qiita.com/qt-luigi/items/ec6cd349259fe6cc29eb)\n* [Clojure - プログラムでシダを描画する - Qiita](http://qiita.com/woxtu/items/30aebcf15770c438d6fd)\n* [「プログラムでシダを描画する」をPythonで描画する - Qiita](http://qiita.com/noc06140728/items/8b8f06cfc312b8492df4)\n* [「プログラムでシダを描画する」をJavaScript+Canvasで描画する - Qiita](http://qiita.com/alucky0707/items/ada6514d6068fdff2a8c)\n* [「プログラムでシダを描画する」をPHPで描画する - Qiita](http://qiita.com/mpyw/items/dc339f12705f8b97ef67)\n\n「プログラムでシダを描画する」記事たちに触発されて、Emacs Lispで書いてみました。\nsida.el をロードして、M-x sida で描画されます。\n(バグとかご意見ありましたら https://twitter.com/akmiyoshi までお願いします)\n\n![2014-0528-0222.png](https://qiita-image-store.s3.amazonaws.com/0/32879/f03b68df-dbd0-2557-edd9-a1512b1491e3.png)\n\n```el:sida.el\n(require 'cl)\n(require 'eieio)\n\n(defconst *sida-inverted-xbm-image*\n  (or (eq system-type 'windows-nt)\n      (and (eq system-type 'cygwin) (string= (getenv \"DISPLAY\") \"w32\"))))\n(defconst *sida-foreground-color* \"green\")\n(defconst *sida-background-color* \"white\")\n\n(defun W1x ($x $y) (+ (* 0.836 $x) (* 0.044 $y)))\n(defun W1y ($x $y) (+ (* -0.044 $x) (* 0.836 $y) 0.169))\n(defun W2x ($x $y) (+ (* -0.141 $x) (* 0.302 $y)))\n(defun W2y ($x $y) (+ (* 0.302 $x) (* 0.141 $y) 0.127))\n(defun W3x ($x $y) (- (* 0.141 $x) (* 0.302 $y)))\n(defun W3y ($x $y) (+ (* 0.302 $x) (* 0.141 $y) 0.169))\n(defun W4x ($x $y) 0)\n(defun W4y ($x $y) (* 0.175337 $y))\n\n(defclass <sida> ()\n  ((width :initarg :width)\n   (height :initarg :height)\n   (bitmap :initarg :bitmap)\n   (image :initarg :image)))\n\n(defmethod initialize-instance :after ((this <sida>) &rest $slots)\n  (assert (slot-boundp this 'width))\n  (assert (slot-boundp this 'height))\n  (with-slots (width height bitmap image) this\n    (assert (zerop (% width 8)))\n    (setf bitmap (make-bool-vector (* width height) nil))\n    (setf image\n          (apply\n           #'create-image\n           bitmap 'xbm t\n           :width width\n           :height height\n           :relief 2\n           :pointer 'arrow\n           (if *sida-inverted-xbm-image*\n               (list :foreground *sida-background-color*\n                     :background *sida-foreground-color*)\n             (list :foreground *sida-foreground-color*\n                   :background *sida-background-color*))))))\n\n(defmethod !f ((this <sida>) $k $x $y)\n  (with-slots (width height) this\n    (if (> $k 0)\n        (loop for $i from 1 to 4 do\n              (when (or (= $i 1) (< (random 10) 3))\n                (!f this\n                    (1- $k)\n                    (funcall (intern (format \"W%dx\" $i)) $x $y)\n                    (funcall (intern (format \"W%dy\" $i)) $x $y))))\n      (!plot this\n             (+ (* $x 490) (* width 0.5))\n             (- height (* $y 490))))))\n\n(defmethod !plot ((this <sida>) $x $y)\n  (with-slots (width height bitmap) this\n    (let (($x (truncate $x))\n          ($y (truncate $y)))\n      (cond\n       ((< $x 0) nil)\n       ((>= $x width) nil)\n       ((< $y 0) nil)\n       ((>= $y height) nil)\n       (t (let (($index (+ (* width $y) $x)))\n            (when (and (>= $index 0) (< $index (length bitmap)))\n              (aset bitmap $index t))))))))\n\n(defun sida ()\n  (interactive)\n  (let (($sida (make-instance <sida> :width 520 :height 500)))\n    (with-slots (image) $sida\n      (switch-to-buffer \"<sida>\")\n      (remove-images (point-min) (point-max))\n      (put-image image (point-min))\n      (!f $sida 20 0 0))))\n```\n",
        "body": "<ul>\n<li><a href=\"http://d.hatena.ne.jp/nakamura001/20140505/1399316565\" title=\"\" target=\"_blank\">プログラムでシダを描画する - 強火で進め</a></li>\n<li><a href=\"http://qiita.com/zukkun/items/08b72c9934d3c0c09936\" title=\"\">「プログラムでシダを描画する」をDartで描画する - Qiita</a></li>\n<li><a href=\"http://qiita.com/qt-luigi/items/ec6cd349259fe6cc29eb\" title=\"\">「プログラムでシダを描画する」をGoで描画する - Qiita</a></li>\n<li><a href=\"http://qiita.com/woxtu/items/30aebcf15770c438d6fd\" title=\"\">Clojure - プログラムでシダを描画する - Qiita</a></li>\n<li><a href=\"http://qiita.com/noc06140728/items/8b8f06cfc312b8492df4\" title=\"\">「プログラムでシダを描画する」をPythonで描画する - Qiita</a></li>\n<li><a href=\"http://qiita.com/alucky0707/items/ada6514d6068fdff2a8c\" title=\"\">「プログラムでシダを描画する」をJavaScript+Canvasで描画する - Qiita</a></li>\n<li><a href=\"http://qiita.com/mpyw/items/dc339f12705f8b97ef67\" title=\"\">「プログラムでシダを描画する」をPHPで描画する - Qiita</a></li>\n</ul>\n<p>「プログラムでシダを描画する」記事たちに触発されて、Emacs Lispで書いてみました。<br>\nsida.el をロードして、M-x sida で描画されます。<br>\n(バグとかご意見ありましたら <a href=\"https://twitter.com/akmiyoshi\" title=\"https://twitter.com/akmiyoshi\" target=\"_blank\">https://twitter.com/akmiyoshi</a> までお願いします)</p>\n<p><img src=\"https://qiita-image-store.s3.amazonaws.com/0/32879/f03b68df-dbd0-2557-edd9-a1512b1491e3.png\" alt=\"2014-0528-0222.png\"></p>\n<div class=\"code-frame\" data-lang=\"el\"><div class=\"code-lang\"><span class=\"bold\">sida.el</span></div><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">require</span> <span class=\"ss\">&#39;cl</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">require</span> <span class=\"ss\">&#39;eieio</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"nv\">defconst</span> <span class=\"vg\">*sida-inverted-xbm-image*</span>\n  <span class=\"p\">(</span><span class=\"nb\">or</span> <span class=\"p\">(</span><span class=\"nb\">eq</span> <span class=\"nv\">system-type</span> <span class=\"ss\">&#39;windows-nt</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nb\">and</span> <span class=\"p\">(</span><span class=\"nb\">eq</span> <span class=\"nv\">system-type</span> <span class=\"ss\">&#39;cygwin</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">string=</span> <span class=\"p\">(</span><span class=\"nv\">getenv</span> <span class=\"s\">&quot;DISPLAY&quot;</span><span class=\"p\">)</span> <span class=\"s\">&quot;w32&quot;</span><span class=\"p\">))))</span>\n<span class=\"p\">(</span><span class=\"nv\">defconst</span> <span class=\"vg\">*sida-foreground-color*</span> <span class=\"s\">&quot;green&quot;</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nv\">defconst</span> <span class=\"vg\">*sida-background-color*</span> <span class=\"s\">&quot;white&quot;</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">W1x</span> <span class=\"p\">(</span><span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">0.836</span> <span class=\"nv\">$x</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">0.044</span> <span class=\"nv\">$y</span><span class=\"p\">)))</span>\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">W1y</span> <span class=\"p\">(</span><span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">-0.044</span> <span class=\"nv\">$x</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">0.836</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"mf\">0.169</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">W2x</span> <span class=\"p\">(</span><span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">-0.141</span> <span class=\"nv\">$x</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">0.302</span> <span class=\"nv\">$y</span><span class=\"p\">)))</span>\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">W2y</span> <span class=\"p\">(</span><span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">0.302</span> <span class=\"nv\">$x</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">0.141</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"mf\">0.127</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">W3x</span> <span class=\"p\">(</span><span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">-</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">0.141</span> <span class=\"nv\">$x</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">0.302</span> <span class=\"nv\">$y</span><span class=\"p\">)))</span>\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">W3y</span> <span class=\"p\">(</span><span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">0.302</span> <span class=\"nv\">$x</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">0.141</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"mf\">0.169</span><span class=\"p\">))</span>\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">W4x</span> <span class=\"p\">(</span><span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">W4y</span> <span class=\"p\">(</span><span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mf\">0.175337</span> <span class=\"nv\">$y</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defclass</span> <span class=\"nv\">&lt;sida&gt;</span> <span class=\"p\">()</span>\n  <span class=\"p\">((</span><span class=\"nv\">width</span> <span class=\"ss\">:initarg</span> <span class=\"ss\">:width</span><span class=\"p\">)</span>\n   <span class=\"p\">(</span><span class=\"nv\">height</span> <span class=\"ss\">:initarg</span> <span class=\"ss\">:height</span><span class=\"p\">)</span>\n   <span class=\"p\">(</span><span class=\"nv\">bitmap</span> <span class=\"ss\">:initarg</span> <span class=\"ss\">:bitmap</span><span class=\"p\">)</span>\n   <span class=\"p\">(</span><span class=\"nv\">image</span> <span class=\"ss\">:initarg</span> <span class=\"ss\">:image</span><span class=\"p\">)))</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defmethod</span> <span class=\"nb\">initialize-instance</span> <span class=\"ss\">:after</span> <span class=\"p\">((</span><span class=\"nv\">this</span> <span class=\"nv\">&lt;sida&gt;</span><span class=\"p\">)</span> <span class=\"k\">&amp;rest</span> <span class=\"nv\">$slots</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nb\">assert</span> <span class=\"p\">(</span><span class=\"nb\">slot-boundp</span> <span class=\"nv\">this</span> <span class=\"ss\">&#39;width</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nb\">assert</span> <span class=\"p\">(</span><span class=\"nb\">slot-boundp</span> <span class=\"nv\">this</span> <span class=\"ss\">&#39;height</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nb\">with-slots</span> <span class=\"p\">(</span><span class=\"nv\">width</span> <span class=\"nv\">height</span> <span class=\"nv\">bitmap</span> <span class=\"nv\">image</span><span class=\"p\">)</span> <span class=\"nv\">this</span>\n    <span class=\"p\">(</span><span class=\"nb\">assert</span> <span class=\"p\">(</span><span class=\"nb\">zerop</span> <span class=\"p\">(</span><span class=\"nv\">%</span> <span class=\"nv\">width</span> <span class=\"mi\">8</span><span class=\"p\">)))</span>\n    <span class=\"p\">(</span><span class=\"nb\">setf</span> <span class=\"nv\">bitmap</span> <span class=\"p\">(</span><span class=\"nv\">make-bool-vector</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"nv\">width</span> <span class=\"nv\">height</span><span class=\"p\">)</span> <span class=\"no\">nil</span><span class=\"p\">))</span>\n    <span class=\"p\">(</span><span class=\"nb\">setf</span> <span class=\"nv\">image</span>\n          <span class=\"p\">(</span><span class=\"nb\">apply</span>\n           <span class=\"nf\">#&#39;</span><span class=\"nv\">create-image</span>\n           <span class=\"nv\">bitmap</span> <span class=\"ss\">&#39;xbm</span> <span class=\"no\">t</span>\n           <span class=\"ss\">:width</span> <span class=\"nv\">width</span>\n           <span class=\"ss\">:height</span> <span class=\"nv\">height</span>\n           <span class=\"ss\">:relief</span> <span class=\"mi\">2</span>\n           <span class=\"ss\">:pointer</span> <span class=\"ss\">&#39;arrow</span>\n           <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"vg\">*sida-inverted-xbm-image*</span>\n               <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"ss\">:foreground</span> <span class=\"vg\">*sida-background-color*</span>\n                     <span class=\"ss\">:background</span> <span class=\"vg\">*sida-foreground-color*</span><span class=\"p\">)</span>\n             <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"ss\">:foreground</span> <span class=\"vg\">*sida-foreground-color*</span>\n                   <span class=\"ss\">:background</span> <span class=\"vg\">*sida-background-color*</span><span class=\"p\">))))))</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defmethod</span> <span class=\"nv\">!f</span> <span class=\"p\">((</span><span class=\"nv\">this</span> <span class=\"nv\">&lt;sida&gt;</span><span class=\"p\">)</span> <span class=\"nv\">$k</span> <span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nb\">with-slots</span> <span class=\"p\">(</span><span class=\"nv\">width</span> <span class=\"nv\">height</span><span class=\"p\">)</span> <span class=\"nv\">this</span>\n    <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">&gt;</span> <span class=\"nv\">$k</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">loop</span> <span class=\"nv\">for</span> <span class=\"nv\">$i</span> <span class=\"nv\">from</span> <span class=\"mi\">1</span> <span class=\"nv\">to</span> <span class=\"mi\">4</span> <span class=\"nb\">do</span>\n              <span class=\"p\">(</span><span class=\"nb\">when</span> <span class=\"p\">(</span><span class=\"nb\">or</span> <span class=\"p\">(</span><span class=\"nb\">=</span> <span class=\"nv\">$i</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"p\">(</span><span class=\"nb\">random</span> <span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n                <span class=\"p\">(</span><span class=\"nv\">!f</span> <span class=\"nv\">this</span>\n                    <span class=\"p\">(</span><span class=\"nb\">1-</span> <span class=\"nv\">$k</span><span class=\"p\">)</span>\n                    <span class=\"p\">(</span><span class=\"nb\">funcall</span> <span class=\"p\">(</span><span class=\"nb\">intern</span> <span class=\"p\">(</span><span class=\"nb\">format</span> <span class=\"s\">&quot;W%dx&quot;</span> <span class=\"nv\">$i</span><span class=\"p\">))</span> <span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">)</span>\n                    <span class=\"p\">(</span><span class=\"nb\">funcall</span> <span class=\"p\">(</span><span class=\"nb\">intern</span> <span class=\"p\">(</span><span class=\"nb\">format</span> <span class=\"s\">&quot;W%dy&quot;</span> <span class=\"nv\">$i</span><span class=\"p\">))</span> <span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">))))</span>\n      <span class=\"p\">(</span><span class=\"nv\">!plot</span> <span class=\"nv\">this</span>\n             <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"nv\">$x</span> <span class=\"mi\">490</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"nv\">width</span> <span class=\"mf\">0.5</span><span class=\"p\">))</span>\n             <span class=\"p\">(</span><span class=\"nb\">-</span> <span class=\"nv\">height</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"nv\">$y</span> <span class=\"mi\">490</span><span class=\"p\">))))))</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defmethod</span> <span class=\"nv\">!plot</span> <span class=\"p\">((</span><span class=\"nv\">this</span> <span class=\"nv\">&lt;sida&gt;</span><span class=\"p\">)</span> <span class=\"nv\">$x</span> <span class=\"nv\">$y</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nb\">with-slots</span> <span class=\"p\">(</span><span class=\"nv\">width</span> <span class=\"nv\">height</span> <span class=\"nv\">bitmap</span><span class=\"p\">)</span> <span class=\"nv\">this</span>\n    <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">$x</span> <span class=\"p\">(</span><span class=\"nb\">truncate</span> <span class=\"nv\">$x</span><span class=\"p\">))</span>\n          <span class=\"p\">(</span><span class=\"nv\">$y</span> <span class=\"p\">(</span><span class=\"nb\">truncate</span> <span class=\"nv\">$y</span><span class=\"p\">)))</span>\n      <span class=\"p\">(</span><span class=\"nb\">cond</span>\n       <span class=\"p\">((</span><span class=\"nb\">&lt;</span> <span class=\"nv\">$x</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"no\">nil</span><span class=\"p\">)</span>\n       <span class=\"p\">((</span><span class=\"nb\">&gt;=</span> <span class=\"nv\">$x</span> <span class=\"nv\">width</span><span class=\"p\">)</span> <span class=\"no\">nil</span><span class=\"p\">)</span>\n       <span class=\"p\">((</span><span class=\"nb\">&lt;</span> <span class=\"nv\">$y</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"no\">nil</span><span class=\"p\">)</span>\n       <span class=\"p\">((</span><span class=\"nb\">&gt;=</span> <span class=\"nv\">$y</span> <span class=\"nv\">height</span><span class=\"p\">)</span> <span class=\"no\">nil</span><span class=\"p\">)</span>\n       <span class=\"p\">(</span><span class=\"no\">t</span> <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">$index</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"nv\">width</span> <span class=\"nv\">$y</span><span class=\"p\">)</span> <span class=\"nv\">$x</span><span class=\"p\">)))</span>\n            <span class=\"p\">(</span><span class=\"nb\">when</span> <span class=\"p\">(</span><span class=\"nb\">and</span> <span class=\"p\">(</span><span class=\"nb\">&gt;=</span> <span class=\"nv\">$index</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"nv\">$index</span> <span class=\"p\">(</span><span class=\"nb\">length</span> <span class=\"nv\">bitmap</span><span class=\"p\">)))</span>\n              <span class=\"p\">(</span><span class=\"nv\">aset</span> <span class=\"nv\">bitmap</span> <span class=\"nv\">$index</span> <span class=\"no\">t</span><span class=\"p\">))))))))</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">sida</span> <span class=\"p\">()</span>\n  <span class=\"p\">(</span><span class=\"nv\">interactive</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">$sida</span> <span class=\"p\">(</span><span class=\"nb\">make-instance</span> <span class=\"nv\">&lt;sida&gt;</span> <span class=\"ss\">:width</span> <span class=\"mi\">520</span> <span class=\"ss\">:height</span> <span class=\"mi\">500</span><span class=\"p\">)))</span>\n    <span class=\"p\">(</span><span class=\"nb\">with-slots</span> <span class=\"p\">(</span><span class=\"nv\">image</span><span class=\"p\">)</span> <span class=\"nv\">$sida</span>\n      <span class=\"p\">(</span><span class=\"nv\">switch-to-buffer</span> <span class=\"s\">&quot;&lt;sida&gt;&quot;</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">remove-images</span> <span class=\"p\">(</span><span class=\"nv\">point-min</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">point-max</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">put-image</span> <span class=\"nv\">image</span> <span class=\"p\">(</span><span class=\"nv\">point-min</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">!f</span> <span class=\"nv\">$sida</span> <span class=\"mi\">20</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span><span class=\"p\">))))</span>\n</pre></div></div>",
        "stock_users": [
            "circularuins",
            "fate_fox",
            "k_ui",
            "jabropt",
            "kencoba",
            "ayaniimi213",
            "mikio_kun",
            "ShingoFukuyama",
            "t-mochizuki",
            "akicho8",
            "tadsan",
            "mpyw",
            "Reds",
            "HirotoKagotani",
            "fujimisakari",
            "boohbah",
            "l3msh0@github",
            "Noboruhi",
            "pogin503",
            "mrkuc",
            "akmiyoshi"
        ]
    },
    {
        "id": 65292,
        "uuid": "613c67b07af2cc8fb916",
        "user": {
            "id": 6090,
            "url_name": "guicho271828",
            "profile_image_url": "https://pbs.twimg.com/profile_images/378800000809306716/dbd9008f86c426eb255aadb7fb0b9769_normal.jpeg"
        },
        "title": "Recursive-Macroexpansion",
        "created_at": "2014-05-03 18:32:28 +0900",
        "updated_at": "2014-05-03 18:42:54 +0900",
        "created_at_in_words": "5ヶ月",
        "updated_at_in_words": "5ヶ月",
        "tags": [
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "cl21",
                "url_name": "cl21",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            },
            {
                "name": "CommonLisp",
                "url_name": "commonlisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/7ec4b6d2f823c969579b87db605ceb000e516b63/medium.jpg?1364838934",
                "versions": []
            }
        ],
        "stock_count": 0,
        "comment_count": 0,
        "url": "http://qiita.com/guicho271828/items/613c67b07af2cc8fb916",
        "created_at_as_seconds": 1399109548,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "I made yet another macro-expansion system which allows for easier compile-time error handling.\n\nRecursive-Macroexpansion has the completely different expansion algorithm than those of Common Lisp’s macro expansion. CL is based on `macroexpand-1` and `macroexpand` while Recursive-Macroexpansion is based on `rmacroexpand` only. However, normal macros are transparent to `macroexpand`, so mixing normal macro and recursive macro is completely ok.\n\n**BIG NOTE** : This is my **FIRST** library written in controversial `CL21`. Thanks to **Fukamachi** !\n\nhttps://github.com/guicho271828/recursive-macroexpansion\n",
        "body": "<p>I made yet another macro-expansion system which allows for easier compile-time error handling.</p>\n<p>Recursive-Macroexpansion has the completely different expansion algorithm than those of Common Lisp’s macro expansion. CL is based on <code>macroexpand-1</code> and <code>macroexpand</code> while Recursive-Macroexpansion is based on <code>rmacroexpand</code> only. However, normal macros are transparent to <code>macroexpand</code>, so mixing normal macro and recursive macro is completely ok.</p>\n<p><strong>BIG NOTE</strong> : This is my <strong>FIRST</strong> library written in controversial <code>CL21</code>. Thanks to <strong>Fukamachi</strong> !</p>\n<p><a href=\"https://github.com/guicho271828/recursive-macroexpansion\" title=\"https://github.com/guicho271828/recursive-macroexpansion\" target=\"_blank\">https://github.com/guicho271828/recursive-macroexpansion</a></p>\n",
        "stock_users": []
    },
    {
        "id": 62557,
        "uuid": "83ad3519c11998fe0abc",
        "user": {
            "id": 16790,
            "url_name": "long_long_float",
            "profile_image_url": "https://pbs.twimg.com/profile_images/2660940168/6fcbbc88089789a8d8ec81b15b38ecda_normal.png"
        },
        "title": "((200行で)作る(Lisp)インタプリタ)",
        "created_at": "2014-04-23 18:46:43 +0900",
        "updated_at": "2014-04-23 18:46:43 +0900",
        "created_at_in_words": "5ヶ月",
        "updated_at_in_words": "5ヶ月",
        "tags": [
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "CoffeeScript",
                "url_name": "coffeescript",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/e41b881d25c683db2ce913dba0d07b9695a55741/medium.jpg?1368788624",
                "versions": [
                    "1.7.1"
                ]
            }
        ],
        "stock_count": 12,
        "comment_count": 2,
        "url": "http://qiita.com/long_long_float/items/83ad3519c11998fe0abc",
        "created_at_as_seconds": 1398246403,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "Lispの勉強がてらCoffeeScriptで作ってみました。\n\n仕様は http://ja.wikipedia.org/wiki/LISP や http://ja.wikipedia.org/wiki/純LISP を参考にググりながらやったので、違うところがあるかもしれません。\n\nソースは https://github.com/long-long-float/lisp-js/tree/limit200 で、 http://long-long-float.github.io/lisp-js/index.html で実際に動かすことができます。\n\n```coffeescript\nclass Symbol\n  constructor: (@name) ->\n  toString: -> @name\n\nclass Nil\n  toString: -> 'nil'\nnil = new Nil\nclass T\n  toString: -> 't'\nt = new T\n\nclass List\n  constructor: (@values) ->\n  toString: -> \"(#{@values.map((v) -> v.toString()).join(' ')})\"\n\nclass CallFun\n  constructor: (@funname, @args) ->\n  toString: -> \"(#{@funname} #{@values.map((v) -> v.toString()).join(' ')})\"\n\nSF_NAMES = ['cond', 'quote', 'lambda', 'defun']\nclass SpecialForm\n  constructor: (@name, @args) ->\n  toString: -> \"(#{@name} #{@args.map((v) -> v.toString()).join(' ')})\"\n\nclass Lambda\n  constructor: (@params, @body) ->\n\nclass Environment\n  constructor: (@variables) ->\n  get: (name) ->\n    val = @variables[name]\n    throw \"undefined #{name}\" unless val\n    return val\n  set: (name, val) -> @variables[name] = val\n\nisAtom = (val) ->\n  typeof val == 'string' or typeof val == 'number' or\n    val instanceof Nil or val instanceof T\n\nenvstack = []\ncurrentEnv = ->\n  throw \"envstack is empty\" unless envstack.length > 0\n  envstack[envstack.length - 1]\n\nclass @Parser\n  skip: ->\n    @pos++ while @code[@pos]?.match /[ \\r\\n\\t]/\n\n  isEOF: ->\n    @pos == @code.length\n\n  expects: (pattern, throwing = false) ->\n    valid = @code[@pos] && (pattern instanceof RegExp and pattern.test @code[@pos]) || pattern == @code[@pos...@pos + pattern.length]\n    if !valid && throwing\n      throw \"unexpected \\\"#{@code[@pos]}\\\", expects \\\"#{pattern}\\\"\"\n\n    return valid\n\n  forwards: (pattern) ->\n    @expects pattern, true\n    @code[@pos]\n    @pos += if pattern instanceof RegExp then 1 else pattern.length\n\n  forwards_if: (pattern) ->\n    @forwards pattern if @expects pattern\n\n  atom: ->\n    #number\n    if @expects /[0-9]/\n      num = ''\n      num += @code[@pos++] while @expects /[0-9]/\n      return parseInt(num)\n\n    #string\n    if @forwards_if '\"'\n      str = ''\n      str += @code[@pos++] until @expects '\"'\n      @forwards '\"'\n      return str\n\n    return nil if @forwards_if 'nil'\n    return t if @forwards_if 't'\n\n    #var\n    return new Symbol(@symbol())\n\n  symbol: ->\n    ret = ''\n    ret += @code[@pos++] while @expects /[\\w!#$%&=-~^|*+<>?_]/\n    return ret\n\n  list: ->\n    @forwards '('\n    values = []\n    until @expects(')') or @isEOF()\n      values.push @expr()\n      @skip()\n    @forwards ')'\n    return new List(values)\n\n  call_fun: ->\n    @forwards '('\n    args = []\n    funname = @expr()\n\n    isSF = SF_NAMES.indexOf(funname.name) != -1\n    until @expects(')') or @isEOF()\n      @skip()\n      args.push @expr(isSF)\n\n    @forwards ')'\n\n    klass = if isSF then SpecialForm else CallFun\n    return new klass(funname, args)\n\n  expr: (isSF) ->\n    if @expects(\"'\") or isSF #value\n      @forwards \"'\" unless isSF\n      if @expects '(' #list\n        return @list()\n      else #atom\n        return @atom()\n    else if @expects '(' #calling function or special form\n      return @call_fun()\n    else #atom\n      return @atom()\n\n  program: ->\n    ret = []\n    until @isEOF()\n      @skip()\n      ret.push @expr()\n    return ret\n\n  parse: (@code) ->\n    @pos = 0\n    @program()\n\nclass Evaluator\n  exec_lambda: (lambda, args) ->\n    envstack.push new Environment(lambda.params.values.reduce(\n      ((env, param, index) -> env[param.name] = args[index]; env), {}))\n    [name, args...] = lambda.body.values\n    ret = @eval_expr(new CallFun(name, args))\n    envstack.pop()\n    return ret\n\n  eval_expr: (expr) ->\n    switch expr.constructor.name\n      when 'SpecialForm'\n        args = expr.args\n        {\n          'cond': => args.filter((arg) => !(@eval_expr(arg.values[0]) instanceof Nil))[0]?.values[1] || nil\n          'quote': -> args[0]\n          'lambda': -> new Lambda(args[0], args[1])\n          'defun': -> currentEnv().set(args[0].name, new Lambda(args[1], args[2]))\n        }[expr.name.name]()\n\n      when 'CallFun'\n        args = expr.args.map (arg) => @eval_expr(arg)\n        funname = if expr.funname instanceof SpecialForm then @eval_expr(expr.funname) else expr.funname\n        switch funname.constructor.name\n          when 'Lambda'\n            @exec_lambda(funname)\n          when 'Symbol'\n            funcs = {\n              '+': -> args.reduce(((sum, n) -> sum + n), 0),\n              'car': -> args[0].values[0]\n              'cdr': -> new List args[0].values[1..]\n              'cons': -> new List [args[0], args[1].values...]\n              'eq': -> if args[0] == args[1] then t else nil\n              'atom': -> if isAtom(args[0]) then t else nil\n            }\n            if funs = funcs[funname.name]\n              funs()\n            else\n              if lambda = currentEnv().get(funname.name)\n                @exec_lambda(lambda, args)\n              else\n                throw \"undefined function : #{funname.name}\"\n          else\n            throw \"#{JSON.stringify(funname)}(#{funname.constructor.name}) is not a function\"\n      when 'Symbol'\n        currentEnv().get(expr.name)\n      else\n        expr\n\n  eval: (ast) ->\n    envstack.push new Environment({})\n    ast.map((expr) => @eval_expr(expr)).pop().toString()\n\nclass @Lisp\n  @eval: (code) ->\n    ast = (new Parser).parse(code)\n    {ast: ast, body: (new Evaluator).eval(ast)}\n\n#support script tag\n$ ->\n  $('script[type=\"text/lisp\"]').each ->\n    Lisp.eval $(this).text()\n```\n\n## 説明\n\n今回は勉強目的だったのでパーサーは手書きしました。再帰下降パーサーです。Parserクラスがこの役割を担っています。内部表現としてSymbol, Nil等のクラスを作りました。\n\n内部表現に変換したらEvaluatorクラスが評価します。再帰で普通にやっているだけです。\n\n## 短くするために\n\nきりのいい200行にするためにやったこと\n\nこの時点で、247行\n\n### 何度も登場する部分を関数として抽出する\n\n基本中の基本ですね。\n\n```coffeescript\nif @expects xxx\n  @forwards xxx\n  #...\n```\n\nが結構多かったので、`forwards_if`を作って、\n\n```coffeescript\nif @forwards_if xxx\n  #...\n```\n\nに書き換えました。ついでに、後置ifに置き換えました。\n\n```coffeescript\n#nil\nif @expects 'nil'\n  @forwards_str 'nil'\n  return nil\n```\n\nを\n\n```coffeescript\nreturn nil if @forwards_if 'nil'\n```\n\nにしました。\n\nこの時点で、221行\n\n### Switch文 -> functionを値としたオブジェクト\n\nswitch文は行数を食うという事が分かりました。具体的には、\n\n```coffeescript\nswitch x\n  when 'hoge'\n    console.log 'hoge~'\n  when 'piyo'\n    console.log 'piyo~'\n  when 'foo'\n    console.log 'foo~'\n```\n\nを\n\n```coffeescript\n{\n  hoge: -> console.log 'hoge~'\n  piyo: -> console.log 'piyo~'\n  foo -> console.log 'foo~'\n}[x]()\n```\n\nにしました。whenの数だけ行数が減ります。\n\nあとconsの実装を\n\n```coffeescript\nnewList = args[1].values[..]\nnewList.unshift(args[0])\nnew List newList\n```\n\nから\n\n```coffeescript\nnew List [args[0], args[1].values...]\n```\n\nに書き換えました。CoffeeScriptはこういう便利な構文が多いですね！\n\nこの時点で、204行\n\n### mapを使う\n\n```coffeescript\nfor expr in ast\n  ret = @eval_expr(expr)\n  return ret.toString()\n```\n\nを\n\n```coffeescript\nast.map((expr) => @eval_expr(expr)).pop().toString()\n```\n\nにした。配列の末尾をとるメソッドが見当たらなかったのでpopをつかいました。ここでついに200行！\n\n## 感想\n\n処理系としては最低限だが、思ったよりあっさりできました。特にパーサーを手書きで書いたのは初めてだったのですが、特につまることなくできてしまいました。ということで、初めて作る処理系としてLispを勧めてみたいと思いました。\n\nパーサーを実装してからみつけたのですが、[((Pythonで) 書く (Lisp) インタプリタ)](http://www.aoky.net/articles/peter_norvig/lispy.htm)はわずか90行で実装しています。ソースを見るとパースはスペースで分割しているみたいです。賢い！",
        "body": "<p>Lispの勉強がてらCoffeeScriptで作ってみました。</p>\n<p>仕様は <a href=\"http://ja.wikipedia.org/wiki/LISP\" title=\"http://ja.wikipedia.org/wiki/LISP\" target=\"_blank\">http://ja.wikipedia.org/wiki/LISP</a> や <a href=\"http://ja.wikipedia.org/wiki/純LISP\" title=\"http://ja.wikipedia.org/wiki/純LISP\" target=\"_blank\">http://ja.wikipedia.org/wiki/純LISP</a> を参考にググりながらやったので、違うところがあるかもしれません。</p>\n<p>ソースは <a href=\"https://github.com/long-long-float/lisp-js/tree/limit200\" title=\"https://github.com/long-long-float/lisp-js/tree/limit200\" target=\"_blank\">https://github.com/long-long-float/lisp-js/tree/limit200</a> で、 <a href=\"http://long-long-float.github.io/lisp-js/index.html\" title=\"http://long-long-float.github.io/lisp-js/index.html\" target=\"_blank\">http://long-long-float.github.io/lisp-js/index.html</a> で実際に動かすことができます。</p>\n<div class=\"code-frame\" data-lang=\"coffeescript\"><div class=\"highlight\"><pre><span class=\"k\">class</span> <span class=\"nx\">Symbol</span>\n  <span class=\"nv\">constructor: </span><span class=\"nf\">(@name) -&gt;</span>\n  <span class=\"nv\">toString: </span><span class=\"nf\">-&gt;</span> <span class=\"nx\">@name</span>\n\n<span class=\"k\">class</span> <span class=\"nx\">Nil</span>\n  <span class=\"nv\">toString: </span><span class=\"nf\">-&gt;</span> <span class=\"s\">&#39;nil&#39;</span>\n<span class=\"nv\">nil = </span><span class=\"k\">new</span> <span class=\"nx\">Nil</span>\n<span class=\"k\">class</span> <span class=\"nx\">T</span>\n  <span class=\"nv\">toString: </span><span class=\"nf\">-&gt;</span> <span class=\"s\">&#39;t&#39;</span>\n<span class=\"nv\">t = </span><span class=\"k\">new</span> <span class=\"nx\">T</span>\n\n<span class=\"k\">class</span> <span class=\"nx\">List</span>\n  <span class=\"nv\">constructor: </span><span class=\"nf\">(@values) -&gt;</span>\n  <span class=\"nv\">toString: </span><span class=\"nf\">-&gt;</span> <span class=\"s\">&quot;(</span><span class=\"si\">#{</span><span class=\"nx\">@values</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nf\">(v) -&gt;</span> <span class=\"nx\">v</span><span class=\"p\">.</span><span class=\"nx\">toString</span><span class=\"p\">()).</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"s\">&#39; &#39;</span><span class=\"p\">)</span><span class=\"si\">}</span><span class=\"s\">)&quot;</span>\n\n<span class=\"k\">class</span> <span class=\"nx\">CallFun</span>\n  <span class=\"nv\">constructor: </span><span class=\"nf\">(@funname, @args) -&gt;</span>\n  <span class=\"nv\">toString: </span><span class=\"nf\">-&gt;</span> <span class=\"s\">&quot;(</span><span class=\"si\">#{</span><span class=\"nx\">@funname</span><span class=\"si\">}</span><span class=\"s\"> </span><span class=\"si\">#{</span><span class=\"nx\">@values</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nf\">(v) -&gt;</span> <span class=\"nx\">v</span><span class=\"p\">.</span><span class=\"nx\">toString</span><span class=\"p\">()).</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"s\">&#39; &#39;</span><span class=\"p\">)</span><span class=\"si\">}</span><span class=\"s\">)&quot;</span>\n\n<span class=\"nv\">SF_NAMES = </span><span class=\"p\">[</span><span class=\"s\">&#39;cond&#39;</span><span class=\"p\">,</span> <span class=\"s\">&#39;quote&#39;</span><span class=\"p\">,</span> <span class=\"s\">&#39;lambda&#39;</span><span class=\"p\">,</span> <span class=\"s\">&#39;defun&#39;</span><span class=\"p\">]</span>\n<span class=\"k\">class</span> <span class=\"nx\">SpecialForm</span>\n  <span class=\"nv\">constructor: </span><span class=\"nf\">(@name, @args) -&gt;</span>\n  <span class=\"nv\">toString: </span><span class=\"nf\">-&gt;</span> <span class=\"s\">&quot;(</span><span class=\"si\">#{</span><span class=\"nx\">@name</span><span class=\"si\">}</span><span class=\"s\"> </span><span class=\"si\">#{</span><span class=\"nx\">@args</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nf\">(v) -&gt;</span> <span class=\"nx\">v</span><span class=\"p\">.</span><span class=\"nx\">toString</span><span class=\"p\">()).</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"s\">&#39; &#39;</span><span class=\"p\">)</span><span class=\"si\">}</span><span class=\"s\">)&quot;</span>\n\n<span class=\"k\">class</span> <span class=\"nx\">Lambda</span>\n  <span class=\"nv\">constructor: </span><span class=\"nf\">(@params, @body) -&gt;</span>\n\n<span class=\"k\">class</span> <span class=\"nx\">Environment</span>\n  <span class=\"nv\">constructor: </span><span class=\"nf\">(@variables) -&gt;</span>\n  <span class=\"nv\">get: </span><span class=\"nf\">(name) -&gt;</span>\n    <span class=\"nv\">val = </span><span class=\"nx\">@variables</span><span class=\"p\">[</span><span class=\"nx\">name</span><span class=\"p\">]</span>\n    <span class=\"k\">throw</span> <span class=\"s\">&quot;undefined </span><span class=\"si\">#{</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"s\">&quot;</span> <span class=\"k\">unless</span> <span class=\"nx\">val</span>\n    <span class=\"k\">return</span> <span class=\"nx\">val</span>\n  <span class=\"nv\">set: </span><span class=\"nf\">(name, val) -&gt;</span> <span class=\"nx\">@variables</span><span class=\"p\">[</span><span class=\"nx\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">val</span>\n\n<span class=\"nv\">isAtom = </span><span class=\"nf\">(val) -&gt;</span>\n  <span class=\"k\">typeof</span> <span class=\"nx\">val</span> <span class=\"o\">==</span> <span class=\"s\">&#39;string&#39;</span> <span class=\"o\">or</span> <span class=\"k\">typeof</span> <span class=\"nx\">val</span> <span class=\"o\">==</span> <span class=\"s\">&#39;number&#39;</span> <span class=\"o\">or</span>\n    <span class=\"nx\">val</span> <span class=\"k\">instanceof</span> <span class=\"nx\">Nil</span> <span class=\"o\">or</span> <span class=\"nx\">val</span> <span class=\"k\">instanceof</span> <span class=\"nx\">T</span>\n\n<span class=\"nv\">envstack = </span><span class=\"p\">[]</span>\n<span class=\"nv\">currentEnv = </span><span class=\"nf\">-&gt;</span>\n  <span class=\"k\">throw</span> <span class=\"s\">&quot;envstack is empty&quot;</span> <span class=\"k\">unless</span> <span class=\"nx\">envstack</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"nx\">envstack</span><span class=\"p\">[</span><span class=\"nx\">envstack</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n\n<span class=\"k\">class</span> <span class=\"nx\">@Parser</span>\n  <span class=\"nv\">skip: </span><span class=\"nf\">-&gt;</span>\n    <span class=\"nx\">@pos</span><span class=\"o\">++</span> <span class=\"k\">while</span> <span class=\"nx\">@code</span><span class=\"p\">[</span><span class=\"nx\">@pos</span><span class=\"p\">]</span><span class=\"o\">?</span><span class=\"p\">.</span><span class=\"nx\">match</span> <span class=\"sr\">/[ \\r\\n\\t]/</span>\n\n  <span class=\"nv\">isEOF: </span><span class=\"nf\">-&gt;</span>\n    <span class=\"nx\">@pos</span> <span class=\"o\">==</span> <span class=\"nx\">@code</span><span class=\"p\">.</span><span class=\"nx\">length</span>\n\n  <span class=\"nv\">expects: </span><span class=\"nf\">(pattern, throwing = false) -&gt;</span>\n    <span class=\"nv\">valid = </span><span class=\"nx\">@code</span><span class=\"p\">[</span><span class=\"nx\">@pos</span><span class=\"p\">]</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"nx\">pattern</span> <span class=\"k\">instanceof</span> <span class=\"nb\">RegExp</span> <span class=\"o\">and</span> <span class=\"nx\">pattern</span><span class=\"p\">.</span><span class=\"nx\">test</span> <span class=\"nx\">@code</span><span class=\"p\">[</span><span class=\"nx\">@pos</span><span class=\"p\">])</span> <span class=\"o\">||</span> <span class=\"nx\">pattern</span> <span class=\"o\">==</span> <span class=\"nx\">@code</span><span class=\"p\">[</span><span class=\"nx\">@pos</span><span class=\"p\">...</span><span class=\"nx\">@pos</span> <span class=\"o\">+</span> <span class=\"nx\">pattern</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">]</span>\n    <span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"nx\">valid</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">throwing</span>\n      <span class=\"k\">throw</span> <span class=\"s\">&quot;unexpected \\&quot;</span><span class=\"si\">#{</span><span class=\"nx\">@code</span><span class=\"p\">[</span><span class=\"nx\">@pos</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s\">\\&quot;, expects \\&quot;</span><span class=\"si\">#{</span><span class=\"nx\">pattern</span><span class=\"si\">}</span><span class=\"s\">\\&quot;&quot;</span>\n\n    <span class=\"k\">return</span> <span class=\"nx\">valid</span>\n\n  <span class=\"nv\">forwards: </span><span class=\"nf\">(pattern) -&gt;</span>\n    <span class=\"nx\">@expects</span> <span class=\"nx\">pattern</span><span class=\"p\">,</span> <span class=\"kc\">true</span>\n    <span class=\"nx\">@code</span><span class=\"p\">[</span><span class=\"nx\">@pos</span><span class=\"p\">]</span>\n    <span class=\"nx\">@pos</span> <span class=\"o\">+=</span> <span class=\"k\">if</span> <span class=\"nx\">pattern</span> <span class=\"k\">instanceof</span> <span class=\"nb\">RegExp</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"nx\">pattern</span><span class=\"p\">.</span><span class=\"nx\">length</span>\n\n  <span class=\"nv\">forwards_if: </span><span class=\"nf\">(pattern) -&gt;</span>\n    <span class=\"nx\">@forwards</span> <span class=\"nx\">pattern</span> <span class=\"k\">if</span> <span class=\"nx\">@expects</span> <span class=\"nx\">pattern</span>\n\n  <span class=\"nv\">atom: </span><span class=\"nf\">-&gt;</span>\n    <span class=\"c1\">#number</span>\n    <span class=\"k\">if</span> <span class=\"nx\">@expects</span> <span class=\"sr\">/[0-9]/</span>\n      <span class=\"nv\">num = </span><span class=\"s\">&#39;&#39;</span>\n      <span class=\"nx\">num</span> <span class=\"o\">+=</span> <span class=\"nx\">@code</span><span class=\"p\">[</span><span class=\"nx\">@pos</span><span class=\"o\">++</span><span class=\"p\">]</span> <span class=\"k\">while</span> <span class=\"nx\">@expects</span> <span class=\"sr\">/[0-9]/</span>\n      <span class=\"k\">return</span> <span class=\"nb\">parseInt</span><span class=\"p\">(</span><span class=\"nx\">num</span><span class=\"p\">)</span>\n\n    <span class=\"c1\">#string</span>\n    <span class=\"k\">if</span> <span class=\"nx\">@forwards_if</span> <span class=\"s\">&#39;&quot;&#39;</span>\n      <span class=\"nv\">str = </span><span class=\"s\">&#39;&#39;</span>\n      <span class=\"nx\">str</span> <span class=\"o\">+=</span> <span class=\"nx\">@code</span><span class=\"p\">[</span><span class=\"nx\">@pos</span><span class=\"o\">++</span><span class=\"p\">]</span> <span class=\"k\">until</span> <span class=\"nx\">@expects</span> <span class=\"s\">&#39;&quot;&#39;</span>\n      <span class=\"nx\">@forwards</span> <span class=\"s\">&#39;&quot;&#39;</span>\n      <span class=\"k\">return</span> <span class=\"nx\">str</span>\n\n    <span class=\"k\">return</span> <span class=\"nx\">nil</span> <span class=\"k\">if</span> <span class=\"nx\">@forwards_if</span> <span class=\"s\">&#39;nil&#39;</span>\n    <span class=\"k\">return</span> <span class=\"nx\">t</span> <span class=\"k\">if</span> <span class=\"nx\">@forwards_if</span> <span class=\"s\">&#39;t&#39;</span>\n\n    <span class=\"c1\">#var</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nx\">Symbol</span><span class=\"p\">(</span><span class=\"nx\">@symbol</span><span class=\"p\">())</span>\n\n  <span class=\"nv\">symbol: </span><span class=\"nf\">-&gt;</span>\n    <span class=\"nv\">ret = </span><span class=\"s\">&#39;&#39;</span>\n    <span class=\"nx\">ret</span> <span class=\"o\">+=</span> <span class=\"nx\">@code</span><span class=\"p\">[</span><span class=\"nx\">@pos</span><span class=\"o\">++</span><span class=\"p\">]</span> <span class=\"k\">while</span> <span class=\"nx\">@expects</span> <span class=\"sr\">/[\\w!#$%&amp;=-~^|*+&lt;&gt;?_]/</span>\n    <span class=\"k\">return</span> <span class=\"nx\">ret</span>\n\n  <span class=\"nv\">list: </span><span class=\"nf\">-&gt;</span>\n    <span class=\"nx\">@forwards</span> <span class=\"s\">&#39;(&#39;</span>\n    <span class=\"nv\">values = </span><span class=\"p\">[]</span>\n    <span class=\"k\">until</span> <span class=\"nx\">@expects</span><span class=\"p\">(</span><span class=\"s\">&#39;)&#39;</span><span class=\"p\">)</span> <span class=\"o\">or</span> <span class=\"nx\">@isEOF</span><span class=\"p\">()</span>\n      <span class=\"nx\">values</span><span class=\"p\">.</span><span class=\"nx\">push</span> <span class=\"nx\">@expr</span><span class=\"p\">()</span>\n      <span class=\"nx\">@skip</span><span class=\"p\">()</span>\n    <span class=\"nx\">@forwards</span> <span class=\"s\">&#39;)&#39;</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nx\">List</span><span class=\"p\">(</span><span class=\"nx\">values</span><span class=\"p\">)</span>\n\n  <span class=\"nv\">call_fun: </span><span class=\"nf\">-&gt;</span>\n    <span class=\"nx\">@forwards</span> <span class=\"s\">&#39;(&#39;</span>\n    <span class=\"nv\">args = </span><span class=\"p\">[]</span>\n    <span class=\"nv\">funname = </span><span class=\"nx\">@expr</span><span class=\"p\">()</span>\n\n    <span class=\"nv\">isSF = </span><span class=\"nx\">SF_NAMES</span><span class=\"p\">.</span><span class=\"nx\">indexOf</span><span class=\"p\">(</span><span class=\"nx\">funname</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n    <span class=\"k\">until</span> <span class=\"nx\">@expects</span><span class=\"p\">(</span><span class=\"s\">&#39;)&#39;</span><span class=\"p\">)</span> <span class=\"o\">or</span> <span class=\"nx\">@isEOF</span><span class=\"p\">()</span>\n      <span class=\"nx\">@skip</span><span class=\"p\">()</span>\n      <span class=\"nx\">args</span><span class=\"p\">.</span><span class=\"nx\">push</span> <span class=\"nx\">@expr</span><span class=\"p\">(</span><span class=\"nx\">isSF</span><span class=\"p\">)</span>\n\n    <span class=\"nx\">@forwards</span> <span class=\"s\">&#39;)&#39;</span>\n\n    <span class=\"nv\">klass = </span><span class=\"k\">if</span> <span class=\"nx\">isSF</span> <span class=\"k\">then</span> <span class=\"nx\">SpecialForm</span> <span class=\"k\">else</span> <span class=\"nx\">CallFun</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"nx\">klass</span><span class=\"p\">(</span><span class=\"nx\">funname</span><span class=\"p\">,</span> <span class=\"nx\">args</span><span class=\"p\">)</span>\n\n  <span class=\"nv\">expr: </span><span class=\"nf\">(isSF) -&gt;</span>\n    <span class=\"k\">if</span> <span class=\"nx\">@expects</span><span class=\"p\">(</span><span class=\"s\">&quot;&#39;&quot;</span><span class=\"p\">)</span> <span class=\"o\">or</span> <span class=\"nx\">isSF</span> <span class=\"c1\">#value</span>\n      <span class=\"nx\">@forwards</span> <span class=\"s\">&quot;&#39;&quot;</span> <span class=\"k\">unless</span> <span class=\"nx\">isSF</span>\n      <span class=\"k\">if</span> <span class=\"nx\">@expects</span> <span class=\"s\">&#39;(&#39;</span> <span class=\"c1\">#list</span>\n        <span class=\"k\">return</span> <span class=\"nx\">@list</span><span class=\"p\">()</span>\n      <span class=\"k\">else</span> <span class=\"c1\">#atom</span>\n        <span class=\"k\">return</span> <span class=\"nx\">@atom</span><span class=\"p\">()</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"nx\">@expects</span> <span class=\"s\">&#39;(&#39;</span> <span class=\"c1\">#calling function or special form</span>\n      <span class=\"k\">return</span> <span class=\"nx\">@call_fun</span><span class=\"p\">()</span>\n    <span class=\"k\">else</span> <span class=\"c1\">#atom</span>\n      <span class=\"k\">return</span> <span class=\"nx\">@atom</span><span class=\"p\">()</span>\n\n  <span class=\"nv\">program: </span><span class=\"nf\">-&gt;</span>\n    <span class=\"nv\">ret = </span><span class=\"p\">[]</span>\n    <span class=\"k\">until</span> <span class=\"nx\">@isEOF</span><span class=\"p\">()</span>\n      <span class=\"nx\">@skip</span><span class=\"p\">()</span>\n      <span class=\"nx\">ret</span><span class=\"p\">.</span><span class=\"nx\">push</span> <span class=\"nx\">@expr</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span> <span class=\"nx\">ret</span>\n\n  <span class=\"nv\">parse: </span><span class=\"nf\">(@code) -&gt;</span>\n    <span class=\"vi\">@pos = </span><span class=\"mi\">0</span>\n    <span class=\"nx\">@program</span><span class=\"p\">()</span>\n\n<span class=\"k\">class</span> <span class=\"nx\">Evaluator</span>\n  <span class=\"nv\">exec_lambda: </span><span class=\"nf\">(lambda, args) -&gt;</span>\n    <span class=\"nx\">envstack</span><span class=\"p\">.</span><span class=\"nx\">push</span> <span class=\"k\">new</span> <span class=\"nx\">Environment</span><span class=\"p\">(</span><span class=\"nx\">lambda</span><span class=\"p\">.</span><span class=\"nx\">params</span><span class=\"p\">.</span><span class=\"nx\">values</span><span class=\"p\">.</span><span class=\"nx\">reduce</span><span class=\"p\">(</span>\n      <span class=\"p\">(</span><span class=\"nf\">(env, param, index) -&gt;</span> <span class=\"nx\">env</span><span class=\"p\">[</span><span class=\"nx\">param</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"nx\">index</span><span class=\"p\">];</span> <span class=\"nx\">env</span><span class=\"p\">),</span> <span class=\"p\">{}))</span>\n    <span class=\"p\">[</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">args</span><span class=\"p\">...]</span> <span class=\"o\">=</span> <span class=\"nx\">lambda</span><span class=\"p\">.</span><span class=\"nx\">body</span><span class=\"p\">.</span><span class=\"nx\">values</span>\n    <span class=\"nv\">ret = </span><span class=\"nx\">@eval_expr</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nx\">CallFun</span><span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">args</span><span class=\"p\">))</span>\n    <span class=\"nx\">envstack</span><span class=\"p\">.</span><span class=\"nx\">pop</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span> <span class=\"nx\">ret</span>\n\n  <span class=\"nv\">eval_expr: </span><span class=\"nf\">(expr) -&gt;</span>\n    <span class=\"k\">switch</span> <span class=\"nx\">expr</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span>\n      <span class=\"k\">when</span> <span class=\"s\">&#39;SpecialForm&#39;</span>\n        <span class=\"nv\">args = </span><span class=\"nx\">expr</span><span class=\"p\">.</span><span class=\"nx\">args</span>\n        <span class=\"p\">{</span>\n          <span class=\"s\">&#39;cond&#39;</span><span class=\"o\">:</span> <span class=\"o\">=&gt;</span> <span class=\"nx\">args</span><span class=\"p\">.</span><span class=\"nx\">filter</span><span class=\"p\">(</span><span class=\"nf\">(arg) =&gt;</span> <span class=\"o\">!</span><span class=\"p\">(</span><span class=\"nx\">@eval_expr</span><span class=\"p\">(</span><span class=\"nx\">arg</span><span class=\"p\">.</span><span class=\"nx\">values</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"k\">instanceof</span> <span class=\"nx\">Nil</span><span class=\"p\">))[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">?</span><span class=\"p\">.</span><span class=\"nx\">values</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">||</span> <span class=\"nx\">nil</span>\n          <span class=\"s\">&#39;quote&#39;</span><span class=\"o\">:</span> <span class=\"nf\">-&gt;</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n          <span class=\"s\">&#39;lambda&#39;</span><span class=\"o\">:</span> <span class=\"nf\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nx\">Lambda</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n          <span class=\"s\">&#39;defun&#39;</span><span class=\"o\">:</span> <span class=\"nf\">-&gt;</span> <span class=\"nx\">currentEnv</span><span class=\"p\">().</span><span class=\"nx\">set</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"k\">new</span> <span class=\"nx\">Lambda</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]))</span>\n        <span class=\"p\">}[</span><span class=\"nx\">expr</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">]()</span>\n\n      <span class=\"k\">when</span> <span class=\"s\">&#39;CallFun&#39;</span>\n        <span class=\"nv\">args = </span><span class=\"nx\">expr</span><span class=\"p\">.</span><span class=\"nx\">args</span><span class=\"p\">.</span><span class=\"nx\">map</span> <span class=\"nf\">(arg) =&gt;</span> <span class=\"nx\">@eval_expr</span><span class=\"p\">(</span><span class=\"nx\">arg</span><span class=\"p\">)</span>\n        <span class=\"nv\">funname = </span><span class=\"k\">if</span> <span class=\"nx\">expr</span><span class=\"p\">.</span><span class=\"nx\">funname</span> <span class=\"k\">instanceof</span> <span class=\"nx\">SpecialForm</span> <span class=\"k\">then</span> <span class=\"nx\">@eval_expr</span><span class=\"p\">(</span><span class=\"nx\">expr</span><span class=\"p\">.</span><span class=\"nx\">funname</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"nx\">expr</span><span class=\"p\">.</span><span class=\"nx\">funname</span>\n        <span class=\"k\">switch</span> <span class=\"nx\">funname</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span>\n          <span class=\"k\">when</span> <span class=\"s\">&#39;Lambda&#39;</span>\n            <span class=\"nx\">@exec_lambda</span><span class=\"p\">(</span><span class=\"nx\">funname</span><span class=\"p\">)</span>\n          <span class=\"k\">when</span> <span class=\"s\">&#39;Symbol&#39;</span>\n            <span class=\"nv\">funcs = </span><span class=\"p\">{</span>\n              <span class=\"s\">&#39;+&#39;</span><span class=\"o\">:</span> <span class=\"nf\">-&gt;</span> <span class=\"nx\">args</span><span class=\"p\">.</span><span class=\"nx\">reduce</span><span class=\"p\">((</span><span class=\"nf\">(sum, n) -&gt;</span> <span class=\"nx\">sum</span> <span class=\"o\">+</span> <span class=\"nx\">n</span><span class=\"p\">),</span> <span class=\"mi\">0</span><span class=\"p\">),</span>\n              <span class=\"s\">&#39;car&#39;</span><span class=\"o\">:</span> <span class=\"nf\">-&gt;</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">values</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n              <span class=\"s\">&#39;cdr&#39;</span><span class=\"o\">:</span> <span class=\"nf\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nx\">List</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">values</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">..]</span>\n              <span class=\"s\">&#39;cons&#39;</span><span class=\"o\">:</span> <span class=\"nf\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nx\">List</span> <span class=\"p\">[</span><span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"nx\">values</span><span class=\"p\">...]</span>\n              <span class=\"s\">&#39;eq&#39;</span><span class=\"o\">:</span> <span class=\"nf\">-&gt;</span> <span class=\"k\">if</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"k\">then</span> <span class=\"nx\">t</span> <span class=\"k\">else</span> <span class=\"nx\">nil</span>\n              <span class=\"s\">&#39;atom&#39;</span><span class=\"o\">:</span> <span class=\"nf\">-&gt;</span> <span class=\"k\">if</span> <span class=\"nx\">isAtom</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"k\">then</span> <span class=\"nx\">t</span> <span class=\"k\">else</span> <span class=\"nx\">nil</span>\n            <span class=\"p\">}</span>\n            <span class=\"k\">if</span> <span class=\"nv\">funs = </span><span class=\"nx\">funcs</span><span class=\"p\">[</span><span class=\"nx\">funname</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">]</span>\n              <span class=\"nx\">funs</span><span class=\"p\">()</span>\n            <span class=\"k\">else</span>\n              <span class=\"k\">if</span> <span class=\"nv\">lambda = </span><span class=\"nx\">currentEnv</span><span class=\"p\">().</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"nx\">funname</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">)</span>\n                <span class=\"nx\">@exec_lambda</span><span class=\"p\">(</span><span class=\"nx\">lambda</span><span class=\"p\">,</span> <span class=\"nx\">args</span><span class=\"p\">)</span>\n              <span class=\"k\">else</span>\n                <span class=\"k\">throw</span> <span class=\"s\">&quot;undefined function : </span><span class=\"si\">#{</span><span class=\"nx\">funname</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"s\">&quot;</span>\n          <span class=\"k\">else</span>\n            <span class=\"k\">throw</span> <span class=\"s\">&quot;</span><span class=\"si\">#{</span><span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"nx\">funname</span><span class=\"p\">)</span><span class=\"si\">}</span><span class=\"s\">(</span><span class=\"si\">#{</span><span class=\"nx\">funname</span><span class=\"p\">.</span><span class=\"nx\">constructor</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"s\">) is not a function&quot;</span>\n      <span class=\"k\">when</span> <span class=\"s\">&#39;Symbol&#39;</span>\n        <span class=\"nx\">currentEnv</span><span class=\"p\">().</span><span class=\"nx\">get</span><span class=\"p\">(</span><span class=\"nx\">expr</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">)</span>\n      <span class=\"k\">else</span>\n        <span class=\"nx\">expr</span>\n\n  <span class=\"nb\">eval</span><span class=\"o\">:</span> <span class=\"nf\">(ast) -&gt;</span>\n    <span class=\"nx\">envstack</span><span class=\"p\">.</span><span class=\"nx\">push</span> <span class=\"k\">new</span> <span class=\"nx\">Environment</span><span class=\"p\">({})</span>\n    <span class=\"nx\">ast</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nf\">(expr) =&gt;</span> <span class=\"nx\">@eval_expr</span><span class=\"p\">(</span><span class=\"nx\">expr</span><span class=\"p\">)).</span><span class=\"nx\">pop</span><span class=\"p\">().</span><span class=\"nx\">toString</span><span class=\"p\">()</span>\n\n<span class=\"k\">class</span> <span class=\"nx\">@Lisp</span>\n  <span class=\"vi\">@eval: </span><span class=\"nf\">(code) -&gt;</span>\n    <span class=\"nv\">ast = </span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nx\">Parser</span><span class=\"p\">).</span><span class=\"nx\">parse</span><span class=\"p\">(</span><span class=\"nx\">code</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span><span class=\"nv\">ast: </span><span class=\"nx\">ast</span><span class=\"p\">,</span> <span class=\"nv\">body: </span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nx\">Evaluator</span><span class=\"p\">).</span><span class=\"nb\">eval</span><span class=\"p\">(</span><span class=\"nx\">ast</span><span class=\"p\">)}</span>\n\n<span class=\"c1\">#support script tag</span>\n<span class=\"nx\">$</span> <span class=\"nf\">-&gt;</span>\n  <span class=\"nx\">$</span><span class=\"p\">(</span><span class=\"s\">&#39;script[type=&quot;text/lisp&quot;]&#39;</span><span class=\"p\">).</span><span class=\"nx\">each</span> <span class=\"nf\">-&gt;</span>\n    <span class=\"nx\">Lisp</span><span class=\"p\">.</span><span class=\"nb\">eval</span> <span class=\"nx\">$</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">).</span><span class=\"nx\">text</span><span class=\"p\">()</span>\n</pre></div></div><h2>\n        <span id=\"2-1\" class=\"fragment\"></span>\n        <a href=\"#2-1\"><i class=\"fa fa-link\"></i></a>説明\n      </h2><p>今回は勉強目的だったのでパーサーは手書きしました。再帰下降パーサーです。Parserクラスがこの役割を担っています。内部表現としてSymbol, Nil等のクラスを作りました。</p>\n<p>内部表現に変換したらEvaluatorクラスが評価します。再帰で普通にやっているだけです。</p>\n<h2>\n        <span id=\"2-2\" class=\"fragment\"></span>\n        <a href=\"#2-2\"><i class=\"fa fa-link\"></i></a>短くするために\n      </h2><p>きりのいい200行にするためにやったこと</p>\n<p>この時点で、247行</p>\n<h3>\n        <span id=\"3-1\" class=\"fragment\"></span>\n        <a href=\"#3-1\"><i class=\"fa fa-link\"></i></a>何度も登場する部分を関数として抽出する\n      </h3><p>基本中の基本ですね。</p>\n<div class=\"code-frame\" data-lang=\"coffeescript\"><div class=\"highlight\"><pre><span class=\"k\">if</span> <span class=\"nx\">@expects</span> <span class=\"nx\">xxx</span>\n  <span class=\"nx\">@forwards</span> <span class=\"nx\">xxx</span>\n  <span class=\"c1\">#...</span>\n</pre></div></div><p>が結構多かったので、<code>forwards_if</code>を作って、</p>\n<div class=\"code-frame\" data-lang=\"coffeescript\"><div class=\"highlight\"><pre><span class=\"k\">if</span> <span class=\"nx\">@forwards_if</span> <span class=\"nx\">xxx</span>\n  <span class=\"c1\">#...</span>\n</pre></div></div><p>に書き換えました。ついでに、後置ifに置き換えました。</p>\n<div class=\"code-frame\" data-lang=\"coffeescript\"><div class=\"highlight\"><pre><span class=\"c1\">#nil</span>\n<span class=\"k\">if</span> <span class=\"nx\">@expects</span> <span class=\"s\">&#39;nil&#39;</span>\n  <span class=\"nx\">@forwards_str</span> <span class=\"s\">&#39;nil&#39;</span>\n  <span class=\"k\">return</span> <span class=\"nx\">nil</span>\n</pre></div></div><p>を</p>\n<div class=\"code-frame\" data-lang=\"coffeescript\"><div class=\"highlight\"><pre><span class=\"k\">return</span> <span class=\"nx\">nil</span> <span class=\"k\">if</span> <span class=\"nx\">@forwards_if</span> <span class=\"s\">&#39;nil&#39;</span>\n</pre></div></div><p>にしました。</p>\n<p>この時点で、221行</p>\n<h3>\n        <span id=\"3-2\" class=\"fragment\"></span>\n        <a href=\"#3-2\"><i class=\"fa fa-link\"></i></a>Switch文 -> functionを値としたオブジェクト\n      </h3><p>switch文は行数を食うという事が分かりました。具体的には、</p>\n<div class=\"code-frame\" data-lang=\"coffeescript\"><div class=\"highlight\"><pre><span class=\"k\">switch</span> <span class=\"nx\">x</span>\n  <span class=\"k\">when</span> <span class=\"s\">&#39;hoge&#39;</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span> <span class=\"s\">&#39;hoge~&#39;</span>\n  <span class=\"k\">when</span> <span class=\"s\">&#39;piyo&#39;</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span> <span class=\"s\">&#39;piyo~&#39;</span>\n  <span class=\"k\">when</span> <span class=\"s\">&#39;foo&#39;</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span> <span class=\"s\">&#39;foo~&#39;</span>\n</pre></div></div><p>を</p>\n<div class=\"code-frame\" data-lang=\"coffeescript\"><div class=\"highlight\"><pre><span class=\"p\">{</span>\n  <span class=\"nv\">hoge: </span><span class=\"nf\">-&gt;</span> <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span> <span class=\"s\">&#39;hoge~&#39;</span>\n  <span class=\"nv\">piyo: </span><span class=\"nf\">-&gt;</span> <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span> <span class=\"s\">&#39;piyo~&#39;</span>\n  <span class=\"nx\">foo</span> <span class=\"nf\">-&gt;</span> <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span> <span class=\"s\">&#39;foo~&#39;</span>\n<span class=\"p\">}[</span><span class=\"nx\">x</span><span class=\"p\">]()</span>\n</pre></div></div><p>にしました。whenの数だけ行数が減ります。</p>\n<p>あとconsの実装を</p>\n<div class=\"code-frame\" data-lang=\"coffeescript\"><div class=\"highlight\"><pre><span class=\"nv\">newList = </span><span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"nx\">values</span><span class=\"p\">[..]</span>\n<span class=\"nx\">newList</span><span class=\"p\">.</span><span class=\"nx\">unshift</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"k\">new</span> <span class=\"nx\">List</span> <span class=\"nx\">newList</span>\n</pre></div></div><p>から</p>\n<div class=\"code-frame\" data-lang=\"coffeescript\"><div class=\"highlight\"><pre><span class=\"k\">new</span> <span class=\"nx\">List</span> <span class=\"p\">[</span><span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"nx\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"nx\">values</span><span class=\"p\">...]</span>\n</pre></div></div><p>に書き換えました。CoffeeScriptはこういう便利な構文が多いですね！</p>\n<p>この時点で、204行</p>\n<h3>\n        <span id=\"3-3\" class=\"fragment\"></span>\n        <a href=\"#3-3\"><i class=\"fa fa-link\"></i></a>mapを使う\n      </h3><div class=\"code-frame\" data-lang=\"coffeescript\"><div class=\"highlight\"><pre><span class=\"k\">for</span> <span class=\"nx\">expr</span> <span class=\"k\">in</span> <span class=\"nx\">ast</span>\n  <span class=\"nv\">ret = </span><span class=\"nx\">@eval_expr</span><span class=\"p\">(</span><span class=\"nx\">expr</span><span class=\"p\">)</span>\n  <span class=\"k\">return</span> <span class=\"nx\">ret</span><span class=\"p\">.</span><span class=\"nx\">toString</span><span class=\"p\">()</span>\n</pre></div></div><p>を</p>\n<div class=\"code-frame\" data-lang=\"coffeescript\"><div class=\"highlight\"><pre><span class=\"nx\">ast</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nf\">(expr) =&gt;</span> <span class=\"nx\">@eval_expr</span><span class=\"p\">(</span><span class=\"nx\">expr</span><span class=\"p\">)).</span><span class=\"nx\">pop</span><span class=\"p\">().</span><span class=\"nx\">toString</span><span class=\"p\">()</span>\n</pre></div></div><p>にした。配列の末尾をとるメソッドが見当たらなかったのでpopをつかいました。ここでついに200行！</p>\n<h2>\n        <span id=\"2-3\" class=\"fragment\"></span>\n        <a href=\"#2-3\"><i class=\"fa fa-link\"></i></a>感想\n      </h2><p>処理系としては最低限だが、思ったよりあっさりできました。特にパーサーを手書きで書いたのは初めてだったのですが、特につまることなくできてしまいました。ということで、初めて作る処理系としてLispを勧めてみたいと思いました。</p>\n<p>パーサーを実装してからみつけたのですが、<a href=\"http://www.aoky.net/articles/peter_norvig/lispy.htm\" title=\"\" target=\"_blank\">((Pythonで) 書く (Lisp) インタプリタ)</a>はわずか90行で実装しています。ソースを見るとパースはスペースで分割しているみたいです。賢い！</p>\n",
        "stock_users": [
            "koki_cheese",
            "rn404",
            "fracmode",
            "tsuyoshi_cho",
            "toby_net",
            "xorphitus",
            "Noboruhi",
            "akmiyoshi",
            "selious",
            "kasumani",
            "Reds",
            "sassy_watson"
        ]
    },
    {
        "id": 59085,
        "uuid": "fc1764dde1fa62cdac2f",
        "user": {
            "id": 18886,
            "url_name": "jonigata",
            "profile_image_url": "https://secure.gravatar.com/avatar/d5ba6a59bd51385910c1d8fb210102bc"
        },
        "title": "GLRパーサの実装(コーディング編)",
        "created_at": "2014-04-12 01:49:18 +0900",
        "updated_at": "2014-04-12 17:26:37 +0900",
        "created_at_in_words": "5ヶ月",
        "updated_at_in_words": "5ヶ月",
        "tags": [
            {
                "name": "パーサジェネレータ",
                "url_name": "%e3%83%91%e3%83%bc%e3%82%b5%e3%82%b8%e3%82%a7%e3%83%8d%e3%83%ac%e3%83%bc%e3%82%bf",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            },
            {
                "name": "JavaScript",
                "url_name": "javascript",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/c01023cf926d47b711747c9d00b00fd18dc6638a/medium.jpg?1364837881",
                "versions": []
            },
            {
                "name": "C++",
                "url_name": "cpp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/2f1bca4f52b2c48a0282062eff2db8323fcddc2a/medium.jpg?1364837801",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "コンパイラ",
                "url_name": "%e3%82%b3%e3%83%b3%e3%83%91%e3%82%a4%e3%83%a9",
                "icon_url": "/icons/medium/missing.png",
                "versions": []
            }
        ],
        "stock_count": 4,
        "comment_count": 0,
        "url": "http://qiita.com/jonigata/items/fc1764dde1fa62cdac2f",
        "created_at_as_seconds": 1397234958,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "# 対象読者など　\n\n[前回](http://qiita.com/jonigata/items/69381937b2d5b0af410c)の続きです。LR構文解析の基本的な方法が分かっている方が想定読者です。そこから知りたい方は、ドラゴンブックを読むか、[Wikipedia](http://ja.wikipedia.org/wiki/LR%E6%B3%95)、前々回紹介した[ytqwertyさんの記事](http://d.hatena.ne.jp/ytqwerty/20080304#p3)などを御覧ください。\n\n申し訳ありませんが、この文書を読んでもGLRを実装できるようにはたぶんなりません。が、概略と注意点を大まかにつかむ程度はできるのではないかな、と思います。\n\n# お手本\n\n実装にあたって、「[Efficient Parsing for Natural Language](http://www.amazon.co.jp/Efficient-Parsing-Natural-Language-International/dp/0898382025)」をお手本とします。本文書で「教科書」と言ったらこの本のことだと思ってください。\n\n私の履歴を見ると、どうも20000円だして買ったようです。たっか！　研究者でもないのにちょっと頭おかしい感じがしますね。でもお陰でなんとか実装できたようなので、後悔はしていません。\n\nこの本は、\n\n* 1章　イントロ\n* 2章　アルゴリズムのインフォーマルな説明\n* 3章　実例\n* 4章　アルゴリズムのフォーマルな説明\n* 5章以降　他のアルゴリズムとの比較、証明、パフォーマンスなど\n\nといった構成になっていて、さらにおまけとして証明やコード！がついています。\n\nコードといっても、MACLISPのコードで、ちょっと読む気が起きなかったので私は読みませんでした。\n\n![MACLISP](https://dl.dropboxusercontent.com/u/1767117/maclisp.png)\n\n本を買う気のある方は、これをschemeあたりに逐語訳してから読むなどすれば、少し楽ができるかもしれません。\n\nアルゴリズムのフォーマルな説明も、私の知性が足りなかったのでほとんど読んでいません。ほぼ2章と3章だけ読んで実装しました。したがって、どこか間違っているかもしれません。間違いを見つけたら是非教えて下さい。\n\nGLRは、この本のタイトル通り、自然言語の構文解析のために考案されたアルゴリズムのようですね。ですが、特性的には機械言語の方が向いている気がします。この文書を読んでいただければなんとなく納得していただける、かもしれません。\n\n3章の実例ではスタックの詳細のトレースが図示されていて非常にありがたい（というか私から見るとこの本の価値の7割くらいは3章、2割くらいが2章といった感じ）ですが、パースフォレストの内容が一部あきらかに間違っているっぽいので注意してください。例えばp30以降のnode12は6ではなく8が正しく、p36以降のnode26も[S(15 20)]の間違いだと思います。\n\n# 実装難易度\n\n考え方自体はかなりstraightforwardな感じで、LALRテーブル作成よりははるかに楽でした。正味2～3日でできたのではないかという気がします（間にコーディングはしてないけど頭では考えてる時間が挟まってますが）。データ構造がとても関数型チックなので、関数型言語の覚えがない方は先に勉強をしておくと捗ると思います。\n\n# テーブル\n\nテーブルはLR系だったらなんでもいいと教科書にも書いてありましたので、私はcaperのLALRテーブルを利用しました。\n\n前回書いたように、GLRではコンフリクトが起きる場合すべて並列に扱いますので、アクションテーブルは順序つきセットとして、すべての可能性を保持するようにちょっとだけ改造しました。その結果コードはある意味簡潔になりました。\n\n# データ構造\n\nデータ構造については前回も書きましたが、軽くおさらいしておきます。\n\nGLRのスタックは、前回はlispのconsセルで構成されたリストのようなもの、と書きましたが、それは正確ではなくて、実際は「合流」があるため[DAG](http://en.wikipedia.org/wiki/Directed_acyclic_graph)になります。教科書ではGraph Structured Stack(GSS)と呼ばれています。\n\n受理済みデータは「パースフォレスト」と呼ばれるデータ構造に置かれます。パースツリーと違ってrootが一つではないので「フォレスト」です。前回述べたように、関数型言語のpersistent treeのようなデータ構造を想像してください。たとえばOCamlのMapを使ってみると、「insertした後insert後のtreeが帰ってくるけど、insert前のtreeも依然として使える」ことに気づくと思いますが、あれです。\n\nこれらのデータ構造に関しては、[前回お見せしたシミュレータ](http://jonigata.github.io/caper/glr/glrdemo.html)をいじってみていただければ、だいたいのノリはわかると思います。\n\n前回の記事を書いてから気づいたことですが、GLRのデータ構造はgitのデータ構造ととてもよく似ています。gitをご存知の方は、gitを想像しながらシミュレータをいじってみれば理解しやすいかもしれません。\n\n# 用語\n\nグラフ構造が2種類出てきて紛らわしいこともあり、教科書ではGSSのノードを「Vertex」、パースフォレストのノードを「Node」と読んでいますので、本文書およびcaperの出力でもそれに習います。前述のシミュレータで言うと、赤がVertex、青がNodeです。\n\n# ターゲット言語\n\n前述のように、GLRパーサのデータ構造はとても関数型チックです。\n\ncaperは基本的にはC++をターゲット言語とする処理系で、他の言語用のジェネレータは「できるからやった」くらいのものなのですが、GLRの駆動エンジンを実装するにあたってC++はどう考えても不向きです（GCがないときつい）。またデバッグ出力などを必要とする時に、データ構造が1次元のテキスト向きでないので、ビジュアル化したい（そうしないと私の知性ではおそらく理解できない）といった希望もありました。そういったわけで、GCと関数型言語的な機能があり、ウェブブラウザとの親和性も高いJavascriptをターゲット言語としました。\n\n# 全体構造\n\n複数のパーサが同時に動くところを想像していたので、パーサの上位概念を作ってそれをParserと呼び、今までParserと呼んでいたものをSliceと呼んでみることにしました。\n\n# 分岐\n\nまず、一番簡単そうな分岐からはじめました。caper(LALR)の出力するスタックは、動的メモリ割り当てなしの配列でロールバックに対応しようとしたりしているため、微妙にややこしい実装になっています。ですので、一旦全部削除してlispっぽい構造に書き直しました。すると、スタック操作を独立させる必要が感じられないほどシンプルになったので、スタックという概念を削除しました。SliceはVertexへのポインタを「head」として一つだけ持つ構造になりました。\n\nスタックがそういった構造になっていると分岐は実際楽で、Sliceがコンフリクトに遭遇したらParserにそれを伝えると、ParserがSliceをcloneする、といった処理で難なく実装できました。\n\nこれができれば後は難しいことないだろう、と思っていたら、そうでもなかった……\n\n# 合流\n\n合流自体は単純な処理（同じ状態にいるSliceを統一するだけ)なのですが、2つほど実装上面倒な点がありました。\n\n## reduce\n\nLRパーサは、reduceするとき、文法規則の右側に登場するシンボルの数の分だけスタックをpopして、代わりに左側のnonterminalをpushするような動きをするのですが、合流後のスタックをpopする(合流したVertexを削除する)ということは、すなわちその操作によって合流前のheadが複数露出する可能性があるということなのです。シミュレータでいじってみればなんとなくわかると思います。実装するまでこれに気づいていなくて、結構面倒な目にあいました。\n\n教科書ではどうやってるのか形式的定義とかサンプルコード読んでないのでよくわからないんですが、反射的に「再帰っすよね」と思ったので再帰で書きました。動いてるっぽいです。\n\n## 合流判定\n\n当初、こんな感じのコードを書いていました。1ポスト＝1サイクルと考えてください。\n\n  1. 生きているSliceをすべて「reduce集合」に入れ、空の「次のreduce集合」と空の「shift集合」を用意する\n  2. 「reduce集合」に入っているすべてのSliceに対し、\n    1. そのSliceにトークンをpost\n    2. 表引きの結果がshiftだったらSliceのクローンをshift集合に入れる\n    3. 表引きの結果がreduceだったらSliceのクローンを「次のreduce集合」に入れる\n  3. 「次のreduce集合」が空でなければ、「reduce集合」にして2へ\n  4. 「shift集合」を全部処理(トークンをshift)\n  5. 「shift集合」を統合\n  6. 「shift集合」を「生きてるSlice」にする\n  7. 1サイクル終了\n\nが、どうもサンプルの結果が合わないので調べたところ、各サイクルは以下のようなアルゴリズムで書くべきだということがわかりました。\n\n  1. 生きているSliceをすべて「reduce集合」に入れ、空の「shift集合」を用意する\n  2. 「reduce集合」に入っている各Sliceから一つ取り出し、\n    1. そのSliceにトークンをpost\n    2. 表引きの結果がshiftだったらSliceのクローンをshift集合に入れる\n    3. 表引きの結果がreduceだったらSliceのクローンを「reduce集合」に入れる\n      * b, cは同時に行われる可能性もある。\n      * cはreduce/reduceコンフリクトで複数回行われる可能性もある\n      * reduceによるpopで前述のようにheadが複数生じた場合も複数回行われる可能性がある\n    d. 「reduce集合」を統合\n    e. 「reduce集合」が空になるまで2を繰り返す\n  3. 「shift集合」を統合\n  4. 「shift集合」を全部処理(トークンをshift)\n  5. 「shift集合」を統合\n  6. 「shift集合」を「生きてるSlice」にする\n  7. 1サイクル終了\n    \nつまり、何か1個reduceするたびに統合処理が入るということです。統合処理は基本的にO($n^2$)(nは生存パーサ数)なので、これだけ頻繁に行う必要があると重そうだなあという印象です。それでも、とにかくSliceの数は最小限に減らさないと危険なのでしょう。あるいは常に最小であることを保証する必要があるのかもしれませんが、私の知性だとちょっとわかりません。興味のある方は教科書の証明のところを読んでみてください。\n\nただ、O($n^2$)とはいえ、LALRに毛が生えた程度の文法の場合、だいたいnが1なのでGLRは大体は高速、ということのようです。O(nlogn)程度にする方法もあるでしょうが、nが大体1なのであれば係数負けしそうです。自然言語だったらそれでもO(nlogn)程度にしたほうがいいのかな？　ちょっと測ってみないとわからないですね。\n\nひょっとしたら、Hacker's delight的なうまい方法がある、かもしれません。\n\n# パースフォレスト\n\nパースフォレストについては、OCamlのSetのようなデータ構造がわかっていればだいたいそれと同じなので、直球で書くだけです。Vertex一つが基本的にはNode一つへのポインタを持っています。OCamlのSetなどと一つ違うのは、Vertexを統合した場合にはNodeが複数の値を持つことがある点です。\n\n# 書き直し\n\n以上で大体動くようにはなりましたが、ここまで書いた時点でSliceという概念とVertexという概念が独立して存在している意義を見失ったので、統合してSliceという概念を削除し、書き直しました。パーサ＝スタック(トップ)です。「現在生きているパーサ」は「parser.heads」になりました。型はVertexです。\n\n# ソース\n\n[こちら](https://gist.github.com/jonigata/10481869)に、caperのGLR/js出力を載せておきました。ご興味のある方はどうぞ。state_*, gotof_*のあたりは機械的に展開されたテーブルですので、読み飛ばして大丈夫です。統合の処理はいまのところちょっと冗長です。\n# GLRの問題\n\nさて、GLRには、実用にあたって、実装難易度と速度以外にも幾つか問題点があります。いったいそれはなんでしょうか？　ちょっと長くなりすぎましたので、また次回としたいと思います。\n",
        "body": "<h1>\n        <span id=\"1-1\" class=\"fragment\"></span>\n        <a href=\"#1-1\"><i class=\"fa fa-link\"></i></a>対象読者など　\n      </h1><p><a href=\"http://qiita.com/jonigata/items/69381937b2d5b0af410c\" title=\"\">前回</a>の続きです。LR構文解析の基本的な方法が分かっている方が想定読者です。そこから知りたい方は、ドラゴンブックを読むか、<a href=\"http://ja.wikipedia.org/wiki/LR%E6%B3%95\" title=\"\" target=\"_blank\">Wikipedia</a>、前々回紹介した<a href=\"http://d.hatena.ne.jp/ytqwerty/20080304#p3\" title=\"\" target=\"_blank\">ytqwertyさんの記事</a>などを御覧ください。</p>\n<p>申し訳ありませんが、この文書を読んでもGLRを実装できるようにはたぶんなりません。が、概略と注意点を大まかにつかむ程度はできるのではないかな、と思います。</p>\n<h1>\n        <span id=\"1-2\" class=\"fragment\"></span>\n        <a href=\"#1-2\"><i class=\"fa fa-link\"></i></a>お手本\n      </h1><p>実装にあたって、「<a href=\"http://www.amazon.co.jp/Efficient-Parsing-Natural-Language-International/dp/0898382025\" title=\"\" target=\"_blank\">Efficient Parsing for Natural Language</a>」をお手本とします。本文書で「教科書」と言ったらこの本のことだと思ってください。</p>\n<p>私の履歴を見ると、どうも20000円だして買ったようです。たっか！　研究者でもないのにちょっと頭おかしい感じがしますね。でもお陰でなんとか実装できたようなので、後悔はしていません。</p>\n<p>この本は、</p>\n\n<ul>\n<li>1章　イントロ</li>\n<li>2章　アルゴリズムのインフォーマルな説明</li>\n<li>3章　実例</li>\n<li>4章　アルゴリズムのフォーマルな説明</li>\n<li>5章以降　他のアルゴリズムとの比較、証明、パフォーマンスなど</li>\n</ul>\n<p>といった構成になっていて、さらにおまけとして証明やコード！がついています。</p>\n<p>コードといっても、MACLISPのコードで、ちょっと読む気が起きなかったので私は読みませんでした。</p>\n<p><img src=\"https://dl.dropboxusercontent.com/u/1767117/maclisp.png\" alt=\"MACLISP\"></p>\n<p>本を買う気のある方は、これをschemeあたりに逐語訳してから読むなどすれば、少し楽ができるかもしれません。</p>\n<p>アルゴリズムのフォーマルな説明も、私の知性が足りなかったのでほとんど読んでいません。ほぼ2章と3章だけ読んで実装しました。したがって、どこか間違っているかもしれません。間違いを見つけたら是非教えて下さい。</p>\n<p>GLRは、この本のタイトル通り、自然言語の構文解析のために考案されたアルゴリズムのようですね。ですが、特性的には機械言語の方が向いている気がします。この文書を読んでいただければなんとなく納得していただける、かもしれません。</p>\n<p>3章の実例ではスタックの詳細のトレースが図示されていて非常にありがたい（というか私から見るとこの本の価値の7割くらいは3章、2割くらいが2章といった感じ）ですが、パースフォレストの内容が一部あきらかに間違っているっぽいので注意してください。例えばp30以降のnode12は6ではなく8が正しく、p36以降のnode26も[S(15 20)]の間違いだと思います。</p>\n<h1>\n        <span id=\"1-3\" class=\"fragment\"></span>\n        <a href=\"#1-3\"><i class=\"fa fa-link\"></i></a>実装難易度\n      </h1><p>考え方自体はかなりstraightforwardな感じで、LALRテーブル作成よりははるかに楽でした。正味2～3日でできたのではないかという気がします（間にコーディングはしてないけど頭では考えてる時間が挟まってますが）。データ構造がとても関数型チックなので、関数型言語の覚えがない方は先に勉強をしておくと捗ると思います。</p>\n<h1>\n        <span id=\"1-4\" class=\"fragment\"></span>\n        <a href=\"#1-4\"><i class=\"fa fa-link\"></i></a>テーブル\n      </h1><p>テーブルはLR系だったらなんでもいいと教科書にも書いてありましたので、私はcaperのLALRテーブルを利用しました。</p>\n<p>前回書いたように、GLRではコンフリクトが起きる場合すべて並列に扱いますので、アクションテーブルは順序つきセットとして、すべての可能性を保持するようにちょっとだけ改造しました。その結果コードはある意味簡潔になりました。</p>\n<h1>\n        <span id=\"1-5\" class=\"fragment\"></span>\n        <a href=\"#1-5\"><i class=\"fa fa-link\"></i></a>データ構造\n      </h1><p>データ構造については前回も書きましたが、軽くおさらいしておきます。</p>\n<p>GLRのスタックは、前回はlispのconsセルで構成されたリストのようなもの、と書きましたが、それは正確ではなくて、実際は「合流」があるため<a href=\"http://en.wikipedia.org/wiki/Directed_acyclic_graph\" title=\"\" target=\"_blank\">DAG</a>になります。教科書ではGraph Structured Stack(GSS)と呼ばれています。</p>\n<p>受理済みデータは「パースフォレスト」と呼ばれるデータ構造に置かれます。パースツリーと違ってrootが一つではないので「フォレスト」です。前回述べたように、関数型言語のpersistent treeのようなデータ構造を想像してください。たとえばOCamlのMapを使ってみると、「insertした後insert後のtreeが帰ってくるけど、insert前のtreeも依然として使える」ことに気づくと思いますが、あれです。</p>\n<p>これらのデータ構造に関しては、<a href=\"http://jonigata.github.io/caper/glr/glrdemo.html\" title=\"\" target=\"_blank\">前回お見せしたシミュレータ</a>をいじってみていただければ、だいたいのノリはわかると思います。</p>\n<p>前回の記事を書いてから気づいたことですが、GLRのデータ構造はgitのデータ構造ととてもよく似ています。gitをご存知の方は、gitを想像しながらシミュレータをいじってみれば理解しやすいかもしれません。</p>\n<h1>\n        <span id=\"1-6\" class=\"fragment\"></span>\n        <a href=\"#1-6\"><i class=\"fa fa-link\"></i></a>用語\n      </h1><p>グラフ構造が2種類出てきて紛らわしいこともあり、教科書ではGSSのノードを「Vertex」、パースフォレストのノードを「Node」と読んでいますので、本文書およびcaperの出力でもそれに習います。前述のシミュレータで言うと、赤がVertex、青がNodeです。</p>\n<h1>\n        <span id=\"1-7\" class=\"fragment\"></span>\n        <a href=\"#1-7\"><i class=\"fa fa-link\"></i></a>ターゲット言語\n      </h1><p>前述のように、GLRパーサのデータ構造はとても関数型チックです。</p>\n<p>caperは基本的にはC++をターゲット言語とする処理系で、他の言語用のジェネレータは「できるからやった」くらいのものなのですが、GLRの駆動エンジンを実装するにあたってC++はどう考えても不向きです（GCがないときつい）。またデバッグ出力などを必要とする時に、データ構造が1次元のテキスト向きでないので、ビジュアル化したい（そうしないと私の知性ではおそらく理解できない）といった希望もありました。そういったわけで、GCと関数型言語的な機能があり、ウェブブラウザとの親和性も高いJavascriptをターゲット言語としました。</p>\n<h1>\n        <span id=\"1-8\" class=\"fragment\"></span>\n        <a href=\"#1-8\"><i class=\"fa fa-link\"></i></a>全体構造\n      </h1><p>複数のパーサが同時に動くところを想像していたので、パーサの上位概念を作ってそれをParserと呼び、今までParserと呼んでいたものをSliceと呼んでみることにしました。</p>\n<h1>\n        <span id=\"1-9\" class=\"fragment\"></span>\n        <a href=\"#1-9\"><i class=\"fa fa-link\"></i></a>分岐\n      </h1><p>まず、一番簡単そうな分岐からはじめました。caper(LALR)の出力するスタックは、動的メモリ割り当てなしの配列でロールバックに対応しようとしたりしているため、微妙にややこしい実装になっています。ですので、一旦全部削除してlispっぽい構造に書き直しました。すると、スタック操作を独立させる必要が感じられないほどシンプルになったので、スタックという概念を削除しました。SliceはVertexへのポインタを「head」として一つだけ持つ構造になりました。</p>\n<p>スタックがそういった構造になっていると分岐は実際楽で、Sliceがコンフリクトに遭遇したらParserにそれを伝えると、ParserがSliceをcloneする、といった処理で難なく実装できました。</p>\n<p>これができれば後は難しいことないだろう、と思っていたら、そうでもなかった……</p>\n<h1>\n        <span id=\"1-10\" class=\"fragment\"></span>\n        <a href=\"#1-10\"><i class=\"fa fa-link\"></i></a>合流\n      </h1><p>合流自体は単純な処理（同じ状態にいるSliceを統一するだけ)なのですが、2つほど実装上面倒な点がありました。</p>\n<h2>\n        <span id=\"2-1\" class=\"fragment\"></span>\n        <a href=\"#2-1\"><i class=\"fa fa-link\"></i></a>reduce\n      </h2><p>LRパーサは、reduceするとき、文法規則の右側に登場するシンボルの数の分だけスタックをpopして、代わりに左側のnonterminalをpushするような動きをするのですが、合流後のスタックをpopする(合流したVertexを削除する)ということは、すなわちその操作によって合流前のheadが複数露出する可能性があるということなのです。シミュレータでいじってみればなんとなくわかると思います。実装するまでこれに気づいていなくて、結構面倒な目にあいました。</p>\n<p>教科書ではどうやってるのか形式的定義とかサンプルコード読んでないのでよくわからないんですが、反射的に「再帰っすよね」と思ったので再帰で書きました。動いてるっぽいです。</p>\n<h2>\n        <span id=\"2-2\" class=\"fragment\"></span>\n        <a href=\"#2-2\"><i class=\"fa fa-link\"></i></a>合流判定\n      </h2><p>当初、こんな感じのコードを書いていました。1ポスト＝1サイクルと考えてください。</p>\n\n<ol>\n<li>生きているSliceをすべて「reduce集合」に入れ、空の「次のreduce集合」と空の「shift集合」を用意する</li>\n<li>「reduce集合」に入っているすべてのSliceに対し、\n\n<ol>\n<li>そのSliceにトークンをpost</li>\n<li>表引きの結果がshiftだったらSliceのクローンをshift集合に入れる</li>\n<li>表引きの結果がreduceだったらSliceのクローンを「次のreduce集合」に入れる</li>\n</ol></li>\n<li>「次のreduce集合」が空でなければ、「reduce集合」にして2へ</li>\n<li>「shift集合」を全部処理(トークンをshift)</li>\n<li>「shift集合」を統合</li>\n<li>「shift集合」を「生きてるSlice」にする</li>\n<li>1サイクル終了</li>\n</ol>\n<p>が、どうもサンプルの結果が合わないので調べたところ、各サイクルは以下のようなアルゴリズムで書くべきだということがわかりました。</p>\n\n<ol>\n<li>生きているSliceをすべて「reduce集合」に入れ、空の「shift集合」を用意する</li>\n<li>「reduce集合」に入っている各Sliceから一つ取り出し、\n\n<ol>\n<li>そのSliceにトークンをpost</li>\n<li>表引きの結果がshiftだったらSliceのクローンをshift集合に入れる</li>\n<li>表引きの結果がreduceだったらSliceのクローンを「reduce集合」に入れる\n\n<ul>\n<li>b, cは同時に行われる可能性もある。</li>\n<li>cはreduce/reduceコンフリクトで複数回行われる可能性もある</li>\n<li>reduceによるpopで前述のようにheadが複数生じた場合も複数回行われる可能性がある\nd. 「reduce集合」を統合\ne. 「reduce集合」が空になるまで2を繰り返す</li>\n</ul></li>\n</ol></li>\n<li>「shift集合」を統合</li>\n<li>「shift集合」を全部処理(トークンをshift)</li>\n<li>「shift集合」を統合</li>\n<li>「shift集合」を「生きてるSlice」にする</li>\n<li>1サイクル終了</li>\n</ol>\n<p>つまり、何か1個reduceするたびに統合処理が入るということです。統合処理は基本的にO($n^2$)(nは生存パーサ数)なので、これだけ頻繁に行う必要があると重そうだなあという印象です。それでも、とにかくSliceの数は最小限に減らさないと危険なのでしょう。あるいは常に最小であることを保証する必要があるのかもしれませんが、私の知性だとちょっとわかりません。興味のある方は教科書の証明のところを読んでみてください。</p>\n<p>ただ、O($n^2$)とはいえ、LALRに毛が生えた程度の文法の場合、だいたいnが1なのでGLRは大体は高速、ということのようです。O(nlogn)程度にする方法もあるでしょうが、nが大体1なのであれば係数負けしそうです。自然言語だったらそれでもO(nlogn)程度にしたほうがいいのかな？　ちょっと測ってみないとわからないですね。</p>\n<p>ひょっとしたら、Hacker&#39;s delight的なうまい方法がある、かもしれません。</p>\n<h1>\n        <span id=\"1-11\" class=\"fragment\"></span>\n        <a href=\"#1-11\"><i class=\"fa fa-link\"></i></a>パースフォレスト\n      </h1><p>パースフォレストについては、OCamlのSetのようなデータ構造がわかっていればだいたいそれと同じなので、直球で書くだけです。Vertex一つが基本的にはNode一つへのポインタを持っています。OCamlのSetなどと一つ違うのは、Vertexを統合した場合にはNodeが複数の値を持つことがある点です。</p>\n<h1>\n        <span id=\"1-12\" class=\"fragment\"></span>\n        <a href=\"#1-12\"><i class=\"fa fa-link\"></i></a>書き直し\n      </h1><p>以上で大体動くようにはなりましたが、ここまで書いた時点でSliceという概念とVertexという概念が独立して存在している意義を見失ったので、統合してSliceという概念を削除し、書き直しました。パーサ＝スタック(トップ)です。「現在生きているパーサ」は「parser.heads」になりました。型はVertexです。</p>\n<h1>\n        <span id=\"1-13\" class=\"fragment\"></span>\n        <a href=\"#1-13\"><i class=\"fa fa-link\"></i></a>ソース\n      </h1><p><a href=\"https://gist.github.com/jonigata/10481869\" title=\"\" target=\"_blank\">こちら</a>に、caperのGLR/js出力を載せておきました。ご興味のある方はどうぞ。state_*, gotof_*のあたりは機械的に展開されたテーブルですので、読み飛ばして大丈夫です。統合の処理はいまのところちょっと冗長です。</p>\n<h1>\n        <span id=\"1-14\" class=\"fragment\"></span>\n        <a href=\"#1-14\"><i class=\"fa fa-link\"></i></a>GLRの問題\n      </h1><p>さて、GLRには、実用にあたって、実装難易度と速度以外にも幾つか問題点があります。いったいそれはなんでしょうか？　ちょっと長くなりすぎましたので、また次回としたいと思います。</p>\n",
        "stock_users": [
            "iwadon",
            "Reds",
            "kasumani",
            "norahiko"
        ]
    },
    {
        "id": 49731,
        "uuid": "5d69cbe02eafac6196ac",
        "user": {
            "id": 1988,
            "url_name": "kametaro",
            "profile_image_url": "https://pbs.twimg.com/profile_images/53236277/pengin_02_normal.gif"
        },
        "title": "メタマジック・ゲームからハノイの塔写経",
        "created_at": "2014-03-06 00:20:26 +0900",
        "updated_at": "2014-03-06 00:20:26 +0900",
        "created_at_in_words": "7ヶ月",
        "updated_at_in_words": "7ヶ月",
        "tags": [
            {
                "name": "Scheme",
                "url_name": "scheme",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/b1fb74e3610feb2020a403cd0eab2cebdd217f10/medium.jpg?1399021725",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            }
        ],
        "stock_count": 0,
        "comment_count": 0,
        "url": "http://qiita.com/kametaro/items/5d69cbe02eafac6196ac",
        "created_at_as_seconds": 1394032826,
        "tweet": false,
        "gist_url": null,
        "private": false,
        "raw_body": "\n\n```\n\n(define carry-one-disk\n  (lambda (sn dn)\n\t(string-append sn dn)))\n\n(define move-tower\n  (lambda (n sn dn hn)\n\t(cond ((= n 1) (carry-one-disk sn dn))\n\t\t  (else (list (move-tower (sub1 n) sn hn dn)\n\t\t\t\t\t  (carry-one-disk sn dn)\n\t\t\t\t\t  (move-tower (sub1 n) hn dn sn))))))\n\n\n(define carry-one-disk-flatten\n  (lambda (sn dn)\n\t(list (string-append sn dn))))\n\n(define move-tower-flatten\n  (lambda (n sn dn hn)\n\t(cond ((= n 1) (carry-one-disk-flatten sn dn))\n\t\t  (else (append (move-tower-flatten (sub1 n) sn hn dn)\n\t\t\t\t\t  (carry-one-disk-flatten sn dn)\n\t\t\t\t\t  (move-tower-flatten (sub1 n) hn dn sn))))))\n\n\n```",
        "body": "<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>(define carry-one-disk\n  (lambda (sn dn)\n    (string-append sn dn)))\n\n(define move-tower\n  (lambda (n sn dn hn)\n    (cond ((= n 1) (carry-one-disk sn dn))\n          (else (list (move-tower (sub1 n) sn hn dn)\n                      (carry-one-disk sn dn)\n                      (move-tower (sub1 n) hn dn sn))))))\n\n\n(define carry-one-disk-flatten\n  (lambda (sn dn)\n    (list (string-append sn dn))))\n\n(define move-tower-flatten\n  (lambda (n sn dn hn)\n    (cond ((= n 1) (carry-one-disk-flatten sn dn))\n          (else (append (move-tower-flatten (sub1 n) sn hn dn)\n                      (carry-one-disk-flatten sn dn)\n                      (move-tower-flatten (sub1 n) hn dn sn))))))\n</pre></div></div>",
        "stock_users": []
    },
    {
        "id": 45735,
        "uuid": "07ba4ff11bff494dc03f",
        "user": {
            "id": 6090,
            "url_name": "guicho271828",
            "profile_image_url": "https://pbs.twimg.com/profile_images/378800000809306716/dbd9008f86c426eb255aadb7fb0b9769_normal.jpeg"
        },
        "title": "Macro System: Common Lisp is still hard to satisfy. (english)",
        "created_at": "2014-02-15 15:58:33 +0900",
        "updated_at": "2014-02-16 09:32:14 +0900",
        "created_at_in_words": "7ヶ月",
        "updated_at_in_words": "7ヶ月",
        "tags": [
            {
                "name": "common-lisp",
                "url_name": "common-lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/745b73901dc247fd2b064c1766a7bcd8037cd5a7/medium.jpg?1364838584",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            },
            {
                "name": "アルゴリズム",
                "url_name": "%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/a8b610e5601d4adba9dc33dd95be3be00ce1800d/medium.jpg?1387910607",
                "versions": []
            }
        ],
        "stock_count": 1,
        "comment_count": 0,
        "url": "http://qiita.com/guicho271828/items/07ba4ff11bff494dc03f",
        "created_at_as_seconds": 1392447513,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "# Abstract\n\nMacro is one of the most characteristic feature of the Lisp-family of languages which allows the higher level of abstraction by extending the syntax of the language. If a head of an S-expression specifies a macro, then the whole expression, which is a list, are passed to the corresponding macro-function and it replaces the original expression with the new list returned by the function. This expansion, or *compilation*, is done from the root to the leaf in a iterative manner.\n\nIn this article, we show the current limit of the macro system in ANSI Common Lisp. We also show an alternative macro expansion system which overcomes the limitation.\n\nThe rest of the article is organized as follows: we first briefly review the basic usage of macro and its behavior. We also investigate the behavior of the interpreter in `sbcl` in order to see how macros are processed during the code traversal (for evaluation or bytecode/native compilation). Based on these introductions, we then show that the current macro system is not able to give a clean implementation of certain kinds of *local macros* in `iterate`, and we introduce a notion of *compile-time continuation* as well as showing how it overcomes the problem.\n\nIn *Related Works*, we see the current implementation of `iterate`. We also briefly introduce a now somewhat forgotten [*expression passing style* by Dybvig](http://www.cs.indiana.edu/l/www/pub/techreports/TR195.pdf) as a similar concept.\n\n# Preliminaries\n\n(I assume everyone reading this article are already familiar with macros, so I just explain it very briefly)\n\nMacros, functions and variables related to Macro System:\n\n```cl\n(defmacro name lambda-list &body body)\n(macrolet bindings &body body)\n(eval form)\n(compile name definition)\n(macroexpand form &optional env)\n(macroexpand-1 form &optional env)\n*macroexpand-hook*\n```\n\nFunctions provided by CLtL2, which allows the manipulation of the environments:\n\n```cl\nAUGMENT-ENVIRONMENT\nCOMPILER-LET\nDECLARATION-INFORMATION\nDEFINE-DECLARATION\nENCLOSE\nFUNCTION-INFORMATION\nPARSE-MACRO\nVARIABLE-INFORMATION\n```\n\n\n# Basic Usage of Macros and its Behavior\n\nMacro functions are essentially functions which takes a list (form) and an environment, and return a new list (form).  They can be defined via `defmacro` . `defmacro` is almost like `defun` but stores the function in a `macro-function` namespace. At the lowest level, an S-expression is expanded via `macroexpand-1` .\n\n```cl\n(macroexpand-1 form &optional env) -> expansion, expanded-p\n```\n\n> If form is a macro form, then the `expansion` is a macro expansion and `expanded-p` is true. Otherwise, the `expansion` is the given form and `expanded-p` is false. \n> [CLHS macroexpand-1](http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_macroexpa_acroexpand-1.html)\n\nIf a head of an S-expression specifies a macro, which means the form is a *macro form*, then the whole expression, which is a list, are passed to the corresponding macro-function and it replaces the original expression with the new list returned by the function.\n\nIn the example below, the `*form*` begins with `let` and it is a *special form*, so `macroexpand-1` does nothing.\n\n```cl\n(defmacro my-unless (condition &body body)\n  `(when (not ,condition)\n     ,@body))\n\n(defparameter *form*\n  `(let ((x 5))\n     (my-unless (plusp x)\n       (print :minus))))\n\n(macroexpand-1 *form*)\n; -->\n;  (LET ((X 5))\n;    (MY-UNLESS (PLUSP X)\n;      (PRINT :MINUS)))\n;  NIL\n```\n\nThe next example, however, contains a *macro form* directly:\n\n```cl\n(defparameter *form2*\n  `(my-unless (plusp x)\n      (print :minus)))\n```\n\nand if it is passed to `macroexpand-1`, it expands the definition:\n\n\n```cl\n(macroexpand-1 *form2*)\n;; -->\n;; (WHEN (NOT (PLUSP X)) (PRINT :MINUS))\n;; T\n```\n\nAs a result, `when` appears as defined in `my-unless`. The secondary value is `T` because the expansion was done. Furthermore, since `when` is again a macro, the repeated expansion gives the following results:\n\n```cl\n(macroexpand-1 (macroexpand-1 *form2*))\n;; ->\n;; (IF (NOT (PLUSP X))\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; T\n(macroexpand-1 (macroexpand-1 (macroexpand-1 *form2*)))\n;; ->\n;; (IF (NOT (PLUSP X))          ; no expansion\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; NIL\n```\n\nAs a result of the third expansion, `if` being a *special operator*, not a macro, the expansion stops and the secondary value is `NIL`.\n\n`macroexpand` repeatedly expands a form using `macroexpand-1`, watching its secondary Boolean return value. It stops the expansion when it see `NIL` in the secondary value in the first time.\n\n```cl\n(macroexpand *form2*)\n;; -->\n;; (IF (NOT (PLUSP X))\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; T\n```\n\nNote that `macroexpand` does *not* expands the inner nodes: it expands only the *root node* of the S-expression syntax tree.\n\n```cl\n(macroexpand *form*)\n;; -->\n;;  (LET ((X 5))\n;;    (MY-UNLESS (PLUSP X)\n;;      (PRINT :MINUS)))\n;;   NIL\n```\n\n\n# Code Expansion during the Traversal\n\nIn the previous section, we saw that `macroexpand` expands the root node only. If so, when and how the inner nodes are expanded?\n\nThe code of `eval` helps us investigate the behavior of macro expansion. `eval` interprets and executes a form, but the word `interpreter` is sometimes *misinterpreted* as if it does not do any compilation --- which actually does. It doesn't run a byte-code/native-code compilation, but macros are always expanded, as described in [CLHS 3. Evaluation and Compilation](http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/chap-3.html).\n\nTalking about which implementation of `eval` to investigate, we see `eval` in `sb-eval`, which is included in the recent `sbcl`. `sbcl` and other implementations with `python` native compiler is known to have *always-compile* strategy, but if we set `sb-eval:*evaluator-mode*` to `:interpret`, we get a true interpreter.\n\n```cl\nCL-USER> (setf *evaluator-mode* :interpret) \n; --> :INTERPRET\n```\n\nOK, let's see what's happening inside `eval`:\n\n```cl\n(defun eval (original-exp)\n  (eval-in-lexenv original-exp (make-null-lexenv)))\n\n;; ↓\n\n(defun eval-in-lexenv (exp lexenv)\n  (if (eq *evaluator-mode* :compile)\n      ...\n      (sb!eval:eval-in-native-environment exp lexenv)))\n\n;; ↓ \n\n(defun eval-in-native-environment (form lexenv)\n  (handler-bind\n      ((sb!impl::eval-error ...))\n      ...\n      (%eval form env)))\n\n;; ↓\n\n(defun %eval (exp env)\n  ...\n  (%%eval exp env))\n\n;; ↓\n```\n\nits sooo heavily nested. well, well,...\n\n```cl\n(defun %%eval (exp env)\n  (cond\n    ((symbolp exp)\n     ;; CLHS 3.1.2.1.1 Symbols as Forms\n     (multiple-value-bind (value kind) (get-variable exp env)\n       (ecase kind\n         (:variable value)\n         (:expansion (%eval value env)))))\n    ;; CLHS 3.1.2.1.3 Self-Evaluating Objects\n    ((atom exp) exp)\n    ;; CLHS 3.1.2.1.2 Conses as Forms\n    ((consp exp)\n     (case (car exp)\n       ;; CLHS 3.1.2.1.2.1 Special Forms\n       ((block)                (eval-block (cdr exp) env))\n       ((catch)                (eval-catch (cdr exp) env))\n       ;;\n       ;; 20 or more special forms **skipped**\n       ;; \n       (t\n        (let ((dispatcher (getf *eval-dispatch-functions* (car exp))))\n          (cond\n            (dispatcher ; for cltl2:compiler-let\n             (funcall dispatcher exp env))\n            ;; CLHS 3.1.2.1.2.4 Lambda Forms\n            ((and (consp (car exp)) (eq (caar exp) 'lambda))\n             (interpreted-apply (eval-function (list (car exp)) env)\n                                (eval-args (cdr exp) env)))\n            (t\n             (multiple-value-bind (function kind) (get-function (car exp) env)\n               (ecase kind\n                 ;; CLHS 3.1.2.1.2.3 Function Forms\n                 (:function (%apply function (eval-args (cdr exp) env)))\n                 ;; CLHS 3.1.2.1.2.2 Macro Forms\n                 (:macro\n                  ;; ** This is what we want **\n                  )))))))))))\n```\n\nExtracting only those part we are interested in, then it is:\n\n```cl\n(let ((hook *macroexpand-hook*)) ; hook = funcall by default\n  (%eval (funcall hook\n                  function\n                  exp\n                  (env-native-lexenv env))\n         env))\n```\n\nWe see that the evaluator first expand the macro (root node only) and then evaluate the expansion again.\n\n## The Call Stack\n\nGiven above implementation of `eval`, let's review the behavior of the call stack during the evaluation. And we get the following:\n\n```cl\n;; the code to be evaluated:\n(let ((x 5))\n  (my-unless (plusp x)\n    (print :minus)))\n\n;; the expansion\n(let ((x 5))\n  (IF (NOT (PLUSP X))\n      (PROGN (PRINT :MINUS))\n      NIL))\n\n;; call stack\n(eval            ; let\n (eval           ; my-unless\n  (macroexpand)  ; my-unless -> when -> if\n  (eval          ; if\n    (eval-if       ; if\n     (eval (eval)) ; (not (plusp x))\n     (eval))))     ; (progn ...) or NIL\n```\n\nWe see a `macroexpand` during the evaluation. That's good.  Then, what if the code needs the macro expansion twice?  Here it is.\n\n```cl\n;; the code to be evaluated:\n(my-unless (plusp x)\n  (my-unless (minusp x)\n    (print :zero)))  \n\n;; the expansion\n(IF (NOT (PLUSP X))\n    (PROGN\n     (IF (NOT (MINUSP X))\n         (PROGN (PRINT :ZERO))\n         NIL))\n    NIL)\n\n;; call stack\n(eval               ; my-unless\n (macroexpand)      ; my-unless -> when -> if\n (eval              ; if\n  (eval-if            ;if\n    (eval             ; (not (plusp))\n     (eval            ; my-unless\n      (macroexpand)   ; my-unless -> when -> if\n      (eval ...)))))  ; if ...\n```\n\nNow, notice that each expansion is called independently -- the information of outer expansion is not on the stack when the inner expansion occurs. This leads to the fundamental problem shown in the next section.\n\n# Local Macros -- with macrolet --\n\nThe above behavior somewhat inhibits the easy implementation of some *smart* local macros. Local macros? Why not use just `macrolet` ??\n\nWe describe the reason by implementing the simple version of `iterate`. It has a syntax as shown below:\n\n```cl\n    ;; inside `iter`, `while` continues the execution only when the argument is true.\n    ;; `collect` accumulate its argument into a list and make `iter` return the accumulated result.\n    ;; `while` and `collect` signals an error outside `iter`.\n    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (collect (+ 3 (* 4 i)))))\n```\n\nLet's implement it with `macrolet`.  It is possible, clean and simple.\n    \n```cl    \n    (define-condition compile-error (simple-error)\n      ((message :initarg :message :accessor message))\n      (:report (lambda (c s)\n                 (princ (message c) s))))\n    \n    (defmacro collect (x)\n      (declare (ignore x))\n      (error 'compile-error\n             :message \"`collect' must be used under `iter'\"))\n    \n    (defmacro while (x)\n      (declare (ignore x))\n      (error 'compile-error\n             :message \"`while' must be used under `iter'\"))\n    \n    (require :alexandria)\n    (use-package :alexandria)\n    \n    (defmacro iter (&body body)\n      (with-gensyms (iter-block accumulate start)\n        `(block ,iter-block\n           (let ((,accumulate nil))\n             (macrolet ((while (condition)\n                          `(unless ,condition\n                             (return-from ,',iter-block\n                               (nreverse ,',accumulate))))\n                        (collect (thing)\n                          `(push ,thing ,',accumulate)))\n               (tagbody\n                 ,start\n                 ,@body\n                 (go ,start)))))))\n    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (collect (+ 3 (* 4 i)))))\n    \n    ;; --> (7 11 15 19 23)\n```\n\nWorked well. Sounds good. What's the problem?\n\nOK, then go further: let's implement `(collect x into acc)` feature in the original `iterate` . It allows users to specify the name of the list that the elements are accumulated. But again, only with macrolet.\n\n```    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc) ; <--\n            (collect (+ 3 (* 4 i)) :into acc))) ; <--\n```\n\nWhat now? You may easily encounter a problem: How we safely bind the symbol `acc`? Without destructing the global environment?\n\nIn order to bind a variable safely, we need to wrap the entire loop with `let` . The problem exists here: the `collect` clause are expanded **only after the expansion of iter** . The bad thing is, we have no way behind -- backtracking the expansion is impossible. No method to go back to the pre-expansion state.\n\n# Macros in Common Lisp are still *restricted*\n\nHere resides the crucial problem in the macro system in Common Lisp.\n\n**Expansion is done iteratively, not recursively**\n\nEven CLHS writes:\n\n>  macroexpand **repeatedly** expands form until it is no longer a macro form. In effect, macroexpand calls macroexpand-1 repeatedly until the secondary value it returns is nil. -- [CLHS Function MACROEXPAND, MACROEXPAND-1](http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_macroexpa_acroexpand-1.html)\n\nIf the previous expansion context is on the stack, we can signal an error and backtrack the expansion like:\n\n```cl\n    (collect (thing &key into)\n      (if into\n          (error 'accumulate-target :name into) ; Compile it again!\n          `(push ,thing ,',accumulate)))\n```\n\nand the handler in the `iter` might catch the signal.\n\nHypothetical implementation following such a macro system is shown below. In `defmacro`, we have additional argument `&continuation cont` that takes a closure which continue the expansion of the inner clauses. If a condition is signaled from the upper stack, then it is handled by the handler here and it recompile the whole clause again.\n\n```cl\n   (defmacro iter (&body body &continuation cont)\n      (with-gensyms (iter-block accumulate start)\n        (handler-case\n            (funcall #'cont\n                     `(block ,iter-block\n                        (let ((,accumulate nil))\n                          (macrolet ((while (condition)\n                                       `(unless ,condition\n                                          (return-from ,',iter-block\n                                            (nreverse ,',accumulate))))\n                                     (collect (thing &key into)\n                                       (if into\n                                           (signal 'accumulate-target :name into)\n                                           `(push ,thing ,',accumulate))))\n                            (tagbody\n                              ,start\n                              ,@body\n                              (go ,start))))))\n          ;; handler\n          (accumulate-target (c)\n            (setf accumulate (name c))\n            (funcall #'cont\n                     `(block ,iter-block\n                        (let ((,accumulate nil))\n                          (macrolet ((while (condition)\n                                       `(unless ,condition\n                                          (return-from ,',iter-block\n                                            (nreverse ,',accumulate))))\n                                     (collect (thing &key into)\n                                       `(push ,thing ,',accumulate)))\n                            (tagbody\n                              ,start\n                              ,@body\n                              (go ,start))))))))))\n```\n\nWe refer to this continuation `cont` as *compile-time continuation* because it is a continuation intended to be used in a macro expansion. These style itself is called as `Expression Passing Style` according to [*expression passing style* by Dybvig](http://www.cs.indiana.edu/l/www/pub/techreports/TR195.pdf) because it passes a sub-expression to the continuation. However, since the paper assumes a scheme-like system in describing the concept, the direct application to Common Lisp is not possible.\n\n# Related Works\n\nThe original `iterate`, however, does not handle the problem in this way. It rather has its own code walker to detect all `(collect ... into ...)` *prior to* the expansion of `iter`. This is clearly a dirty workaround -- consider a case that a `collect` clause is hidden in a expansion of another macro:\n\n```cl\n    ;; `collect` clause hidden in a macro\n    (defmacro my-collect (&rest args)\n      `(collect ,@args))\n    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc)\n            (my-collect (+ 3 (* 4 i)) into acc)))\n```\n\nIn order to detect all `collect` clause in any macro expansion, the code walker in `iterate` expands all macro inside the body of `iter`. This is dirty -- and has indeed a critical limitation:\n\n```cl\n    (require :iterate)\n    (in-package :iterate)\n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc)\n            (macrolet ((my-collect (&rest args)\n                         `(collect ,@args)))\n              (my-collect (+ 3 (* 4 i)) into acc))))\n    \n    ; in: LET ((I 0)) ...\n    ; \n    ; caught WARNING:\n    ;   Iterate:\n    ;   Iterate does not know how to handle \n    ;     the special form (MACROLET ...)\n    ;   It will not be walked, which means that Iterate clauses\n    ;   inside it will not be seen.\n    ;\n    ; compilation unit finished\n    ;   Undefined function:\n    ;     COLLECT\n    ;   Undefined variables:\n    ;     ACC INTO\n```\n\nThis is essentially a problem in ANSI CL. Theoretically, `augment-environment` and `parse-macro` defined in cltl2 allows the code walker to expand those clauses. The behavior may be the result of historical issue.\n\n> [Function] augment-environment env &key\n> \n> :variable :symbol-macro :function :macro :declare\n> \n> :macro\n> \n> The argument is a list of local macro definitions, each of the form (name definition). Note that the argument is **not** in the same format as the cadr of a macrolet special form. Each definition must be a function of two arguments (a form and an environment). The new environment will have local macro bindings of each name to the corresponding expander function, which will be returned by macro-function and used by macroexpand.\n>\n> [CLTL2 8.5 Environment](http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node102.html)\n\n```cl\n    (defmacro iter (... &environment env)\n      ...\n      (walk-code ... env))\n    \n    (defun walk-code (form env)\n      ...\n      (when (eq 'macrolet (car form))\n        (destructuring-bind (car macros . body) form\n          (declare (ignore car))\n          (walk-code\n            `(progn ,@body)\n            (augment-environment\n             env\n             :macro (mapcar (rcurry #'parse-macro env) macros))))))\n```\n\nWell, well, however, is it clever to implement such a code walker? We have lots of special forms `let,tagbody,block,catch` which are already correctly handled by the implementation, and possibly some other implementation-dependent special forms (in sbcl, `sb!ext:truly-the` and `sb!sys:with-pinned-objects`). Isn't it just re-implementing those feature by hand? Quite *un*clever, isn't it? (no offence, I don't mean to insult iterate's author - I love it, but its implementation is badly affected by the design of the macro system in CL.)\n\nAlso, the code processed by `walk-code` is traversed again by the bytecode/native compiler, or an evaluator. They search for macro forms again, with similar implementation to that of `walk-code` -- it's just inefficient.\n\n```cl\n    (eval            ; let\n     (eval           ; iter\n      (macroexpand)  ; expand `iter`, calling `walk-code` inside it\n      (eval)))       ; `eval` traverse the body again\n```\n\nAnother aspect of the problem is here.\n\n\n```cl\n    (let ((x 0))\n      (let ((y x))\n        (declare (fixnum y))\n        ...))\n```\n\n`let` is not a macro, but assume it is one.  In this example, `y` is declared to be a fixnum.  However, *humans easily know that* `y` is directly copied from `x` and `x` is unmodified -- you want the compiler to automatically deduce `x` to be a fixnum, don't you? By **backtracking the expansion?**\n\nThe core problem of current macro system is essentially the following: it is not able to propagate the **inner** constraints to the **outer** environment.  Communications between the outer and the inner macros are virtually impossible. As a result, such tasks tend to be handled by a implementation specific extensions such as `deftransform` in sbcl.\n\n# Conclusion\n\nCurrent macro system calls expansions and traversals independently, which does not allow the backtracking during the macro expansion.  It inhibits the communication between the inner and outer macros, especially from the former(inside) to the latter(outside), thus restricting the ability of macros in general.\n\nIn this article, we proposed a recursive macro system with a notion of `compile-time continuation`, which is a closure of one argument and when called with a form it continues the traversal and expand of the subforms. We also showed its benefit i.e. such system potentially has a more easy-to-use interface for a constraint propagation from the inner to the outer code.\n\nComments are welcome.\n",
        "body": "<h1>\n        <span id=\"1-1\" class=\"fragment\"></span>\n        <a href=\"#1-1\"><i class=\"fa fa-link\"></i></a>Abstract\n      </h1><p>Macro is one of the most characteristic feature of the Lisp-family of languages which allows the higher level of abstraction by extending the syntax of the language. If a head of an S-expression specifies a macro, then the whole expression, which is a list, are passed to the corresponding macro-function and it replaces the original expression with the new list returned by the function. This expansion, or <em>compilation</em>, is done from the root to the leaf in a iterative manner.</p>\n<p>In this article, we show the current limit of the macro system in ANSI Common Lisp. We also show an alternative macro expansion system which overcomes the limitation.</p>\n<p>The rest of the article is organized as follows: we first briefly review the basic usage of macro and its behavior. We also investigate the behavior of the interpreter in <code>sbcl</code> in order to see how macros are processed during the code traversal (for evaluation or bytecode/native compilation). Based on these introductions, we then show that the current macro system is not able to give a clean implementation of certain kinds of <em>local macros</em> in <code>iterate</code>, and we introduce a notion of <em>compile-time continuation</em> as well as showing how it overcomes the problem.</p>\n<p>In <em>Related Works</em>, we see the current implementation of <code>iterate</code>. We also briefly introduce a now somewhat forgotten <a href=\"http://www.cs.indiana.edu/l/www/pub/techreports/TR195.pdf\" title=\"\" target=\"_blank\"><em>expression passing style</em> by Dybvig</a> as a similar concept.</p>\n<h1>\n        <span id=\"1-2\" class=\"fragment\"></span>\n        <a href=\"#1-2\"><i class=\"fa fa-link\"></i></a>Preliminaries\n      </h1><p>(I assume everyone reading this article are already familiar with macros, so I just explain it very briefly)</p>\n<p>Macros, functions and variables related to Macro System:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">name</span> <span class=\"nv\">lambda-list</span> <span class=\"k\">&amp;body</span> <span class=\"nv\">body</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"k\">macrolet</span> <span class=\"nv\">bindings</span> <span class=\"k\">&amp;body</span> <span class=\"nv\">body</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">eval</span> <span class=\"nv\">form</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">compile</span> <span class=\"nv\">name</span> <span class=\"nv\">definition</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">macroexpand</span> <span class=\"nv\">form</span> <span class=\"k\">&amp;optional</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"nv\">form</span> <span class=\"k\">&amp;optional</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n<span class=\"vg\">*macroexpand-hook*</span>\n</pre></div></div><p>Functions provided by CLtL2, which allows the manipulation of the environments:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"nv\">AUGMENT-ENVIRONMENT</span>\n<span class=\"nv\">COMPILER-LET</span>\n<span class=\"nv\">DECLARATION-INFORMATION</span>\n<span class=\"nv\">DEFINE-DECLARATION</span>\n<span class=\"nv\">ENCLOSE</span>\n<span class=\"nv\">FUNCTION-INFORMATION</span>\n<span class=\"nv\">PARSE-MACRO</span>\n<span class=\"nv\">VARIABLE-INFORMATION</span>\n</pre></div></div><h1>\n        <span id=\"1-3\" class=\"fragment\"></span>\n        <a href=\"#1-3\"><i class=\"fa fa-link\"></i></a>Basic Usage of Macros and its Behavior\n      </h1><p>Macro functions are essentially functions which takes a list (form) and an environment, and return a new list (form).  They can be defined via <code>defmacro</code> . <code>defmacro</code> is almost like <code>defun</code> but stores the function in a <code>macro-function</code> namespace. At the lowest level, an S-expression is expanded via <code>macroexpand-1</code> .</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"nv\">form</span> <span class=\"k\">&amp;optional</span> <span class=\"nv\">env</span><span class=\"p\">)</span> <span class=\"nv\">-&gt;</span> <span class=\"nv\">expansion,</span> <span class=\"nv\">expanded-p</span>\n</pre></div></div>\n<blockquote>\n<p>If form is a macro form, then the <code>expansion</code> is a macro expansion and <code>expanded-p</code> is true. Otherwise, the <code>expansion</code> is the given form and <code>expanded-p</code> is false. <br>\n<a href=\"http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_macroexpa_acroexpand-1.html\" title=\"\" target=\"_blank\">CLHS macroexpand-1</a></p>\n</blockquote>\n<p>If a head of an S-expression specifies a macro, which means the form is a <em>macro form</em>, then the whole expression, which is a list, are passed to the corresponding macro-function and it replaces the original expression with the new list returned by the function.</p>\n<p>In the example below, the <code>*form*</code> begins with <code>let</code> and it is a <em>special form</em>, so <code>macroexpand-1</code> does nothing.</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"kt\">condition</span> <span class=\"k\">&amp;body</span> <span class=\"nv\">body</span><span class=\"p\">)</span>\n  <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">when</span> <span class=\"p\">(</span><span class=\"nb\">not</span> <span class=\"o\">,</span><span class=\"kt\">condition</span><span class=\"p\">)</span>\n     <span class=\"o\">,@</span><span class=\"nv\">body</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defparameter</span> <span class=\"vg\">*form*</span>\n  <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">x</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n     <span class=\"p\">(</span><span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"nb\">plusp</span> <span class=\"nv\">x</span><span class=\"p\">)</span>\n       <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"ss\">:minus</span><span class=\"p\">))))</span>\n\n<span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"vg\">*form*</span><span class=\"p\">)</span>\n<span class=\"c1\">; --&gt;</span>\n<span class=\"c1\">;  (LET ((X 5))</span>\n<span class=\"c1\">;    (MY-UNLESS (PLUSP X)</span>\n<span class=\"c1\">;      (PRINT :MINUS)))</span>\n<span class=\"c1\">;  NIL</span>\n</pre></div></div><p>The next example, however, contains a <em>macro form</em> directly:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defparameter</span> <span class=\"vg\">*form2*</span>\n  <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"nb\">plusp</span> <span class=\"nv\">x</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"ss\">:minus</span><span class=\"p\">)))</span>\n</pre></div></div><p>and if it is passed to <code>macroexpand-1</code>, it expands the definition:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"vg\">*form2*</span><span class=\"p\">)</span>\n<span class=\"c1\">;; --&gt;</span>\n<span class=\"c1\">;; (WHEN (NOT (PLUSP X)) (PRINT :MINUS))</span>\n<span class=\"c1\">;; T</span>\n</pre></div></div><p>As a result, <code>when</code> appears as defined in <code>my-unless</code>. The secondary value is <code>T</code> because the expansion was done. Furthermore, since <code>when</code> is again a macro, the repeated expansion gives the following results:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"vg\">*form2*</span><span class=\"p\">))</span>\n<span class=\"c1\">;; -&gt;</span>\n<span class=\"c1\">;; (IF (NOT (PLUSP X))</span>\n<span class=\"c1\">;;     (PROGN (PRINT :MINUS))</span>\n<span class=\"c1\">;;     NIL)</span>\n<span class=\"c1\">;; T</span>\n<span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"vg\">*form2*</span><span class=\"p\">)))</span>\n<span class=\"c1\">;; -&gt;</span>\n<span class=\"c1\">;; (IF (NOT (PLUSP X))          ; no expansion</span>\n<span class=\"c1\">;;     (PROGN (PRINT :MINUS))</span>\n<span class=\"c1\">;;     NIL)</span>\n<span class=\"c1\">;; NIL</span>\n</pre></div></div><p>As a result of the third expansion, <code>if</code> being a <em>special operator</em>, not a macro, the expansion stops and the secondary value is <code>NIL</code>.</p>\n<p><code>macroexpand</code> repeatedly expands a form using <code>macroexpand-1</code>, watching its secondary Boolean return value. It stops the expansion when it see <code>NIL</code> in the secondary value in the first time.</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">macroexpand</span> <span class=\"vg\">*form2*</span><span class=\"p\">)</span>\n<span class=\"c1\">;; --&gt;</span>\n<span class=\"c1\">;; (IF (NOT (PLUSP X))</span>\n<span class=\"c1\">;;     (PROGN (PRINT :MINUS))</span>\n<span class=\"c1\">;;     NIL)</span>\n<span class=\"c1\">;; T</span>\n</pre></div></div><p>Note that <code>macroexpand</code> does <em>not</em> expands the inner nodes: it expands only the <em>root node</em> of the S-expression syntax tree.</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">macroexpand</span> <span class=\"vg\">*form*</span><span class=\"p\">)</span>\n<span class=\"c1\">;; --&gt;</span>\n<span class=\"c1\">;;  (LET ((X 5))</span>\n<span class=\"c1\">;;    (MY-UNLESS (PLUSP X)</span>\n<span class=\"c1\">;;      (PRINT :MINUS)))</span>\n<span class=\"c1\">;;   NIL</span>\n</pre></div></div><h1>\n        <span id=\"1-4\" class=\"fragment\"></span>\n        <a href=\"#1-4\"><i class=\"fa fa-link\"></i></a>Code Expansion during the Traversal\n      </h1><p>In the previous section, we saw that <code>macroexpand</code> expands the root node only. If so, when and how the inner nodes are expanded?</p>\n<p>The code of <code>eval</code> helps us investigate the behavior of macro expansion. <code>eval</code> interprets and executes a form, but the word <code>interpreter</code> is sometimes <em>misinterpreted</em> as if it does not do any compilation --- which actually does. It doesn&#39;t run a byte-code/native-code compilation, but macros are always expanded, as described in <a href=\"http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/chap-3.html\" title=\"\" target=\"_blank\">CLHS 3. Evaluation and Compilation</a>.</p>\n<p>Talking about which implementation of <code>eval</code> to investigate, we see <code>eval</code> in <code>sb-eval</code>, which is included in the recent <code>sbcl</code>. <code>sbcl</code> and other implementations with <code>python</code> native compiler is known to have <em>always-compile</em> strategy, but if we set <code>sb-eval:*evaluator-mode*</code> to <code>:interpret</code>, we get a true interpreter.</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"nv\">CL-USER&gt;</span> <span class=\"p\">(</span><span class=\"nb\">setf</span> <span class=\"vg\">*evaluator-mode*</span> <span class=\"ss\">:interpret</span><span class=\"p\">)</span> \n<span class=\"c1\">; --&gt; :INTERPRET</span>\n</pre></div></div><p>OK, let&#39;s see what&#39;s happening inside <code>eval</code>:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nb\">eval</span> <span class=\"p\">(</span><span class=\"nv\">original-exp</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nv\">eval-in-lexenv</span> <span class=\"nv\">original-exp</span> <span class=\"p\">(</span><span class=\"nv\">make-null-lexenv</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">;; ↓</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">eval-in-lexenv</span> <span class=\"p\">(</span><span class=\"nb\">exp</span> <span class=\"nv\">lexenv</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">eq</span> <span class=\"vg\">*evaluator-mode*</span> <span class=\"ss\">:compile</span><span class=\"p\">)</span>\n      <span class=\"o\">...</span>\n      <span class=\"p\">(</span><span class=\"nv\">sb!eval:eval-in-native-environment</span> <span class=\"nb\">exp</span> <span class=\"nv\">lexenv</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">;; ↓ </span>\n\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">eval-in-native-environment</span> <span class=\"p\">(</span><span class=\"nv\">form</span> <span class=\"nv\">lexenv</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nb\">handler-bind</span>\n      <span class=\"p\">((</span><span class=\"nv\">sb!impl::eval-error</span> <span class=\"o\">...</span><span class=\"p\">))</span>\n      <span class=\"o\">...</span>\n      <span class=\"p\">(</span><span class=\"nv\">%eval</span> <span class=\"nv\">form</span> <span class=\"nv\">env</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">;; ↓</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">%eval</span> <span class=\"p\">(</span><span class=\"nb\">exp</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n  <span class=\"o\">...</span>\n  <span class=\"p\">(</span><span class=\"nv\">%%eval</span> <span class=\"nb\">exp</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; ↓</span>\n</pre></div></div><p>its sooo heavily nested. well, well,...</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">%%eval</span> <span class=\"p\">(</span><span class=\"nb\">exp</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nb\">cond</span>\n    <span class=\"p\">((</span><span class=\"nb\">symbolp</span> <span class=\"nb\">exp</span><span class=\"p\">)</span>\n     <span class=\"c1\">;; CLHS 3.1.2.1.1 Symbols as Forms</span>\n     <span class=\"p\">(</span><span class=\"nb\">multiple-value-bind</span> <span class=\"p\">(</span><span class=\"nv\">value</span> <span class=\"nv\">kind</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">get-variable</span> <span class=\"nb\">exp</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n       <span class=\"p\">(</span><span class=\"nb\">ecase</span> <span class=\"nv\">kind</span>\n         <span class=\"p\">(</span><span class=\"ss\">:variable</span> <span class=\"nv\">value</span><span class=\"p\">)</span>\n         <span class=\"p\">(</span><span class=\"ss\">:expansion</span> <span class=\"p\">(</span><span class=\"nv\">%eval</span> <span class=\"nv\">value</span> <span class=\"nv\">env</span><span class=\"p\">)))))</span>\n    <span class=\"c1\">;; CLHS 3.1.2.1.3 Self-Evaluating Objects</span>\n    <span class=\"p\">((</span><span class=\"nb\">atom</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nb\">exp</span><span class=\"p\">)</span>\n    <span class=\"c1\">;; CLHS 3.1.2.1.2 Conses as Forms</span>\n    <span class=\"p\">((</span><span class=\"nb\">consp</span> <span class=\"nb\">exp</span><span class=\"p\">)</span>\n     <span class=\"p\">(</span><span class=\"nb\">case</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nb\">exp</span><span class=\"p\">)</span>\n       <span class=\"c1\">;; CLHS 3.1.2.1.2.1 Special Forms</span>\n       <span class=\"p\">((</span><span class=\"k\">block</span><span class=\"p\">)</span>                <span class=\"p\">(</span><span class=\"nv\">eval-block</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n       <span class=\"p\">((</span><span class=\"k\">catch</span><span class=\"p\">)</span>                <span class=\"p\">(</span><span class=\"nv\">eval-catch</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n       <span class=\"c1\">;;</span>\n       <span class=\"c1\">;; 20 or more special forms **skipped**</span>\n       <span class=\"c1\">;; </span>\n       <span class=\"p\">(</span><span class=\"no\">t</span>\n        <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">dispatcher</span> <span class=\"p\">(</span><span class=\"nb\">getf</span> <span class=\"vg\">*eval-dispatch-functions*</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nb\">exp</span><span class=\"p\">))))</span>\n          <span class=\"p\">(</span><span class=\"nb\">cond</span>\n            <span class=\"p\">(</span><span class=\"nv\">dispatcher</span> <span class=\"c1\">; for cltl2:compiler-let</span>\n             <span class=\"p\">(</span><span class=\"nb\">funcall</span> <span class=\"nv\">dispatcher</span> <span class=\"nb\">exp</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n            <span class=\"c1\">;; CLHS 3.1.2.1.2.4 Lambda Forms</span>\n            <span class=\"p\">((</span><span class=\"nb\">and</span> <span class=\"p\">(</span><span class=\"nb\">consp</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nb\">exp</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"nb\">eq</span> <span class=\"p\">(</span><span class=\"nb\">caar</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"ss\">&#39;lambda</span><span class=\"p\">))</span>\n             <span class=\"p\">(</span><span class=\"nv\">interpreted-apply</span> <span class=\"p\">(</span><span class=\"nv\">eval-function</span> <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nb\">exp</span><span class=\"p\">))</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n                                <span class=\"p\">(</span><span class=\"nv\">eval-args</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nv\">env</span><span class=\"p\">)))</span>\n            <span class=\"p\">(</span><span class=\"no\">t</span>\n             <span class=\"p\">(</span><span class=\"nb\">multiple-value-bind</span> <span class=\"p\">(</span><span class=\"k\">function</span> <span class=\"nv\">kind</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">get-function</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n               <span class=\"p\">(</span><span class=\"nb\">ecase</span> <span class=\"nv\">kind</span>\n                 <span class=\"c1\">;; CLHS 3.1.2.1.2.3 Function Forms</span>\n                 <span class=\"p\">(</span><span class=\"ss\">:function</span> <span class=\"p\">(</span><span class=\"nv\">%apply</span> <span class=\"k\">function</span> <span class=\"p\">(</span><span class=\"nv\">eval-args</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nv\">env</span><span class=\"p\">)))</span>\n                 <span class=\"c1\">;; CLHS 3.1.2.1.2.2 Macro Forms</span>\n                 <span class=\"p\">(</span><span class=\"ss\">:macro</span>\n                  <span class=\"c1\">;; ** This is what we want **</span>\n                  <span class=\"p\">)))))))))))</span>\n</pre></div></div><p>Extracting only those part we are interested in, then it is:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">hook</span> <span class=\"vg\">*macroexpand-hook*</span><span class=\"p\">))</span> <span class=\"c1\">; hook = funcall by default</span>\n  <span class=\"p\">(</span><span class=\"nv\">%eval</span> <span class=\"p\">(</span><span class=\"nb\">funcall</span> <span class=\"nv\">hook</span>\n                  <span class=\"k\">function</span>\n                  <span class=\"nb\">exp</span>\n                  <span class=\"p\">(</span><span class=\"nv\">env-native-lexenv</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n         <span class=\"nv\">env</span><span class=\"p\">))</span>\n</pre></div></div><p>We see that the evaluator first expand the macro (root node only) and then evaluate the expansion again.</p>\n<h2>\n        <span id=\"2-1\" class=\"fragment\"></span>\n        <a href=\"#2-1\"><i class=\"fa fa-link\"></i></a>The Call Stack\n      </h2><p>Given above implementation of <code>eval</code>, let&#39;s review the behavior of the call stack during the evaluation. And we get the following:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"c1\">;; the code to be evaluated:</span>\n<span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">x</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"nb\">plusp</span> <span class=\"nv\">x</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"ss\">:minus</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">;; the expansion</span>\n<span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">x</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nv\">IF</span> <span class=\"p\">(</span><span class=\"nv\">NOT</span> <span class=\"p\">(</span><span class=\"nv\">PLUSP</span> <span class=\"nv\">X</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">PROGN</span> <span class=\"p\">(</span><span class=\"nv\">PRINT</span> <span class=\"ss\">:MINUS</span><span class=\"p\">))</span>\n      <span class=\"no\">NIL</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; call stack</span>\n<span class=\"p\">(</span><span class=\"nb\">eval</span>            <span class=\"c1\">; let</span>\n <span class=\"p\">(</span><span class=\"nb\">eval</span>           <span class=\"c1\">; my-unless</span>\n  <span class=\"p\">(</span><span class=\"nb\">macroexpand</span><span class=\"p\">)</span>  <span class=\"c1\">; my-unless -&gt; when -&gt; if</span>\n  <span class=\"p\">(</span><span class=\"nb\">eval</span>          <span class=\"c1\">; if</span>\n    <span class=\"p\">(</span><span class=\"nv\">eval-if</span>       <span class=\"c1\">; if</span>\n     <span class=\"p\">(</span><span class=\"nb\">eval</span> <span class=\"p\">(</span><span class=\"nb\">eval</span><span class=\"p\">))</span> <span class=\"c1\">; (not (plusp x))</span>\n     <span class=\"p\">(</span><span class=\"nb\">eval</span><span class=\"p\">))))</span>     <span class=\"c1\">; (progn ...) or NIL</span>\n</pre></div></div><p>We see a <code>macroexpand</code> during the evaluation. That&#39;s good.  Then, what if the code needs the macro expansion twice?  Here it is.</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"c1\">;; the code to be evaluated:</span>\n<span class=\"p\">(</span><span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"nb\">plusp</span> <span class=\"nv\">x</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"nb\">minusp</span> <span class=\"nv\">x</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"ss\">:zero</span><span class=\"p\">)))</span>  \n\n<span class=\"c1\">;; the expansion</span>\n<span class=\"p\">(</span><span class=\"nv\">IF</span> <span class=\"p\">(</span><span class=\"nv\">NOT</span> <span class=\"p\">(</span><span class=\"nv\">PLUSP</span> <span class=\"nv\">X</span><span class=\"p\">))</span>\n    <span class=\"p\">(</span><span class=\"nv\">PROGN</span>\n     <span class=\"p\">(</span><span class=\"nv\">IF</span> <span class=\"p\">(</span><span class=\"nv\">NOT</span> <span class=\"p\">(</span><span class=\"nv\">MINUSP</span> <span class=\"nv\">X</span><span class=\"p\">))</span>\n         <span class=\"p\">(</span><span class=\"nv\">PROGN</span> <span class=\"p\">(</span><span class=\"nv\">PRINT</span> <span class=\"ss\">:ZERO</span><span class=\"p\">))</span>\n         <span class=\"no\">NIL</span><span class=\"p\">))</span>\n    <span class=\"no\">NIL</span><span class=\"p\">)</span>\n\n<span class=\"c1\">;; call stack</span>\n<span class=\"p\">(</span><span class=\"nb\">eval</span>               <span class=\"c1\">; my-unless</span>\n <span class=\"p\">(</span><span class=\"nb\">macroexpand</span><span class=\"p\">)</span>      <span class=\"c1\">; my-unless -&gt; when -&gt; if</span>\n <span class=\"p\">(</span><span class=\"nb\">eval</span>              <span class=\"c1\">; if</span>\n  <span class=\"p\">(</span><span class=\"nv\">eval-if</span>            <span class=\"c1\">;if</span>\n    <span class=\"p\">(</span><span class=\"nb\">eval</span>             <span class=\"c1\">; (not (plusp))</span>\n     <span class=\"p\">(</span><span class=\"nb\">eval</span>            <span class=\"c1\">; my-unless</span>\n      <span class=\"p\">(</span><span class=\"nb\">macroexpand</span><span class=\"p\">)</span>   <span class=\"c1\">; my-unless -&gt; when -&gt; if</span>\n      <span class=\"p\">(</span><span class=\"nb\">eval</span> <span class=\"o\">...</span><span class=\"p\">)))))</span>  <span class=\"c1\">; if ...</span>\n</pre></div></div><p>Now, notice that each expansion is called independently -- the information of outer expansion is not on the stack when the inner expansion occurs. This leads to the fundamental problem shown in the next section.</p>\n<h1>\n        <span id=\"1-5\" class=\"fragment\"></span>\n        <a href=\"#1-5\"><i class=\"fa fa-link\"></i></a>Local Macros -- with macrolet --\n      </h1><p>The above behavior somewhat inhibits the easy implementation of some <em>smart</em> local macros. Local macros? Why not use just <code>macrolet</code> ??</p>\n<p>We describe the reason by implementing the simple version of <code>iterate</code>. It has a syntax as shown below:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"c1\">;; inside `iter`, `while` continues the execution only when the argument is true.</span>\n    <span class=\"c1\">;; `collect` accumulate its argument into a list and make `iter` return the accumulated result.</span>\n    <span class=\"c1\">;; `while` and `collect` signals an error outside `iter`.</span>\n\n    <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">i</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"nv\">i</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">incf</span> <span class=\"nv\">i</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"mi\">3</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mi\">4</span> <span class=\"nv\">i</span><span class=\"p\">)))))</span>\n</pre></div></div><p>Let&#39;s implement it with <code>macrolet</code>.  It is possible, clean and simple.</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"nb\">define-condition</span> <span class=\"nv\">compile-error</span> <span class=\"p\">(</span><span class=\"kt\">simple-error</span><span class=\"p\">)</span>\n      <span class=\"p\">((</span><span class=\"nv\">message</span> <span class=\"ss\">:initarg</span> <span class=\"ss\">:message</span> <span class=\"ss\">:accessor</span> <span class=\"nv\">message</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"ss\">:report</span> <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nv\">c</span> <span class=\"nv\">s</span><span class=\"p\">)</span>\n                 <span class=\"p\">(</span><span class=\"nb\">princ</span> <span class=\"p\">(</span><span class=\"nv\">message</span> <span class=\"nv\">c</span><span class=\"p\">)</span> <span class=\"nv\">s</span><span class=\"p\">))))</span>\n\n    <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"k\">declare</span> <span class=\"p\">(</span><span class=\"k\">ignore</span> <span class=\"nv\">x</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nb\">error</span> <span class=\"ss\">&#39;compile-error</span>\n             <span class=\"ss\">:message</span> <span class=\"s\">&quot;`collect&#39; must be used under `iter&#39;&quot;</span><span class=\"p\">))</span>\n\n    <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"k\">declare</span> <span class=\"p\">(</span><span class=\"k\">ignore</span> <span class=\"nv\">x</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nb\">error</span> <span class=\"ss\">&#39;compile-error</span>\n             <span class=\"ss\">:message</span> <span class=\"s\">&quot;`while&#39; must be used under `iter&#39;&quot;</span><span class=\"p\">))</span>\n\n    <span class=\"p\">(</span><span class=\"nb\">require</span> <span class=\"ss\">:alexandria</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"nb\">use-package</span> <span class=\"ss\">:alexandria</span><span class=\"p\">)</span>\n\n    <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"k\">&amp;body</span> <span class=\"nv\">body</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">with-gensyms</span> <span class=\"p\">(</span><span class=\"nv\">iter-block</span> <span class=\"nv\">accumulate</span> <span class=\"nv\">start</span><span class=\"p\">)</span>\n        <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"k\">block</span> <span class=\"o\">,</span><span class=\"nv\">iter-block</span>\n           <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"o\">,</span><span class=\"nv\">accumulate</span> <span class=\"no\">nil</span><span class=\"p\">))</span>\n             <span class=\"p\">(</span><span class=\"k\">macrolet</span> <span class=\"p\">((</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"kt\">condition</span><span class=\"p\">)</span>\n                          <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">unless</span> <span class=\"o\">,</span><span class=\"kt\">condition</span>\n                             <span class=\"p\">(</span><span class=\"k\">return-from</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,iter-block</span>\n                               <span class=\"p\">(</span><span class=\"nb\">nreverse</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">))))</span>\n                        <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nv\">thing</span><span class=\"p\">)</span>\n                          <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">push</span> <span class=\"o\">,</span><span class=\"nv\">thing</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">)))</span>\n               <span class=\"p\">(</span><span class=\"k\">tagbody</span>\n                 <span class=\"o\">,</span><span class=\"nv\">start</span>\n                 <span class=\"o\">,@</span><span class=\"nv\">body</span>\n                 <span class=\"p\">(</span><span class=\"k\">go</span> <span class=\"o\">,</span><span class=\"nv\">start</span><span class=\"p\">)))))))</span>\n\n    <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">i</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"nv\">i</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">incf</span> <span class=\"nv\">i</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"mi\">3</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mi\">4</span> <span class=\"nv\">i</span><span class=\"p\">)))))</span>\n\n    <span class=\"c1\">;; --&gt; (7 11 15 19 23)</span>\n</pre></div></div><p>Worked well. Sounds good. What&#39;s the problem?</p>\n<p>OK, then go further: let&#39;s implement <code>(collect x into acc)</code> feature in the original <code>iterate</code> . It allows users to specify the name of the list that the elements are accumulated. But again, only with macrolet.</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>    (let ((i 0))\n      (iter (while (&lt; i 5))\n            (incf i)\n            (print acc) ; &lt;--\n            (collect (+ 3 (* 4 i)) :into acc))) ; &lt;--\n</pre></div></div><p>What now? You may easily encounter a problem: How we safely bind the symbol <code>acc</code>? Without destructing the global environment?</p>\n<p>In order to bind a variable safely, we need to wrap the entire loop with <code>let</code> . The problem exists here: the <code>collect</code> clause are expanded <strong>only after the expansion of iter</strong> . The bad thing is, we have no way behind -- backtracking the expansion is impossible. No method to go back to the pre-expansion state.</p>\n<h1>\n        <span id=\"1-6\" class=\"fragment\"></span>\n        <a href=\"#1-6\"><i class=\"fa fa-link\"></i></a>Macros in Common Lisp are still <em>restricted</em>\n      </h1><p>Here resides the crucial problem in the macro system in Common Lisp.</p>\n<p><strong>Expansion is done iteratively, not recursively</strong></p>\n<p>Even CLHS writes:</p>\n\n<blockquote>\n<p> macroexpand <strong>repeatedly</strong> expands form until it is no longer a macro form. In effect, macroexpand calls macroexpand-1 repeatedly until the secondary value it returns is nil. -- <a href=\"http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_macroexpa_acroexpand-1.html\" title=\"\" target=\"_blank\">CLHS Function MACROEXPAND, MACROEXPAND-1</a></p>\n</blockquote>\n<p>If the previous expansion context is on the stack, we can signal an error and backtrack the expansion like:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nv\">thing</span> <span class=\"k\">&amp;key</span> <span class=\"nv\">into</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"nv\">into</span>\n          <span class=\"p\">(</span><span class=\"nb\">error</span> <span class=\"ss\">&#39;accumulate-target</span> <span class=\"ss\">:name</span> <span class=\"nv\">into</span><span class=\"p\">)</span> <span class=\"c1\">; Compile it again!</span>\n          <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">push</span> <span class=\"o\">,</span><span class=\"nv\">thing</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">)))</span>\n</pre></div></div><p>and the handler in the <code>iter</code> might catch the signal.</p>\n<p>Hypothetical implementation following such a macro system is shown below. In <code>defmacro</code>, we have additional argument <code>&amp;continuation cont</code> that takes a closure which continue the expansion of the inner clauses. If a condition is signaled from the upper stack, then it is handled by the handler here and it recompile the whole clause again.</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>   <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"k\">&amp;body</span> <span class=\"nv\">body</span> <span class=\"nv\">&amp;continuation</span> <span class=\"nv\">cont</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">with-gensyms</span> <span class=\"p\">(</span><span class=\"nv\">iter-block</span> <span class=\"nv\">accumulate</span> <span class=\"nv\">start</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">handler-case</span>\n            <span class=\"p\">(</span><span class=\"nb\">funcall</span> <span class=\"nf\">#&#39;</span><span class=\"nv\">cont</span>\n                     <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"k\">block</span> <span class=\"o\">,</span><span class=\"nv\">iter-block</span>\n                        <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"o\">,</span><span class=\"nv\">accumulate</span> <span class=\"no\">nil</span><span class=\"p\">))</span>\n                          <span class=\"p\">(</span><span class=\"k\">macrolet</span> <span class=\"p\">((</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"kt\">condition</span><span class=\"p\">)</span>\n                                       <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">unless</span> <span class=\"o\">,</span><span class=\"kt\">condition</span>\n                                          <span class=\"p\">(</span><span class=\"k\">return-from</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,iter-block</span>\n                                            <span class=\"p\">(</span><span class=\"nb\">nreverse</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">))))</span>\n                                     <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nv\">thing</span> <span class=\"k\">&amp;key</span> <span class=\"nv\">into</span><span class=\"p\">)</span>\n                                       <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"nv\">into</span>\n                                           <span class=\"p\">(</span><span class=\"nb\">signal</span> <span class=\"ss\">&#39;accumulate-target</span> <span class=\"ss\">:name</span> <span class=\"nv\">into</span><span class=\"p\">)</span>\n                                           <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">push</span> <span class=\"o\">,</span><span class=\"nv\">thing</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">))))</span>\n                            <span class=\"p\">(</span><span class=\"k\">tagbody</span>\n                              <span class=\"o\">,</span><span class=\"nv\">start</span>\n                              <span class=\"o\">,@</span><span class=\"nv\">body</span>\n                              <span class=\"p\">(</span><span class=\"k\">go</span> <span class=\"o\">,</span><span class=\"nv\">start</span><span class=\"p\">))))))</span>\n          <span class=\"c1\">;; handler</span>\n          <span class=\"p\">(</span><span class=\"nv\">accumulate-target</span> <span class=\"p\">(</span><span class=\"nv\">c</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nb\">setf</span> <span class=\"nv\">accumulate</span> <span class=\"p\">(</span><span class=\"nv\">name</span> <span class=\"nv\">c</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">funcall</span> <span class=\"nf\">#&#39;</span><span class=\"nv\">cont</span>\n                     <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"k\">block</span> <span class=\"o\">,</span><span class=\"nv\">iter-block</span>\n                        <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"o\">,</span><span class=\"nv\">accumulate</span> <span class=\"no\">nil</span><span class=\"p\">))</span>\n                          <span class=\"p\">(</span><span class=\"k\">macrolet</span> <span class=\"p\">((</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"kt\">condition</span><span class=\"p\">)</span>\n                                       <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">unless</span> <span class=\"o\">,</span><span class=\"kt\">condition</span>\n                                          <span class=\"p\">(</span><span class=\"k\">return-from</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,iter-block</span>\n                                            <span class=\"p\">(</span><span class=\"nb\">nreverse</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">))))</span>\n                                     <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nv\">thing</span> <span class=\"k\">&amp;key</span> <span class=\"nv\">into</span><span class=\"p\">)</span>\n                                       <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">push</span> <span class=\"o\">,</span><span class=\"nv\">thing</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">)))</span>\n                            <span class=\"p\">(</span><span class=\"k\">tagbody</span>\n                              <span class=\"o\">,</span><span class=\"nv\">start</span>\n                              <span class=\"o\">,@</span><span class=\"nv\">body</span>\n                              <span class=\"p\">(</span><span class=\"k\">go</span> <span class=\"o\">,</span><span class=\"nv\">start</span><span class=\"p\">))))))))))</span>\n</pre></div></div><p>We refer to this continuation <code>cont</code> as <em>compile-time continuation</em> because it is a continuation intended to be used in a macro expansion. These style itself is called as <code>Expression Passing Style</code> according to <a href=\"http://www.cs.indiana.edu/l/www/pub/techreports/TR195.pdf\" title=\"\" target=\"_blank\"><em>expression passing style</em> by Dybvig</a> because it passes a sub-expression to the continuation. However, since the paper assumes a scheme-like system in describing the concept, the direct application to Common Lisp is not possible.</p>\n<h1>\n        <span id=\"1-7\" class=\"fragment\"></span>\n        <a href=\"#1-7\"><i class=\"fa fa-link\"></i></a>Related Works\n      </h1><p>The original <code>iterate</code>, however, does not handle the problem in this way. It rather has its own code walker to detect all <code>(collect ... into ...)</code> <em>prior to</em> the expansion of <code>iter</code>. This is clearly a dirty workaround -- consider a case that a <code>collect</code> clause is hidden in a expansion of another macro:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"c1\">;; `collect` clause hidden in a macro</span>\n    <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">my-collect</span> <span class=\"p\">(</span><span class=\"k\">&amp;rest</span> <span class=\"nv\">args</span><span class=\"p\">)</span>\n      <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"o\">,@</span><span class=\"nv\">args</span><span class=\"p\">))</span>\n\n    <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">i</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"nv\">i</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">incf</span> <span class=\"nv\">i</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"nv\">acc</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nv\">my-collect</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"mi\">3</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mi\">4</span> <span class=\"nv\">i</span><span class=\"p\">))</span> <span class=\"nv\">into</span> <span class=\"nv\">acc</span><span class=\"p\">)))</span>\n</pre></div></div><p>In order to detect all <code>collect</code> clause in any macro expansion, the code walker in <code>iterate</code> expands all macro inside the body of <code>iter</code>. This is dirty -- and has indeed a critical limitation:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"nb\">require</span> <span class=\"ss\">:iterate</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"nb\">in-package</span> <span class=\"ss\">:iterate</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">i</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"nv\">i</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">incf</span> <span class=\"nv\">i</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"nv\">acc</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"k\">macrolet</span> <span class=\"p\">((</span><span class=\"nv\">my-collect</span> <span class=\"p\">(</span><span class=\"k\">&amp;rest</span> <span class=\"nv\">args</span><span class=\"p\">)</span>\n                         <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"o\">,@</span><span class=\"nv\">args</span><span class=\"p\">)))</span>\n              <span class=\"p\">(</span><span class=\"nv\">my-collect</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"mi\">3</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mi\">4</span> <span class=\"nv\">i</span><span class=\"p\">))</span> <span class=\"nv\">into</span> <span class=\"nv\">acc</span><span class=\"p\">))))</span>\n\n    <span class=\"c1\">; in: LET ((I 0)) ...</span>\n    <span class=\"c1\">; </span>\n    <span class=\"c1\">; caught WARNING:</span>\n    <span class=\"c1\">;   Iterate:</span>\n    <span class=\"c1\">;   Iterate does not know how to handle </span>\n    <span class=\"c1\">;     the special form (MACROLET ...)</span>\n    <span class=\"c1\">;   It will not be walked, which means that Iterate clauses</span>\n    <span class=\"c1\">;   inside it will not be seen.</span>\n    <span class=\"c1\">;</span>\n    <span class=\"c1\">; compilation unit finished</span>\n    <span class=\"c1\">;   Undefined function:</span>\n    <span class=\"c1\">;     COLLECT</span>\n    <span class=\"c1\">;   Undefined variables:</span>\n    <span class=\"c1\">;     ACC INTO</span>\n</pre></div></div><p>This is essentially a problem in ANSI CL. Theoretically, <code>augment-environment</code> and <code>parse-macro</code> defined in cltl2 allows the code walker to expand those clauses. The behavior may be the result of historical issue.</p>\n\n<blockquote>\n<p>[Function] augment-environment env &amp;key</p>\n<p>:variable :symbol-macro :function :macro :declare</p>\n<p>:macro</p>\n<p>The argument is a list of local macro definitions, each of the form (name definition). Note that the argument is <strong>not</strong> in the same format as the cadr of a macrolet special form. Each definition must be a function of two arguments (a form and an environment). The new environment will have local macro bindings of each name to the corresponding expander function, which will be returned by macro-function and used by macroexpand.</p>\n<p><a href=\"http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node102.html\" title=\"\" target=\"_blank\">CLTL2 8.5 Environment</a></p>\n</blockquote>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"o\">...</span> <span class=\"k\">&amp;environment</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n      <span class=\"o\">...</span>\n      <span class=\"p\">(</span><span class=\"nv\">walk-code</span> <span class=\"o\">...</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n\n    <span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">walk-code</span> <span class=\"p\">(</span><span class=\"nv\">form</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n      <span class=\"o\">...</span>\n      <span class=\"p\">(</span><span class=\"nb\">when</span> <span class=\"p\">(</span><span class=\"nb\">eq</span> <span class=\"ss\">&#39;macrolet</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">form</span><span class=\"p\">))</span>\n        <span class=\"p\">(</span><span class=\"nb\">destructuring-bind</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">macros</span> <span class=\"o\">.</span> <span class=\"nv\">body</span><span class=\"p\">)</span> <span class=\"nv\">form</span>\n          <span class=\"p\">(</span><span class=\"k\">declare</span> <span class=\"p\">(</span><span class=\"k\">ignore</span> <span class=\"nb\">car</span><span class=\"p\">))</span>\n          <span class=\"p\">(</span><span class=\"nv\">walk-code</span>\n            <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"k\">progn</span> <span class=\"o\">,@</span><span class=\"nv\">body</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nv\">augment-environment</span>\n             <span class=\"nv\">env</span>\n             <span class=\"ss\">:macro</span> <span class=\"p\">(</span><span class=\"nb\">mapcar</span> <span class=\"p\">(</span><span class=\"nv\">rcurry</span> <span class=\"nf\">#&#39;</span><span class=\"nv\">parse-macro</span> <span class=\"nv\">env</span><span class=\"p\">)</span> <span class=\"nv\">macros</span><span class=\"p\">))))))</span>\n</pre></div></div><p>Well, well, however, is it clever to implement such a code walker? We have lots of special forms <code>let,tagbody,block,catch</code> which are already correctly handled by the implementation, and possibly some other implementation-dependent special forms (in sbcl, <code>sb!ext:truly-the</code> and <code>sb!sys:with-pinned-objects</code>). Isn&#39;t it just re-implementing those feature by hand? Quite *un*clever, isn&#39;t it? (no offence, I don&#39;t mean to insult iterate&#39;s author - I love it, but its implementation is badly affected by the design of the macro system in CL.)</p>\n<p>Also, the code processed by <code>walk-code</code> is traversed again by the bytecode/native compiler, or an evaluator. They search for macro forms again, with similar implementation to that of <code>walk-code</code> -- it&#39;s just inefficient.</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"nb\">eval</span>            <span class=\"c1\">; let</span>\n     <span class=\"p\">(</span><span class=\"nb\">eval</span>           <span class=\"c1\">; iter</span>\n      <span class=\"p\">(</span><span class=\"nb\">macroexpand</span><span class=\"p\">)</span>  <span class=\"c1\">; expand `iter`, calling `walk-code` inside it</span>\n      <span class=\"p\">(</span><span class=\"nb\">eval</span><span class=\"p\">)))</span>       <span class=\"c1\">; `eval` traverse the body again</span>\n</pre></div></div><p>Another aspect of the problem is here.</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">x</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">y</span> <span class=\"nv\">x</span><span class=\"p\">))</span>\n        <span class=\"p\">(</span><span class=\"k\">declare</span> <span class=\"p\">(</span><span class=\"kt\">fixnum</span> <span class=\"nv\">y</span><span class=\"p\">))</span>\n        <span class=\"o\">...</span><span class=\"p\">))</span>\n</pre></div></div><p><code>let</code> is not a macro, but assume it is one.  In this example, <code>y</code> is declared to be a fixnum.  However, <em>humans easily know that</em> <code>y</code> is directly copied from <code>x</code> and <code>x</code> is unmodified -- you want the compiler to automatically deduce <code>x</code> to be a fixnum, don&#39;t you? By <strong>backtracking the expansion?</strong></p>\n<p>The core problem of current macro system is essentially the following: it is not able to propagate the <strong>inner</strong> constraints to the <strong>outer</strong> environment.  Communications between the outer and the inner macros are virtually impossible. As a result, such tasks tend to be handled by a implementation specific extensions such as <code>deftransform</code> in sbcl.</p>\n<h1>\n        <span id=\"1-8\" class=\"fragment\"></span>\n        <a href=\"#1-8\"><i class=\"fa fa-link\"></i></a>Conclusion\n      </h1><p>Current macro system calls expansions and traversals independently, which does not allow the backtracking during the macro expansion.  It inhibits the communication between the inner and outer macros, especially from the former(inside) to the latter(outside), thus restricting the ability of macros in general.</p>\n<p>In this article, we proposed a recursive macro system with a notion of <code>compile-time continuation</code>, which is a closure of one argument and when called with a form it continues the traversal and expand of the subforms. We also showed its benefit i.e. such system potentially has a more easy-to-use interface for a constraint propagation from the inner to the outer code.</p>\n<p>Comments are welcome.</p>\n",
        "stock_users": [
            "kencoba"
        ]
    },
    {
        "id": 45628,
        "uuid": "2852196ddf4c48ff0e3c",
        "user": {
            "id": 6090,
            "url_name": "guicho271828",
            "profile_image_url": "https://pbs.twimg.com/profile_images/378800000809306716/dbd9008f86c426eb255aadb7fb0b9769_normal.jpeg"
        },
        "title": "Common Lisp is still hard to satisfy.",
        "created_at": "2014-02-14 22:35:22 +0900",
        "updated_at": "2014-02-14 22:38:36 +0900",
        "created_at_in_words": "7ヶ月",
        "updated_at_in_words": "7ヶ月",
        "tags": [
            {
                "name": "common-lisp",
                "url_name": "common-lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/745b73901dc247fd2b064c1766a7bcd8037cd5a7/medium.jpg?1364838584",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            }
        ],
        "stock_count": 11,
        "comment_count": 8,
        "url": "http://qiita.com/guicho271828/items/2852196ddf4c48ff0e3c",
        "created_at_as_seconds": 1392384922,
        "tweet": true,
        "gist_url": "https://gist.github.com/9001076",
        "private": false,
        "raw_body": "# Abstract\n\nマクロは、構文拡張により言語の高い次元の抽象化を行うことができる、Lisp 特有の機能です。マクロは、S式をコンパイルするとき、そのheadがマクロをもつシンボルであったならば、対応する macro-function を呼び出して式を変形させるという動作をします。コンパイルは構文木のrootから順に行われます。\n\nこの記事では、マクロ一般の能力ではなく、 **現在の Common Lisp におけるマクロシステム** について、それが制限を持っているということを示します。また、この制限を克服できる新たなマクロシステムを提案します。\n\n# マクロとは\n\n(略)\n\nマクロに関係するマクロ、関数、変数は以下です。\n\n```cl\n(defmacro name lambda-list &body body)\n(macrolet bindigs &body body)\n(eval form)\n(compile name definition)\n(macroexpand form &optional env)\n(macroexpand-1 form &optional env)\n*macroexpand-hook*\n```\n\nまた、環境に関してcltl2で提供される関数も示します。\n\n\n```cl\nAUGMENT-ENVIRONMENT\nCOMPILER-LET\nDECLARATION-INFORMATION\nDEFINE-DECLARATION\nENCLOSE\nFUNCTION-INFORMATION\nPARSE-MACRO\nVARIABLE-INFORMATION\n```\n\n\n# マクロの基本的な使用方法とその動作\n\nマクロの基本はリスト操作, `defmacro` , `macroexpand-1` です。\n\n`defmacro` は、ほとんど `defun` と同じですが、その関数をマクロ展開関数(`macro-function`)として保存します。\n\n`macroexpand-1` は引数にリストを取り、リストの `head` (最初の要素) にあるシンボルをみて、そのシンボルに `macro-function` が束縛されているかを見ます。束縛されている場合、`defmacro`によって定義された関数を呼び出して、その関数が返した新たなフォームを返します。なお、`macroexpand-1` は `*macroexpand-hook*` を通して`macro-function`を呼び出します。二つめの返り値は、マクロ展開が行われたかどうかのbooleanを返します。\n\nマクロ関数が束縛されていない場合、つまりシンボルがタダの関数かスペシャルフォームである場合、何も行いません。下の `*form*` の例では、その`head` は `let` 、つまりスペシャルフォームの名前なので、何も展開しません。\n\n```cl\n(defmacro my-unless (condition &body body)\n  `(when (not ,condition)\n     ,@body))\n\n(defparameter *form*\n  `(let ((x 5))\n     (my-unless (plusp x)\n       (print :minus))))\n\n(macroexpand-1 *form*)\n; -->\n;  (LET ((X 5))\n;    (MY-UNLESS (PLUSP X)\n;      (PRINT :MINUS)))\n;  NIL\n```\n\n次の場合はどうでしょうか。\n\n```cl\n(defparameter *form2*\n  `(my-unless (plusp x)\n      (print :minus)))\n```\n\nこの場合、 `my-unless` は今回作ったマクロですから、展開されます。\n\n\n```cl\n(macroexpand-1 *form2*)\n;; -->\n;; (WHEN (NOT (PLUSP X)) (PRINT :MINUS))\n;; T\n```\n\n展開されると、 `my-unless` で定義されているとおり、 `when` が現れます。二つめの返り値は、マクロ展開が行われたかどうかですから、 `T` が返ります。さて、 CLHS によれば、 `when` もまたマクロです。そのため、もう何度か `macroexpand-1` を噛ませると、こうなります:\n\n\n```cl\n(macroexpand-1 (macroexpand-1 *form2*))\n;; ->\n;; (IF (NOT (PLUSP X))\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; T\n(macroexpand-1 (macroexpand-1 (macroexpand-1 *form2*)))\n;; ->\n;; (IF (NOT (PLUSP X))          ; 変化なし\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; NIL\n```\n\n`if` は special operator で、マクロではありませんから、1番目のケースと同じでこれ以上は展開されません。そのため、二つめの返り値はNILになります。\n\n`macroexpand` はこの２つ目の返り値を見ながら繰り返し展開します。２つ目の返り値がNILになるまで展開し続けるわけです。\n\n\n```cl\n(macroexpand *form2*)\n;; -->\n;; (IF (NOT (PLUSP X))\n;;     (PROGN (PRINT :MINUS))\n;;     NIL)\n;; T\n```\n\nここで重要なのは、 `macroexpand` が展開するのはあくまで *与えられた構文木(フォーム)の一番上の部分だけ* であるという事です。\n\n```cl\n(macroexpand *form*)\n;; -->\n;;  (LET ((X 5))\n;;    (MY-UNLESS (PLUSP X)\n;;      (PRINT :MINUS)))\n;;   NIL\n```\n\nなんど展開しようが `LET` は `LET`  のままです。マクロ展開を内側まで行うことはありません。\n\n# 実際にプログラムを動かす時は?\n\nさて、前の章では、 「 `macroexpand` はすべてのマクロを展開するわけではない」ということを示しました。それが展開するのはトップレベルのマクロだけなわけです。では、内側のマクロはいつ、誰がどのように展開するのでしょうか？\n\nこの動作を調べるのには、インタプリタの `eval` のコードを読むことが助けになります。今私たちはマクロ変換のみに注目したいので、考えるのはインタプリタ評価における動作で十分です。(そうでないと、例えば自分の使っているsbclの場合、ネイティブコードへの変換するコードがまざってきます。)\n\nインタプリタは、マクロを展開しながら逐次動作します。「コンパイルをしないのがインタプリタ」と考えがちですが、実際にはマクロ展開という意味でのコンパイルは行います。\n\nでは、実際に sbcl のインタプリタのコードを見てみましょう。sbclは通常、evalをするときでも一旦ネイティブコンパイルして実行しますが、最近のsbclの `eval` は、 `sb-eval:*evaluator-mode*` という変数を`:interpret` にセットすることで、 *本当の* インタプリタとして動きます。\n\n```cl\nCL-USER> (setf *evaluator-mode* :interpret) \n; --> :INTERPRET\n```\n\nさて、実際のコードです。(一部分、いらないところは削除してあります)\n\n```cl\n(defun eval (original-exp)\n  (eval-in-lexenv original-exp (make-null-lexenv)))\n\n;; ↓\n\n(defun eval-in-lexenv (exp lexenv)\n  (if (eq *evaluator-mode* :compile)\n      ...\n      (sb!eval:eval-in-native-environment exp lexenv)))\n\n;; ↓ \n\n(defun eval-in-native-environment (form lexenv)\n  (handler-bind\n      ((sb!impl::eval-error ...))\n      ...\n      (%eval form env)))\n\n;; ↓\n\n(defun %eval (exp env)\n  ...\n  (%%eval exp env))\n\n;; ↓\n```\n\n長かった。いよいよですね。\n\n\n```cl\n(defun %%eval (exp env)\n  (cond\n    ((symbolp exp)\n     ;; CLHS 3.1.2.1.1 Symbols as Forms\n     (multiple-value-bind (value kind) (get-variable exp env)\n       (ecase kind\n         (:variable value)\n         (:expansion (%eval value env)))))\n    ;; CLHS 3.1.2.1.3 Self-Evaluating Objects\n    ((atom exp) exp)\n    ;; CLHS 3.1.2.1.2 Conses as Forms\n    ((consp exp)\n     (case (car exp)\n       ;; CLHS 3.1.2.1.2.1 Special Forms\n       ((block)                (eval-block (cdr exp) env))\n       ((catch)                (eval-catch (cdr exp) env))\n       ;; special form が20個ぐらい続く\n       ;;\n       ;; (略)\n       (t\n        (let ((dispatcher (getf *eval-dispatch-functions* (car exp))))\n          (cond\n            (dispatcher ; cltl2:compiler-let のための処理\n             (funcall dispatcher exp env))\n            ;; CLHS 3.1.2.1.2.4 Lambda Forms\n            ((and (consp (car exp)) (eq (caar exp) 'lambda))\n             (interpreted-apply (eval-function (list (car exp)) env)\n                                (eval-args (cdr exp) env)))\n            (t\n             (multiple-value-bind (function kind) (get-function (car exp) env)\n               (ecase kind\n                 ;; CLHS 3.1.2.1.2.3 Function Forms\n                 (:function (%apply function (eval-args (cdr exp) env)))\n                 ;; CLHS 3.1.2.1.2.2 Macro Forms\n                 (:macro\n                  ;; **ここからがキモ**\n                  ;; **ここからがキモ**\n                  )))))))))))\n```\n\nネストが深いので、キモだけを抜き出してみました。\n\n```cl\n(let ((hook *macroexpand-hook*))\n  (%eval (funcall hook      ; 展開\n                  function\n                  exp\n                  (env-native-lexenv env))\n         env))\n```\n\nと、いうことで、やはり、1レベルだけ展開して、またeval するわけですね。なお、 `*macroexpand-hook*` は通常 `funcall` に束縛されています。\n\n# スタックの動き\n\n上のコードを見ながら、はじめに扱ったコードを インタプリタがどのように実行するのか、考えてみましょう。すると、展開や評価におけるコールスタックの動き方が下の図のようなものだとわかります。\n\n```cl\n;; eval するコード\n(let ((x 5))\n  (my-unless (plusp x)\n    (print :minus)))\n\n;; 展開してできるコード\n(let ((x 5))\n  (IF (NOT (PLUSP X))\n      (PROGN (PRINT :MINUS))\n      NIL))\n\n;; コールスタック\n(eval            ; let\n (eval           ; my-unless\n  (macroexpand)  ; my-unless -> when -> if\n  (eval          ; if\n   (eval (eval)) ; (not (plusp x))\n   (eval))))     ; (progn ...) か NIL\n```\n\nevalのコールの途中に macroexpand が混じっている感じですね。もし展開するコードが２つ以上のマクロ展開を含んでいたらどうなるでしょうか。\n\n\n```cl\n;; eval するコード\n(my-unless (plusp x)\n  (my-unless (minusp x)\n    (print :zero)))  \n\n;; 展開してできるコード\n(IF (NOT (PLUSP X))\n    (PROGN\n     (IF (NOT (MINUSP X))\n         (PROGN (PRINT :ZERO))\n         NIL))\n    NIL)\n\n;; コールスタック\n(eval               ; my-unless\n (macroexpand)      ; my-unless -> when -> if\n (eval              ; if\n  (eval             ; (not (plusp))\n   (eval            ; my-unless\n    (macroexpand)   ; my-unless -> when -> if\n    (eval ...)))))  ; (not (minusp))\n```\n\nここで掲げたい重要事項が、各々のマクロ展開は独立しているということです。上のマクロ展開は、下のマクロ展開の時に、スタック上に残っていない。カッコでいって上にあるコードがどのようなものだったかという情報は、綺麗サッパリ消えてしまっています。コールスタックに残っていないからです。\n\n# 局所マクロ -- macrolet で作ってみる --\n\n上の仕様は、「賢い」局所マクロを実装する上の障害になります。局所マクロを実装する方法はすでにあるだろう、と思われるかもしれません。`macrolet` のことですね。でも、それではいけないのです。\n\nわかりやすい説明をするために、LOOPのような機能をもつ有名なユーティリティ `iterate` の簡易版を実装してみましょう。私が実装する簡易版 `iterate` は、だいたい以下のような構文を持ちます。\n\n```cl\n    ;; iterate の簡易バージョン\n    ;; iter の中にいるばあい、\n    ;; while は 引数が true の時だけ実行を次の節に続けます。\n    ;; collect はその引数を内部的な変数に集め、iterの返り値にします。\n    ;; iter の外で使われた時は、for と collect はエラーを投げます。\n    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (collect (+ 3 (* 4 i)))))\n```\n\nこれを `macrolet` だけで実装してみましょう。ざっとこんな感じ。\n\n    \n```cl    \n    (define-condition compile-error (simple-error)\n      ((message :initarg :message :accessor message))\n      (:report (lambda (c s)\n                 (princ (message c) s))))\n    \n    (defmacro collect (x)\n      (declare (ignore x))\n      (error 'compile-error\n             :message \"`collect' must be used under `iter'\"))\n    \n    (defmacro while (x)\n      (declare (ignore x))\n      (error 'compile-error\n             :message \"`while' must be used under `iter'\"))\n    \n    (require :alexandria)\n    (use-package :alexandria)\n    \n    (defmacro iter (&body body)\n      (with-gensyms (iter-block accumulate start)\n        `(block ,iter-block\n           (let ((,accumulate nil))\n             (macrolet ((while (condition)\n                          `(unless ,condition\n                             (return-from ,',iter-block\n                               (nreverse ,',accumulate))))\n                        (collect (thing)\n                          `(push ,thing ,',accumulate)))\n               (tagbody\n                 ,start\n                 ,@body\n                 (go ,start)))))))\n    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (collect (+ 3 (* 4 i)))))\n    \n    ;; --> (7 11 15 19 23)\n```\n\nうん、まあうまく行ってますね。なんだ、やはり `macrolet` だけで十分じゃないかと。\n\nでは、それと同じ感じで 本来の `iterate` にある`(collect x into acc)` の機能を作ってみましょう。これは、モノが蓄積される場所を明示的に指定できる機能です。\n\n```    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc) ; <--\n            (collect (+ 3 (* 4 i)) :into acc))) ; <--\n```\n\n・・・できますか？ macroletだけで？ できないはずです。\n\n何らかの場所を明示的に指定するためには、その場所を束縛するように、ループ全体を `let` で囲まなくてはいけません。 **でも、collect節が展開されるのは、iterが展開された後なのです。この点こそが致命的な弱点です。**\n\n# Macros in Common Lisp are still *restricted*\n\nlisp以外の言語の使用者からすれば「はぁ、そうですか」となるかもしれませんが、まあど〜せそういった人々は対象ではありません。私が考える common lisp のマクロの致命的な弱点はこの点です。\n\n**マクロ展開が再帰的でない**\n\nマクロ展開は、 **繰り返し** によって行われます。CLHSですら、こう書いています。\n\n>  macroexpand **repeatedly** expands form until it is no longer a macro\n> form. In effect, macroexpand calls macroexpand-1 repeatedly until the\n> secondary value it returns is nil. -- [CLHS Function MACROEXPAND, MACROEXPAND-1](http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_macroexpa_acroexpand-1.html)\n\n展開が再帰的で、上の展開がスタックに残っていれば、たとえば先ほど示した例に対応する `collect` の実装は、以下のように書くことができます。\n\n```cl\n    (collect (thing &key into)\n      (if into\n          (error 'accumulate-target :name into) ; コンパイルやり直し！\n          `(push ,thing ,',accumulate)))\n```\n\nそして、 `iter` 展開時のハンドラでこのシグナルをキャッチするのです。たとえば、以下のような実装はどうでしょうか。`&continuation cont` としてクロージャが与えられ、これを `funcall` を通して呼ぶことで、下層の `macroexpand` を呼ぶことができると考えましょう。スタックの下から登ってきた condition を、上のハンドラが受け取って、マクロ展開をやり直せます。\n\n\n```cl\n   (defmacro iter (&body body &continuation cont)\n      (with-gensyms (iter-block accumulate start)\n        (handler-case\n            (funcall #'cont\n                     `(block ,iter-block\n                        (let ((,accumulate nil))\n                          (macrolet ((while (condition)\n                                       `(unless ,condition\n                                          (return-from ,',iter-block\n                                            (nreverse ,',accumulate))))\n                                     (collect (thing &key into)\n                                       (if into\n                                           (signal 'accumulate-target :name into)\n                                           `(push ,thing ,',accumulate))))\n                            (tagbody\n                              ,start\n                              ,@body\n                              (go ,start))))))\n          ;; handler\n          (accumulate-target (c)\n            (setf accumulate (name c))\n            (funcall #'cont\n                     `(block ,iter-block\n                        (let ((,accumulate nil))\n                          (macrolet ((while (condition)\n                                       `(unless ,condition\n                                          (return-from ,',iter-block\n                                            (nreverse ,',accumulate))))\n                                     (collect (thing &key into)\n                                       `(push ,thing ,',accumulate)))\n                            (tagbody\n                              ,start\n                              ,@body\n                              (go ,start))))))))))\n```\n\n# Related Works\n\n本物の `iterate` では、このようなことが行えないため、code walker を用いて `(collect ... into ...)` 節を検出しています。code walker がどう賢くないかというと、 `collect` などの節がマクロの中に現れてしまった時に困るという点です。\n\n```cl\n    ;; 一階層隠蔽する\n    (defmacro my-collect (&rest args)\n      `(collect ,@args))\n    \n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc)\n            (my-collect (+ 3 (* 4 i)) into acc)))\n```\n\n`iterate` の code walker は、すべての `collect` 節を漏らさず検出するために、 `iter` 以下のすべてのマクロを展開する必要があります。しかし、それには限界があります。iterateは、iter節の中に現れた macrolet を展開できません。つまり、 macrolet の中にある `while` や `collect` は code walker に見過ごされます。\n\n```cl\n    (require :iterate)\n    (in-package :iterate)\n    (let ((i 0))\n      (iter (while (< i 5))\n            (incf i)\n            (print acc)\n            (macrolet ((my-collect (&rest args)\n                         `(collect ,@args)))\n              (my-collect (+ 3 (* 4 i)) into acc))))\n    \n    ; in: LET ((I 0)) ...\n    ; \n    ; caught WARNING:\n    ;   Iterate:\n    ;   Iterate does not know how to handle \n    ;     the special form (MACROLET ...)\n    ;   It will not be walked, which means that Iterate clauses\n    ;   inside it will not be seen.\n    ;\n    ; compilation unit finished\n    ;   Undefined function:\n    ;     COLLECT\n    ;   Undefined variables:\n    ;     ACC INTO\n```\n\nこれは、実質的には ANSI CLの問題です。実は、cltl2 の `augment-environment` を使えば、macrolet を認識して展開することができます。\n\n> [Function] augment-environment env &key\n> \n> :variable :symbol-macro :function :macro :declare\n> \n> :macro\n> \n> The argument is a list of local macro definitions, each of the form (name definition). Note that the argument is **not** in the same format as the cadr of a macrolet special form. Each definition must be a function of two arguments (a form and an environment). The new environment will have local macro bindings of each name to the corresponding expander function, which will be returned by macro-function and used by macroexpand.\n>\n> [CLTL2 8.5 Environment](http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node102.html)\n\nこれによって、\n\n```cl\n    (defmacro iter (... &environment env)\n      ...\n      (walk-code ... env))\n    \n    (defun walk-code (form env)\n      ...\n      (when (eq 'macrolet (car form))\n        (destructuring-bind (car macros . body) form\n          (declare (ignore car))\n          (walk-code\n            `(progn ,@body)\n            (augment-environment\n             env\n             :macro (make-macro-functions macros))))))\n```\n\nと、まあこのように、macrolet を 普通のマクロと同じように展開できるはずです。ただしもう一度ですが、これは cltl2 に頼ることになります。\n\nしかしそもそも、 walk-code は、letやtagbody、blockやcatch など、スペシャルフォームを認識して、すべて理解し直さなくてはなりません。それってすっっっっごく頭が悪いと思いませんか?Common Lisp にはもとからevalやcompileなど、スペシャルフォームをネイティブコードまたはバイトコードに変換してくれる便利な関数が存在しています。なぜ、二度同じものを書きなおさなくてはならないのでしょうか?\n\nそれに、結局このwalk-codeは以下のmacroexpand の中で行われるわけです。つまり、そのあとのevalが、展開したスペシャルフォームと関数フォームをもう一度解析し直す -- つまり、マクロの有無をもう一度確認するわけです。これはとても非効率ではないでしょうか？\n\n```cl\n    (eval            ; let\n     (eval           ; iter\n      (macroexpand)  ; iterを展開 (中でwalk-codeを呼ぶ)\n      (eval)))       ; 展開したコードをまた読み込み直す -- マクロのチェックもする\n```\n\nまた、その他の例もあります。たとえば以下のような例。\n\n```cl\n    (let ((x 0))\n      (let ((y x))\n        (declare (fixnum y))\n        ...))\n```\n\nletは実際にはマクロではありませんが、仮にマクロだと考えてください。この例では、yの方がfixnumであると言われています。しかし、yはxから直接コピーしたものです。マクロ展開をバックトラックして、 **xの型も** fixnumであると宣言したくなりませんか？\n\n似たような応用例はいろいろと考えられます。上に挙げた例は、ソースコードの最適化という操作に大きな効果をもたらすわけですが、これを一般化すると、「ソースコード(カッコ)の内側から、より大域的な環境に制約(=型情報など)を伝播させることができる」というわけです。今までのマクロシステムではそのようなことはできませんでした。そのため、この種の最適化は処理系独自の拡張 (sbclならば `deftransform` など)によってしか不可能だったのではないかと思います。\n\n# 結論\n\n現状のマクロ展開は、\n\n    macroexpand -> eval -...-> eval -> macroexpand -...->\n\nのように、一部を展開しては次へ評価するという形をとります。その途中で、「以前にmacroexpandを行った」という情報はスタックから消えてしまうため、コンディションシステムを用いてマクロ展開前の状態に戻ることはできなくなります。これは、マクロの可能性をかなり制限します。\n\nこの記事では、より良いマクロシステムの設計として、「展開自体は最初に再帰的にすべて行ってしまい、展開しつくしたコードを評価ないしバイトコード・ネイティブコードコンパイルする」といった形式を提唱しました。また、そのようなマクロシステムを使えば、処理系の特殊な実装に頼ることなく、局所的なコードからより大域的な制約を推論することができることを示しました。\n\n以上、反応をお待ちしています。\n",
        "body": "<h1>\n        <span id=\"1-1\" class=\"fragment\"></span>\n        <a href=\"#1-1\"><i class=\"fa fa-link\"></i></a>Abstract\n      </h1><p>マクロは、構文拡張により言語の高い次元の抽象化を行うことができる、Lisp 特有の機能です。マクロは、S式をコンパイルするとき、そのheadがマクロをもつシンボルであったならば、対応する macro-function を呼び出して式を変形させるという動作をします。コンパイルは構文木のrootから順に行われます。</p>\n<p>この記事では、マクロ一般の能力ではなく、 <strong>現在の Common Lisp におけるマクロシステム</strong> について、それが制限を持っているということを示します。また、この制限を克服できる新たなマクロシステムを提案します。</p>\n<h1>\n        <span id=\"1-2\" class=\"fragment\"></span>\n        <a href=\"#1-2\"><i class=\"fa fa-link\"></i></a>マクロとは\n      </h1><p>(略)</p>\n<p>マクロに関係するマクロ、関数、変数は以下です。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">name</span> <span class=\"nv\">lambda-list</span> <span class=\"k\">&amp;body</span> <span class=\"nv\">body</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"k\">macrolet</span> <span class=\"nv\">bindigs</span> <span class=\"k\">&amp;body</span> <span class=\"nv\">body</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">eval</span> <span class=\"nv\">form</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">compile</span> <span class=\"nv\">name</span> <span class=\"nv\">definition</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">macroexpand</span> <span class=\"nv\">form</span> <span class=\"k\">&amp;optional</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"nv\">form</span> <span class=\"k\">&amp;optional</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n<span class=\"vg\">*macroexpand-hook*</span>\n</pre></div></div><p>また、環境に関してcltl2で提供される関数も示します。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"nv\">AUGMENT-ENVIRONMENT</span>\n<span class=\"nv\">COMPILER-LET</span>\n<span class=\"nv\">DECLARATION-INFORMATION</span>\n<span class=\"nv\">DEFINE-DECLARATION</span>\n<span class=\"nv\">ENCLOSE</span>\n<span class=\"nv\">FUNCTION-INFORMATION</span>\n<span class=\"nv\">PARSE-MACRO</span>\n<span class=\"nv\">VARIABLE-INFORMATION</span>\n</pre></div></div><h1>\n        <span id=\"1-3\" class=\"fragment\"></span>\n        <a href=\"#1-3\"><i class=\"fa fa-link\"></i></a>マクロの基本的な使用方法とその動作\n      </h1><p>マクロの基本はリスト操作, <code>defmacro</code> , <code>macroexpand-1</code> です。</p>\n<p><code>defmacro</code> は、ほとんど <code>defun</code> と同じですが、その関数をマクロ展開関数(<code>macro-function</code>)として保存します。</p>\n<p><code>macroexpand-1</code> は引数にリストを取り、リストの <code>head</code> (最初の要素) にあるシンボルをみて、そのシンボルに <code>macro-function</code> が束縛されているかを見ます。束縛されている場合、<code>defmacro</code>によって定義された関数を呼び出して、その関数が返した新たなフォームを返します。なお、<code>macroexpand-1</code> は <code>*macroexpand-hook*</code> を通して<code>macro-function</code>を呼び出します。二つめの返り値は、マクロ展開が行われたかどうかのbooleanを返します。</p>\n<p>マクロ関数が束縛されていない場合、つまりシンボルがタダの関数かスペシャルフォームである場合、何も行いません。下の <code>*form*</code> の例では、その<code>head</code> は <code>let</code> 、つまりスペシャルフォームの名前なので、何も展開しません。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"kt\">condition</span> <span class=\"k\">&amp;body</span> <span class=\"nv\">body</span><span class=\"p\">)</span>\n  <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">when</span> <span class=\"p\">(</span><span class=\"nb\">not</span> <span class=\"o\">,</span><span class=\"kt\">condition</span><span class=\"p\">)</span>\n     <span class=\"o\">,@</span><span class=\"nv\">body</span><span class=\"p\">))</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defparameter</span> <span class=\"vg\">*form*</span>\n  <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">x</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n     <span class=\"p\">(</span><span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"nb\">plusp</span> <span class=\"nv\">x</span><span class=\"p\">)</span>\n       <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"ss\">:minus</span><span class=\"p\">))))</span>\n\n<span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"vg\">*form*</span><span class=\"p\">)</span>\n<span class=\"c1\">; --&gt;</span>\n<span class=\"c1\">;  (LET ((X 5))</span>\n<span class=\"c1\">;    (MY-UNLESS (PLUSP X)</span>\n<span class=\"c1\">;      (PRINT :MINUS)))</span>\n<span class=\"c1\">;  NIL</span>\n</pre></div></div><p>次の場合はどうでしょうか。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defparameter</span> <span class=\"vg\">*form2*</span>\n  <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"nb\">plusp</span> <span class=\"nv\">x</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"ss\">:minus</span><span class=\"p\">)))</span>\n</pre></div></div><p>この場合、 <code>my-unless</code> は今回作ったマクロですから、展開されます。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"vg\">*form2*</span><span class=\"p\">)</span>\n<span class=\"c1\">;; --&gt;</span>\n<span class=\"c1\">;; (WHEN (NOT (PLUSP X)) (PRINT :MINUS))</span>\n<span class=\"c1\">;; T</span>\n</pre></div></div><p>展開されると、 <code>my-unless</code> で定義されているとおり、 <code>when</code> が現れます。二つめの返り値は、マクロ展開が行われたかどうかですから、 <code>T</code> が返ります。さて、 CLHS によれば、 <code>when</code> もまたマクロです。そのため、もう何度か <code>macroexpand-1</code> を噛ませると、こうなります:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"vg\">*form2*</span><span class=\"p\">))</span>\n<span class=\"c1\">;; -&gt;</span>\n<span class=\"c1\">;; (IF (NOT (PLUSP X))</span>\n<span class=\"c1\">;;     (PROGN (PRINT :MINUS))</span>\n<span class=\"c1\">;;     NIL)</span>\n<span class=\"c1\">;; T</span>\n<span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"p\">(</span><span class=\"nb\">macroexpand-1</span> <span class=\"vg\">*form2*</span><span class=\"p\">)))</span>\n<span class=\"c1\">;; -&gt;</span>\n<span class=\"c1\">;; (IF (NOT (PLUSP X))          ; 変化なし</span>\n<span class=\"c1\">;;     (PROGN (PRINT :MINUS))</span>\n<span class=\"c1\">;;     NIL)</span>\n<span class=\"c1\">;; NIL</span>\n</pre></div></div><p><code>if</code> は special operator で、マクロではありませんから、1番目のケースと同じでこれ以上は展開されません。そのため、二つめの返り値はNILになります。</p>\n<p><code>macroexpand</code> はこの２つ目の返り値を見ながら繰り返し展開します。２つ目の返り値がNILになるまで展開し続けるわけです。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">macroexpand</span> <span class=\"vg\">*form2*</span><span class=\"p\">)</span>\n<span class=\"c1\">;; --&gt;</span>\n<span class=\"c1\">;; (IF (NOT (PLUSP X))</span>\n<span class=\"c1\">;;     (PROGN (PRINT :MINUS))</span>\n<span class=\"c1\">;;     NIL)</span>\n<span class=\"c1\">;; T</span>\n</pre></div></div><p>ここで重要なのは、 <code>macroexpand</code> が展開するのはあくまで <em>与えられた構文木(フォーム)の一番上の部分だけ</em> であるという事です。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">macroexpand</span> <span class=\"vg\">*form*</span><span class=\"p\">)</span>\n<span class=\"c1\">;; --&gt;</span>\n<span class=\"c1\">;;  (LET ((X 5))</span>\n<span class=\"c1\">;;    (MY-UNLESS (PLUSP X)</span>\n<span class=\"c1\">;;      (PRINT :MINUS)))</span>\n<span class=\"c1\">;;   NIL</span>\n</pre></div></div><p>なんど展開しようが <code>LET</code> は <code>LET</code>  のままです。マクロ展開を内側まで行うことはありません。</p>\n<h1>\n        <span id=\"1-4\" class=\"fragment\"></span>\n        <a href=\"#1-4\"><i class=\"fa fa-link\"></i></a>実際にプログラムを動かす時は?\n      </h1><p>さて、前の章では、 「 <code>macroexpand</code> はすべてのマクロを展開するわけではない」ということを示しました。それが展開するのはトップレベルのマクロだけなわけです。では、内側のマクロはいつ、誰がどのように展開するのでしょうか？</p>\n<p>この動作を調べるのには、インタプリタの <code>eval</code> のコードを読むことが助けになります。今私たちはマクロ変換のみに注目したいので、考えるのはインタプリタ評価における動作で十分です。(そうでないと、例えば自分の使っているsbclの場合、ネイティブコードへの変換するコードがまざってきます。)</p>\n<p>インタプリタは、マクロを展開しながら逐次動作します。「コンパイルをしないのがインタプリタ」と考えがちですが、実際にはマクロ展開という意味でのコンパイルは行います。</p>\n<p>では、実際に sbcl のインタプリタのコードを見てみましょう。sbclは通常、evalをするときでも一旦ネイティブコンパイルして実行しますが、最近のsbclの <code>eval</code> は、 <code>sb-eval:*evaluator-mode*</code> という変数を<code>:interpret</code> にセットすることで、 <em>本当の</em> インタプリタとして動きます。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"nv\">CL-USER&gt;</span> <span class=\"p\">(</span><span class=\"nb\">setf</span> <span class=\"vg\">*evaluator-mode*</span> <span class=\"ss\">:interpret</span><span class=\"p\">)</span> \n<span class=\"c1\">; --&gt; :INTERPRET</span>\n</pre></div></div><p>さて、実際のコードです。(一部分、いらないところは削除してあります)</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nb\">eval</span> <span class=\"p\">(</span><span class=\"nv\">original-exp</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nv\">eval-in-lexenv</span> <span class=\"nv\">original-exp</span> <span class=\"p\">(</span><span class=\"nv\">make-null-lexenv</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">;; ↓</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">eval-in-lexenv</span> <span class=\"p\">(</span><span class=\"nb\">exp</span> <span class=\"nv\">lexenv</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">eq</span> <span class=\"vg\">*evaluator-mode*</span> <span class=\"ss\">:compile</span><span class=\"p\">)</span>\n      <span class=\"o\">...</span>\n      <span class=\"p\">(</span><span class=\"nv\">sb!eval:eval-in-native-environment</span> <span class=\"nb\">exp</span> <span class=\"nv\">lexenv</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">;; ↓ </span>\n\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">eval-in-native-environment</span> <span class=\"p\">(</span><span class=\"nv\">form</span> <span class=\"nv\">lexenv</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nb\">handler-bind</span>\n      <span class=\"p\">((</span><span class=\"nv\">sb!impl::eval-error</span> <span class=\"o\">...</span><span class=\"p\">))</span>\n      <span class=\"o\">...</span>\n      <span class=\"p\">(</span><span class=\"nv\">%eval</span> <span class=\"nv\">form</span> <span class=\"nv\">env</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">;; ↓</span>\n\n<span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">%eval</span> <span class=\"p\">(</span><span class=\"nb\">exp</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n  <span class=\"o\">...</span>\n  <span class=\"p\">(</span><span class=\"nv\">%%eval</span> <span class=\"nb\">exp</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; ↓</span>\n</pre></div></div><p>長かった。いよいよですね。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">%%eval</span> <span class=\"p\">(</span><span class=\"nb\">exp</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nb\">cond</span>\n    <span class=\"p\">((</span><span class=\"nb\">symbolp</span> <span class=\"nb\">exp</span><span class=\"p\">)</span>\n     <span class=\"c1\">;; CLHS 3.1.2.1.1 Symbols as Forms</span>\n     <span class=\"p\">(</span><span class=\"nb\">multiple-value-bind</span> <span class=\"p\">(</span><span class=\"nv\">value</span> <span class=\"nv\">kind</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">get-variable</span> <span class=\"nb\">exp</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n       <span class=\"p\">(</span><span class=\"nb\">ecase</span> <span class=\"nv\">kind</span>\n         <span class=\"p\">(</span><span class=\"ss\">:variable</span> <span class=\"nv\">value</span><span class=\"p\">)</span>\n         <span class=\"p\">(</span><span class=\"ss\">:expansion</span> <span class=\"p\">(</span><span class=\"nv\">%eval</span> <span class=\"nv\">value</span> <span class=\"nv\">env</span><span class=\"p\">)))))</span>\n    <span class=\"c1\">;; CLHS 3.1.2.1.3 Self-Evaluating Objects</span>\n    <span class=\"p\">((</span><span class=\"nb\">atom</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nb\">exp</span><span class=\"p\">)</span>\n    <span class=\"c1\">;; CLHS 3.1.2.1.2 Conses as Forms</span>\n    <span class=\"p\">((</span><span class=\"nb\">consp</span> <span class=\"nb\">exp</span><span class=\"p\">)</span>\n     <span class=\"p\">(</span><span class=\"nb\">case</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nb\">exp</span><span class=\"p\">)</span>\n       <span class=\"c1\">;; CLHS 3.1.2.1.2.1 Special Forms</span>\n       <span class=\"p\">((</span><span class=\"k\">block</span><span class=\"p\">)</span>                <span class=\"p\">(</span><span class=\"nv\">eval-block</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n       <span class=\"p\">((</span><span class=\"k\">catch</span><span class=\"p\">)</span>                <span class=\"p\">(</span><span class=\"nv\">eval-catch</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n       <span class=\"c1\">;; special form が20個ぐらい続く</span>\n       <span class=\"c1\">;;</span>\n       <span class=\"c1\">;; (略)</span>\n       <span class=\"p\">(</span><span class=\"no\">t</span>\n        <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">dispatcher</span> <span class=\"p\">(</span><span class=\"nb\">getf</span> <span class=\"vg\">*eval-dispatch-functions*</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nb\">exp</span><span class=\"p\">))))</span>\n          <span class=\"p\">(</span><span class=\"nb\">cond</span>\n            <span class=\"p\">(</span><span class=\"nv\">dispatcher</span> <span class=\"c1\">; cltl2:compiler-let のための処理</span>\n             <span class=\"p\">(</span><span class=\"nb\">funcall</span> <span class=\"nv\">dispatcher</span> <span class=\"nb\">exp</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n            <span class=\"c1\">;; CLHS 3.1.2.1.2.4 Lambda Forms</span>\n            <span class=\"p\">((</span><span class=\"nb\">and</span> <span class=\"p\">(</span><span class=\"nb\">consp</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nb\">exp</span><span class=\"p\">))</span> <span class=\"p\">(</span><span class=\"nb\">eq</span> <span class=\"p\">(</span><span class=\"nb\">caar</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"ss\">&#39;lambda</span><span class=\"p\">))</span>\n             <span class=\"p\">(</span><span class=\"nv\">interpreted-apply</span> <span class=\"p\">(</span><span class=\"nv\">eval-function</span> <span class=\"p\">(</span><span class=\"nb\">list</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nb\">exp</span><span class=\"p\">))</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n                                <span class=\"p\">(</span><span class=\"nv\">eval-args</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nv\">env</span><span class=\"p\">)))</span>\n            <span class=\"p\">(</span><span class=\"no\">t</span>\n             <span class=\"p\">(</span><span class=\"nb\">multiple-value-bind</span> <span class=\"p\">(</span><span class=\"k\">function</span> <span class=\"nv\">kind</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">get-function</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n               <span class=\"p\">(</span><span class=\"nb\">ecase</span> <span class=\"nv\">kind</span>\n                 <span class=\"c1\">;; CLHS 3.1.2.1.2.3 Function Forms</span>\n                 <span class=\"p\">(</span><span class=\"ss\">:function</span> <span class=\"p\">(</span><span class=\"nv\">%apply</span> <span class=\"k\">function</span> <span class=\"p\">(</span><span class=\"nv\">eval-args</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nb\">exp</span><span class=\"p\">)</span> <span class=\"nv\">env</span><span class=\"p\">)))</span>\n                 <span class=\"c1\">;; CLHS 3.1.2.1.2.2 Macro Forms</span>\n                 <span class=\"p\">(</span><span class=\"ss\">:macro</span>\n                  <span class=\"c1\">;; **ここからがキモ**</span>\n                  <span class=\"c1\">;; **ここからがキモ**</span>\n                  <span class=\"p\">)))))))))))</span>\n</pre></div></div><p>ネストが深いので、キモだけを抜き出してみました。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">hook</span> <span class=\"vg\">*macroexpand-hook*</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nv\">%eval</span> <span class=\"p\">(</span><span class=\"nb\">funcall</span> <span class=\"nv\">hook</span>      <span class=\"c1\">; 展開</span>\n                  <span class=\"k\">function</span>\n                  <span class=\"nb\">exp</span>\n                  <span class=\"p\">(</span><span class=\"nv\">env-native-lexenv</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n         <span class=\"nv\">env</span><span class=\"p\">))</span>\n</pre></div></div><p>と、いうことで、やはり、1レベルだけ展開して、またeval するわけですね。なお、 <code>*macroexpand-hook*</code> は通常 <code>funcall</code> に束縛されています。</p>\n<h1>\n        <span id=\"1-5\" class=\"fragment\"></span>\n        <a href=\"#1-5\"><i class=\"fa fa-link\"></i></a>スタックの動き\n      </h1><p>上のコードを見ながら、はじめに扱ったコードを インタプリタがどのように実行するのか、考えてみましょう。すると、展開や評価におけるコールスタックの動き方が下の図のようなものだとわかります。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"c1\">;; eval するコード</span>\n<span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">x</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"nb\">plusp</span> <span class=\"nv\">x</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"ss\">:minus</span><span class=\"p\">)))</span>\n\n<span class=\"c1\">;; 展開してできるコード</span>\n<span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">x</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n  <span class=\"p\">(</span><span class=\"nv\">IF</span> <span class=\"p\">(</span><span class=\"nv\">NOT</span> <span class=\"p\">(</span><span class=\"nv\">PLUSP</span> <span class=\"nv\">X</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">PROGN</span> <span class=\"p\">(</span><span class=\"nv\">PRINT</span> <span class=\"ss\">:MINUS</span><span class=\"p\">))</span>\n      <span class=\"no\">NIL</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; コールスタック</span>\n<span class=\"p\">(</span><span class=\"nb\">eval</span>            <span class=\"c1\">; let</span>\n <span class=\"p\">(</span><span class=\"nb\">eval</span>           <span class=\"c1\">; my-unless</span>\n  <span class=\"p\">(</span><span class=\"nb\">macroexpand</span><span class=\"p\">)</span>  <span class=\"c1\">; my-unless -&gt; when -&gt; if</span>\n  <span class=\"p\">(</span><span class=\"nb\">eval</span>          <span class=\"c1\">; if</span>\n   <span class=\"p\">(</span><span class=\"nb\">eval</span> <span class=\"p\">(</span><span class=\"nb\">eval</span><span class=\"p\">))</span> <span class=\"c1\">; (not (plusp x))</span>\n   <span class=\"p\">(</span><span class=\"nb\">eval</span><span class=\"p\">))))</span>     <span class=\"c1\">; (progn ...) か NIL</span>\n</pre></div></div><p>evalのコールの途中に macroexpand が混じっている感じですね。もし展開するコードが２つ以上のマクロ展開を含んでいたらどうなるでしょうか。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"c1\">;; eval するコード</span>\n<span class=\"p\">(</span><span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"nb\">plusp</span> <span class=\"nv\">x</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nv\">my-unless</span> <span class=\"p\">(</span><span class=\"nb\">minusp</span> <span class=\"nv\">x</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"ss\">:zero</span><span class=\"p\">)))</span>  \n\n<span class=\"c1\">;; 展開してできるコード</span>\n<span class=\"p\">(</span><span class=\"nv\">IF</span> <span class=\"p\">(</span><span class=\"nv\">NOT</span> <span class=\"p\">(</span><span class=\"nv\">PLUSP</span> <span class=\"nv\">X</span><span class=\"p\">))</span>\n    <span class=\"p\">(</span><span class=\"nv\">PROGN</span>\n     <span class=\"p\">(</span><span class=\"nv\">IF</span> <span class=\"p\">(</span><span class=\"nv\">NOT</span> <span class=\"p\">(</span><span class=\"nv\">MINUSP</span> <span class=\"nv\">X</span><span class=\"p\">))</span>\n         <span class=\"p\">(</span><span class=\"nv\">PROGN</span> <span class=\"p\">(</span><span class=\"nv\">PRINT</span> <span class=\"ss\">:ZERO</span><span class=\"p\">))</span>\n         <span class=\"no\">NIL</span><span class=\"p\">))</span>\n    <span class=\"no\">NIL</span><span class=\"p\">)</span>\n\n<span class=\"c1\">;; コールスタック</span>\n<span class=\"p\">(</span><span class=\"nb\">eval</span>               <span class=\"c1\">; my-unless</span>\n <span class=\"p\">(</span><span class=\"nb\">macroexpand</span><span class=\"p\">)</span>      <span class=\"c1\">; my-unless -&gt; when -&gt; if</span>\n <span class=\"p\">(</span><span class=\"nb\">eval</span>              <span class=\"c1\">; if</span>\n  <span class=\"p\">(</span><span class=\"nb\">eval</span>             <span class=\"c1\">; (not (plusp))</span>\n   <span class=\"p\">(</span><span class=\"nb\">eval</span>            <span class=\"c1\">; my-unless</span>\n    <span class=\"p\">(</span><span class=\"nb\">macroexpand</span><span class=\"p\">)</span>   <span class=\"c1\">; my-unless -&gt; when -&gt; if</span>\n    <span class=\"p\">(</span><span class=\"nb\">eval</span> <span class=\"o\">...</span><span class=\"p\">)))))</span>  <span class=\"c1\">; (not (minusp))</span>\n</pre></div></div><p>ここで掲げたい重要事項が、各々のマクロ展開は独立しているということです。上のマクロ展開は、下のマクロ展開の時に、スタック上に残っていない。カッコでいって上にあるコードがどのようなものだったかという情報は、綺麗サッパリ消えてしまっています。コールスタックに残っていないからです。</p>\n<h1>\n        <span id=\"1-6\" class=\"fragment\"></span>\n        <a href=\"#1-6\"><i class=\"fa fa-link\"></i></a>局所マクロ -- macrolet で作ってみる --\n      </h1><p>上の仕様は、「賢い」局所マクロを実装する上の障害になります。局所マクロを実装する方法はすでにあるだろう、と思われるかもしれません。<code>macrolet</code> のことですね。でも、それではいけないのです。</p>\n<p>わかりやすい説明をするために、LOOPのような機能をもつ有名なユーティリティ <code>iterate</code> の簡易版を実装してみましょう。私が実装する簡易版 <code>iterate</code> は、だいたい以下のような構文を持ちます。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"c1\">;; iterate の簡易バージョン</span>\n    <span class=\"c1\">;; iter の中にいるばあい、</span>\n    <span class=\"c1\">;; while は 引数が true の時だけ実行を次の節に続けます。</span>\n    <span class=\"c1\">;; collect はその引数を内部的な変数に集め、iterの返り値にします。</span>\n    <span class=\"c1\">;; iter の外で使われた時は、for と collect はエラーを投げます。</span>\n\n    <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">i</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"nv\">i</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">incf</span> <span class=\"nv\">i</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"mi\">3</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mi\">4</span> <span class=\"nv\">i</span><span class=\"p\">)))))</span>\n</pre></div></div><p>これを <code>macrolet</code> だけで実装してみましょう。ざっとこんな感じ。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"nb\">define-condition</span> <span class=\"nv\">compile-error</span> <span class=\"p\">(</span><span class=\"kt\">simple-error</span><span class=\"p\">)</span>\n      <span class=\"p\">((</span><span class=\"nv\">message</span> <span class=\"ss\">:initarg</span> <span class=\"ss\">:message</span> <span class=\"ss\">:accessor</span> <span class=\"nv\">message</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"ss\">:report</span> <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nv\">c</span> <span class=\"nv\">s</span><span class=\"p\">)</span>\n                 <span class=\"p\">(</span><span class=\"nb\">princ</span> <span class=\"p\">(</span><span class=\"nv\">message</span> <span class=\"nv\">c</span><span class=\"p\">)</span> <span class=\"nv\">s</span><span class=\"p\">))))</span>\n\n    <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"k\">declare</span> <span class=\"p\">(</span><span class=\"k\">ignore</span> <span class=\"nv\">x</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nb\">error</span> <span class=\"ss\">&#39;compile-error</span>\n             <span class=\"ss\">:message</span> <span class=\"s\">&quot;`collect&#39; must be used under `iter&#39;&quot;</span><span class=\"p\">))</span>\n\n    <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"nv\">x</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"k\">declare</span> <span class=\"p\">(</span><span class=\"k\">ignore</span> <span class=\"nv\">x</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nb\">error</span> <span class=\"ss\">&#39;compile-error</span>\n             <span class=\"ss\">:message</span> <span class=\"s\">&quot;`while&#39; must be used under `iter&#39;&quot;</span><span class=\"p\">))</span>\n\n    <span class=\"p\">(</span><span class=\"nb\">require</span> <span class=\"ss\">:alexandria</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"nb\">use-package</span> <span class=\"ss\">:alexandria</span><span class=\"p\">)</span>\n\n    <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"k\">&amp;body</span> <span class=\"nv\">body</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">with-gensyms</span> <span class=\"p\">(</span><span class=\"nv\">iter-block</span> <span class=\"nv\">accumulate</span> <span class=\"nv\">start</span><span class=\"p\">)</span>\n        <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"k\">block</span> <span class=\"o\">,</span><span class=\"nv\">iter-block</span>\n           <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"o\">,</span><span class=\"nv\">accumulate</span> <span class=\"no\">nil</span><span class=\"p\">))</span>\n             <span class=\"p\">(</span><span class=\"k\">macrolet</span> <span class=\"p\">((</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"kt\">condition</span><span class=\"p\">)</span>\n                          <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">unless</span> <span class=\"o\">,</span><span class=\"kt\">condition</span>\n                             <span class=\"p\">(</span><span class=\"k\">return-from</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,iter-block</span>\n                               <span class=\"p\">(</span><span class=\"nb\">nreverse</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">))))</span>\n                        <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nv\">thing</span><span class=\"p\">)</span>\n                          <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">push</span> <span class=\"o\">,</span><span class=\"nv\">thing</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">)))</span>\n               <span class=\"p\">(</span><span class=\"k\">tagbody</span>\n                 <span class=\"o\">,</span><span class=\"nv\">start</span>\n                 <span class=\"o\">,@</span><span class=\"nv\">body</span>\n                 <span class=\"p\">(</span><span class=\"k\">go</span> <span class=\"o\">,</span><span class=\"nv\">start</span><span class=\"p\">)))))))</span>\n\n    <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">i</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"nv\">i</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">incf</span> <span class=\"nv\">i</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"mi\">3</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mi\">4</span> <span class=\"nv\">i</span><span class=\"p\">)))))</span>\n\n    <span class=\"c1\">;; --&gt; (7 11 15 19 23)</span>\n</pre></div></div><p>うん、まあうまく行ってますね。なんだ、やはり <code>macrolet</code> だけで十分じゃないかと。</p>\n<p>では、それと同じ感じで 本来の <code>iterate</code> にある<code>(collect x into acc)</code> の機能を作ってみましょう。これは、モノが蓄積される場所を明示的に指定できる機能です。</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>    (let ((i 0))\n      (iter (while (&lt; i 5))\n            (incf i)\n            (print acc) ; &lt;--\n            (collect (+ 3 (* 4 i)) :into acc))) ; &lt;--\n</pre></div></div><p>・・・できますか？ macroletだけで？ できないはずです。</p>\n<p>何らかの場所を明示的に指定するためには、その場所を束縛するように、ループ全体を <code>let</code> で囲まなくてはいけません。 <strong>でも、collect節が展開されるのは、iterが展開された後なのです。この点こそが致命的な弱点です。</strong></p>\n<h1>\n        <span id=\"1-7\" class=\"fragment\"></span>\n        <a href=\"#1-7\"><i class=\"fa fa-link\"></i></a>Macros in Common Lisp are still <em>restricted</em>\n      </h1><p>lisp以外の言語の使用者からすれば「はぁ、そうですか」となるかもしれませんが、まあど〜せそういった人々は対象ではありません。私が考える common lisp のマクロの致命的な弱点はこの点です。</p>\n<p><strong>マクロ展開が再帰的でない</strong></p>\n<p>マクロ展開は、 <strong>繰り返し</strong> によって行われます。CLHSですら、こう書いています。</p>\n\n<blockquote>\n<p> macroexpand <strong>repeatedly</strong> expands form until it is no longer a macro<br>\nform. In effect, macroexpand calls macroexpand-1 repeatedly until the<br>\nsecondary value it returns is nil. -- <a href=\"http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_macroexpa_acroexpand-1.html\" title=\"\" target=\"_blank\">CLHS Function MACROEXPAND, MACROEXPAND-1</a></p>\n</blockquote>\n<p>展開が再帰的で、上の展開がスタックに残っていれば、たとえば先ほど示した例に対応する <code>collect</code> の実装は、以下のように書くことができます。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nv\">thing</span> <span class=\"k\">&amp;key</span> <span class=\"nv\">into</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"nv\">into</span>\n          <span class=\"p\">(</span><span class=\"nb\">error</span> <span class=\"ss\">&#39;accumulate-target</span> <span class=\"ss\">:name</span> <span class=\"nv\">into</span><span class=\"p\">)</span> <span class=\"c1\">; コンパイルやり直し！</span>\n          <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">push</span> <span class=\"o\">,</span><span class=\"nv\">thing</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">)))</span>\n</pre></div></div><p>そして、 <code>iter</code> 展開時のハンドラでこのシグナルをキャッチするのです。たとえば、以下のような実装はどうでしょうか。<code>&amp;continuation cont</code> としてクロージャが与えられ、これを <code>funcall</code> を通して呼ぶことで、下層の <code>macroexpand</code> を呼ぶことができると考えましょう。スタックの下から登ってきた condition を、上のハンドラが受け取って、マクロ展開をやり直せます。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>   <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"k\">&amp;body</span> <span class=\"nv\">body</span> <span class=\"nv\">&amp;continuation</span> <span class=\"nv\">cont</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"nv\">with-gensyms</span> <span class=\"p\">(</span><span class=\"nv\">iter-block</span> <span class=\"nv\">accumulate</span> <span class=\"nv\">start</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">handler-case</span>\n            <span class=\"p\">(</span><span class=\"nb\">funcall</span> <span class=\"nf\">#&#39;</span><span class=\"nv\">cont</span>\n                     <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"k\">block</span> <span class=\"o\">,</span><span class=\"nv\">iter-block</span>\n                        <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"o\">,</span><span class=\"nv\">accumulate</span> <span class=\"no\">nil</span><span class=\"p\">))</span>\n                          <span class=\"p\">(</span><span class=\"k\">macrolet</span> <span class=\"p\">((</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"kt\">condition</span><span class=\"p\">)</span>\n                                       <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">unless</span> <span class=\"o\">,</span><span class=\"kt\">condition</span>\n                                          <span class=\"p\">(</span><span class=\"k\">return-from</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,iter-block</span>\n                                            <span class=\"p\">(</span><span class=\"nb\">nreverse</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">))))</span>\n                                     <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nv\">thing</span> <span class=\"k\">&amp;key</span> <span class=\"nv\">into</span><span class=\"p\">)</span>\n                                       <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"nv\">into</span>\n                                           <span class=\"p\">(</span><span class=\"nb\">signal</span> <span class=\"ss\">&#39;accumulate-target</span> <span class=\"ss\">:name</span> <span class=\"nv\">into</span><span class=\"p\">)</span>\n                                           <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">push</span> <span class=\"o\">,</span><span class=\"nv\">thing</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">))))</span>\n                            <span class=\"p\">(</span><span class=\"k\">tagbody</span>\n                              <span class=\"o\">,</span><span class=\"nv\">start</span>\n                              <span class=\"o\">,@</span><span class=\"nv\">body</span>\n                              <span class=\"p\">(</span><span class=\"k\">go</span> <span class=\"o\">,</span><span class=\"nv\">start</span><span class=\"p\">))))))</span>\n          <span class=\"c1\">;; handler</span>\n          <span class=\"p\">(</span><span class=\"nv\">accumulate-target</span> <span class=\"p\">(</span><span class=\"nv\">c</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nb\">setf</span> <span class=\"nv\">accumulate</span> <span class=\"p\">(</span><span class=\"nv\">name</span> <span class=\"nv\">c</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">funcall</span> <span class=\"nf\">#&#39;</span><span class=\"nv\">cont</span>\n                     <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"k\">block</span> <span class=\"o\">,</span><span class=\"nv\">iter-block</span>\n                        <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"o\">,</span><span class=\"nv\">accumulate</span> <span class=\"no\">nil</span><span class=\"p\">))</span>\n                          <span class=\"p\">(</span><span class=\"k\">macrolet</span> <span class=\"p\">((</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"kt\">condition</span><span class=\"p\">)</span>\n                                       <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">unless</span> <span class=\"o\">,</span><span class=\"kt\">condition</span>\n                                          <span class=\"p\">(</span><span class=\"k\">return-from</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,iter-block</span>\n                                            <span class=\"p\">(</span><span class=\"nb\">nreverse</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">))))</span>\n                                     <span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"p\">(</span><span class=\"nv\">thing</span> <span class=\"k\">&amp;key</span> <span class=\"nv\">into</span><span class=\"p\">)</span>\n                                       <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nb\">push</span> <span class=\"o\">,</span><span class=\"nv\">thing</span> <span class=\"o\">,</span><span class=\"ss\">&#39;,accumulate</span><span class=\"p\">)))</span>\n                            <span class=\"p\">(</span><span class=\"k\">tagbody</span>\n                              <span class=\"o\">,</span><span class=\"nv\">start</span>\n                              <span class=\"o\">,@</span><span class=\"nv\">body</span>\n                              <span class=\"p\">(</span><span class=\"k\">go</span> <span class=\"o\">,</span><span class=\"nv\">start</span><span class=\"p\">))))))))))</span>\n</pre></div></div><h1>\n        <span id=\"1-8\" class=\"fragment\"></span>\n        <a href=\"#1-8\"><i class=\"fa fa-link\"></i></a>Related Works\n      </h1><p>本物の <code>iterate</code> では、このようなことが行えないため、code walker を用いて <code>(collect ... into ...)</code> 節を検出しています。code walker がどう賢くないかというと、 <code>collect</code> などの節がマクロの中に現れてしまった時に困るという点です。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"c1\">;; 一階層隠蔽する</span>\n    <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">my-collect</span> <span class=\"p\">(</span><span class=\"k\">&amp;rest</span> <span class=\"nv\">args</span><span class=\"p\">)</span>\n      <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"o\">,@</span><span class=\"nv\">args</span><span class=\"p\">))</span>\n\n    <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">i</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"nv\">i</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">incf</span> <span class=\"nv\">i</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"nv\">acc</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nv\">my-collect</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"mi\">3</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mi\">4</span> <span class=\"nv\">i</span><span class=\"p\">))</span> <span class=\"nv\">into</span> <span class=\"nv\">acc</span><span class=\"p\">)))</span>\n</pre></div></div><p><code>iterate</code> の code walker は、すべての <code>collect</code> 節を漏らさず検出するために、 <code>iter</code> 以下のすべてのマクロを展開する必要があります。しかし、それには限界があります。iterateは、iter節の中に現れた macrolet を展開できません。つまり、 macrolet の中にある <code>while</code> や <code>collect</code> は code walker に見過ごされます。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"nb\">require</span> <span class=\"ss\">:iterate</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"nb\">in-package</span> <span class=\"ss\">:iterate</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">i</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"nv\">while</span> <span class=\"p\">(</span><span class=\"nb\">&lt;</span> <span class=\"nv\">i</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">incf</span> <span class=\"nv\">i</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nb\">print</span> <span class=\"nv\">acc</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"k\">macrolet</span> <span class=\"p\">((</span><span class=\"nv\">my-collect</span> <span class=\"p\">(</span><span class=\"k\">&amp;rest</span> <span class=\"nv\">args</span><span class=\"p\">)</span>\n                         <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nv\">collect</span> <span class=\"o\">,@</span><span class=\"nv\">args</span><span class=\"p\">)))</span>\n              <span class=\"p\">(</span><span class=\"nv\">my-collect</span> <span class=\"p\">(</span><span class=\"nb\">+</span> <span class=\"mi\">3</span> <span class=\"p\">(</span><span class=\"nb\">*</span> <span class=\"mi\">4</span> <span class=\"nv\">i</span><span class=\"p\">))</span> <span class=\"nv\">into</span> <span class=\"nv\">acc</span><span class=\"p\">))))</span>\n\n    <span class=\"c1\">; in: LET ((I 0)) ...</span>\n    <span class=\"c1\">; </span>\n    <span class=\"c1\">; caught WARNING:</span>\n    <span class=\"c1\">;   Iterate:</span>\n    <span class=\"c1\">;   Iterate does not know how to handle </span>\n    <span class=\"c1\">;     the special form (MACROLET ...)</span>\n    <span class=\"c1\">;   It will not be walked, which means that Iterate clauses</span>\n    <span class=\"c1\">;   inside it will not be seen.</span>\n    <span class=\"c1\">;</span>\n    <span class=\"c1\">; compilation unit finished</span>\n    <span class=\"c1\">;   Undefined function:</span>\n    <span class=\"c1\">;     COLLECT</span>\n    <span class=\"c1\">;   Undefined variables:</span>\n    <span class=\"c1\">;     ACC INTO</span>\n</pre></div></div><p>これは、実質的には ANSI CLの問題です。実は、cltl2 の <code>augment-environment</code> を使えば、macrolet を認識して展開することができます。</p>\n\n<blockquote>\n<p>[Function] augment-environment env &amp;key</p>\n<p>:variable :symbol-macro :function :macro :declare</p>\n<p>:macro</p>\n<p>The argument is a list of local macro definitions, each of the form (name definition). Note that the argument is <strong>not</strong> in the same format as the cadr of a macrolet special form. Each definition must be a function of two arguments (a form and an environment). The new environment will have local macro bindings of each name to the corresponding expander function, which will be returned by macro-function and used by macroexpand.</p>\n<p><a href=\"http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node102.html\" title=\"\" target=\"_blank\">CLTL2 8.5 Environment</a></p>\n</blockquote>\n<p>これによって、</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"nb\">defmacro</span> <span class=\"nv\">iter</span> <span class=\"p\">(</span><span class=\"o\">...</span> <span class=\"k\">&amp;environment</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n      <span class=\"o\">...</span>\n      <span class=\"p\">(</span><span class=\"nv\">walk-code</span> <span class=\"o\">...</span> <span class=\"nv\">env</span><span class=\"p\">))</span>\n\n    <span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">walk-code</span> <span class=\"p\">(</span><span class=\"nv\">form</span> <span class=\"nv\">env</span><span class=\"p\">)</span>\n      <span class=\"o\">...</span>\n      <span class=\"p\">(</span><span class=\"nb\">when</span> <span class=\"p\">(</span><span class=\"nb\">eq</span> <span class=\"ss\">&#39;macrolet</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">form</span><span class=\"p\">))</span>\n        <span class=\"p\">(</span><span class=\"nb\">destructuring-bind</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">macros</span> <span class=\"o\">.</span> <span class=\"nv\">body</span><span class=\"p\">)</span> <span class=\"nv\">form</span>\n          <span class=\"p\">(</span><span class=\"k\">declare</span> <span class=\"p\">(</span><span class=\"k\">ignore</span> <span class=\"nb\">car</span><span class=\"p\">))</span>\n          <span class=\"p\">(</span><span class=\"nv\">walk-code</span>\n            <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"k\">progn</span> <span class=\"o\">,@</span><span class=\"nv\">body</span><span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"nv\">augment-environment</span>\n             <span class=\"nv\">env</span>\n             <span class=\"ss\">:macro</span> <span class=\"p\">(</span><span class=\"nv\">make-macro-functions</span> <span class=\"nv\">macros</span><span class=\"p\">))))))</span>\n</pre></div></div><p>と、まあこのように、macrolet を 普通のマクロと同じように展開できるはずです。ただしもう一度ですが、これは cltl2 に頼ることになります。</p>\n<p>しかしそもそも、 walk-code は、letやtagbody、blockやcatch など、スペシャルフォームを認識して、すべて理解し直さなくてはなりません。それってすっっっっごく頭が悪いと思いませんか?Common Lisp にはもとからevalやcompileなど、スペシャルフォームをネイティブコードまたはバイトコードに変換してくれる便利な関数が存在しています。なぜ、二度同じものを書きなおさなくてはならないのでしょうか?</p>\n<p>それに、結局このwalk-codeは以下のmacroexpand の中で行われるわけです。つまり、そのあとのevalが、展開したスペシャルフォームと関数フォームをもう一度解析し直す -- つまり、マクロの有無をもう一度確認するわけです。これはとても非効率ではないでしょうか？</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"nb\">eval</span>            <span class=\"c1\">; let</span>\n     <span class=\"p\">(</span><span class=\"nb\">eval</span>           <span class=\"c1\">; iter</span>\n      <span class=\"p\">(</span><span class=\"nb\">macroexpand</span><span class=\"p\">)</span>  <span class=\"c1\">; iterを展開 (中でwalk-codeを呼ぶ)</span>\n      <span class=\"p\">(</span><span class=\"nb\">eval</span><span class=\"p\">)))</span>       <span class=\"c1\">; 展開したコードをまた読み込み直す -- マクロのチェックもする</span>\n</pre></div></div><p>また、その他の例もあります。たとえば以下のような例。</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre>    <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">x</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n      <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">y</span> <span class=\"nv\">x</span><span class=\"p\">))</span>\n        <span class=\"p\">(</span><span class=\"k\">declare</span> <span class=\"p\">(</span><span class=\"kt\">fixnum</span> <span class=\"nv\">y</span><span class=\"p\">))</span>\n        <span class=\"o\">...</span><span class=\"p\">))</span>\n</pre></div></div><p>letは実際にはマクロではありませんが、仮にマクロだと考えてください。この例では、yの方がfixnumであると言われています。しかし、yはxから直接コピーしたものです。マクロ展開をバックトラックして、 <strong>xの型も</strong> fixnumであると宣言したくなりませんか？</p>\n<p>似たような応用例はいろいろと考えられます。上に挙げた例は、ソースコードの最適化という操作に大きな効果をもたらすわけですが、これを一般化すると、「ソースコード(カッコ)の内側から、より大域的な環境に制約(=型情報など)を伝播させることができる」というわけです。今までのマクロシステムではそのようなことはできませんでした。そのため、この種の最適化は処理系独自の拡張 (sbclならば <code>deftransform</code> など)によってしか不可能だったのではないかと思います。</p>\n<h1>\n        <span id=\"1-9\" class=\"fragment\"></span>\n        <a href=\"#1-9\"><i class=\"fa fa-link\"></i></a>結論\n      </h1><p>現状のマクロ展開は、</p>\n<div class=\"code-frame\" data-lang=\"text\"><div class=\"highlight\"><pre>macroexpand -&gt; eval -...-&gt; eval -&gt; macroexpand -...-&gt;\n</pre></div></div><p>のように、一部を展開しては次へ評価するという形をとります。その途中で、「以前にmacroexpandを行った」という情報はスタックから消えてしまうため、コンディションシステムを用いてマクロ展開前の状態に戻ることはできなくなります。これは、マクロの可能性をかなり制限します。</p>\n<p>この記事では、より良いマクロシステムの設計として、「展開自体は最初に再帰的にすべて行ってしまい、展開しつくしたコードを評価ないしバイトコード・ネイティブコードコンパイルする」といった形式を提唱しました。また、そのようなマクロシステムを使えば、処理系の特殊な実装に頼ることなく、局所的なコードからより大域的な制約を推論することができることを示しました。</p>\n<p>以上、反応をお待ちしています。</p>\n",
        "stock_users": [
            "Viarofka",
            "zqwell@github",
            "tsu034",
            "repeatedly",
            "iriya-ufo@github",
            "peketamin",
            "stibear",
            "kencoba",
            "taiki45",
            "JunSuzukiJapan@github",
            "JuanitoFatas"
        ]
    },
    {
        "id": 41022,
        "uuid": "02271e23607640e70669",
        "user": {
            "id": 6090,
            "url_name": "guicho271828",
            "profile_image_url": "https://pbs.twimg.com/profile_images/378800000809306716/dbd9008f86c426eb255aadb7fb0b9769_normal.jpeg"
        },
        "title": "optimaクローン つくりました",
        "created_at": "2014-01-14 20:18:58 +0900",
        "updated_at": "2014-01-14 21:24:46 +0900",
        "created_at_in_words": "8ヶ月",
        "updated_at_in_words": "8ヶ月",
        "tags": [
            {
                "name": "common-lisp",
                "url_name": "common-lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/745b73901dc247fd2b064c1766a7bcd8037cd5a7/medium.jpg?1364838584",
                "versions": []
            },
            {
                "name": "アルゴリズム",
                "url_name": "%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/a8b610e5601d4adba9dc33dd95be3be00ce1800d/medium.jpg?1387910607",
                "versions": []
            },
            {
                "name": "lisp",
                "url_name": "lisp",
                "icon_url": "https://s3-ap-northeast-1.amazonaws.com/qiita-tag-image/6585c47135a6144c0387f0ce5c4a8613907f2017/medium.jpg?1387911086",
                "versions": []
            }
        ],
        "stock_count": 0,
        "comment_count": 1,
        "url": "http://qiita.com/guicho271828/items/02271e23607640e70669",
        "created_at_as_seconds": 1389698338,
        "tweet": true,
        "gist_url": null,
        "private": false,
        "raw_body": "論文の締め切りが思っていたより先だったので気が抜けてしまい、こんなのつくっていました。\n\nhttps://github.com/guicho271828/optima2\n\nなぜ作ったのかというと、主に遅延評価オブジェクトをoptimaで簡単にマッチさせたかったからですね。\n\n自分の作業中、\nn要素の集合からm要素の集合への適切な対応付けが欲しかったのですが、(n,mは5~15程度)\n気張った枝刈りとかは面倒くさかったので、全探索でやろうとしたんですね。\nそう、permutationを作ったんです。n個からm個への。そしたら、簡単に想像が付くとおり、\nメモリが爆発して処理系がハングアップします。\nでも枝刈りのことを考えるのは面倒、遅延評価にすればとりあえずメモリ爆発は逃れられる。\n\nしかし、optimaでthunkをマッチさせるのは[こういう](http://qiita.com/guicho271828/items/c51cb19ce3736c0f6c4c)hackをするか、あるいはoptima.ppcreのようにoptima内部オブジェクトを触らないといけなかったわけです。クリーンじゃない。よしつくろう！と、まあそういう感じです。\n\nあとは・・・\n\n+ 以前からoptimaベースのユニフィケーションライブラリを作りたいと思っていたのですが、optimaはエラー処理・リスタートがそんなにたくさん準備されているわけではないので、pullreqを投げてみたりしてみたものの、実装もそんなに綺麗ではなく、受理されませんでした。自分で書けばそういう問題は起こらない、と。\n\n+ ほかにも、ARRAYのマッチングがあります。これもつくってみてpullreq投げたのですが・・・。\n\n\nコードを殆ど一から書きなおしたので、最適化度合いはoptimaにまったく及びません。従って、実用には\nまだ辛いかと思います。ただ、optima付属のtestは(ほぼ)全部通りました。test scriptは無断でマルマル借り物なので、m2ymさんには感謝です。テストスクリプトってユーザからのissuesの反映の積み重ねなので、LLGPLとはいえこれを丸パクしてしまったのはすこしズルをしている感があります。\n\n主な違いについてはリンク先をどうぞ。\n\n追記：thunk は optima2では[このように](https://github.com/guicho271828/optima2#constructor-pattern)書けます:\n\n```cl\n(defpattern thunk (forced-var)\n  `(constructor (function () t) #'functionp\n                ,(if (place-pattern-p car)\n                     (error \"thunk object cannot be overwritten\")\n                     `(:reader #'funcall ,forced-var))))\n```\n\nconstructor パターンは type と predicate の両方を指定するようになっていますが、\ntypeをチェックした後に predicate を呼び出します。\nただし、predicate呼び出し部分はlocally にtype指定、inline指定かつ(optimize (speed 3))指定されるので、sbclなどの速い実装では呼び出しを消してくれる可能性もあります。\n\n今後の課題は、fabrice et.al. の4,5,6章にみられる以下の手法の実装。\n\n+ optimized mixture rule\n+ Using exhaustiveness information\n+ Optimizing exits\n+ Aggressive control flow optimization\n+ Better OR pattern compilation\n\n",
        "body": "<p>論文の締め切りが思っていたより先だったので気が抜けてしまい、こんなのつくっていました。</p>\n<p><a href=\"https://github.com/guicho271828/optima2\" title=\"https://github.com/guicho271828/optima2\" target=\"_blank\">https://github.com/guicho271828/optima2</a></p>\n<p>なぜ作ったのかというと、主に遅延評価オブジェクトをoptimaで簡単にマッチさせたかったからですね。</p>\n<p>自分の作業中、<br>\nn要素の集合からm要素の集合への適切な対応付けが欲しかったのですが、(n,mは5~15程度)<br>\n気張った枝刈りとかは面倒くさかったので、全探索でやろうとしたんですね。<br>\nそう、permutationを作ったんです。n個からm個への。そしたら、簡単に想像が付くとおり、<br>\nメモリが爆発して処理系がハングアップします。<br>\nでも枝刈りのことを考えるのは面倒、遅延評価にすればとりあえずメモリ爆発は逃れられる。</p>\n<p>しかし、optimaでthunkをマッチさせるのは<a href=\"http://qiita.com/guicho271828/items/c51cb19ce3736c0f6c4c\" title=\"\">こういう</a>hackをするか、あるいはoptima.ppcreのようにoptima内部オブジェクトを触らないといけなかったわけです。クリーンじゃない。よしつくろう！と、まあそういう感じです。</p>\n<p>あとは・・・</p>\n\n<ul>\n<li><p>以前からoptimaベースのユニフィケーションライブラリを作りたいと思っていたのですが、optimaはエラー処理・リスタートがそんなにたくさん準備されているわけではないので、pullreqを投げてみたりしてみたものの、実装もそんなに綺麗ではなく、受理されませんでした。自分で書けばそういう問題は起こらない、と。</p>\n</li><li><p>ほかにも、ARRAYのマッチングがあります。これもつくってみてpullreq投げたのですが・・・。</p>\n</li></ul>\n<p>コードを殆ど一から書きなおしたので、最適化度合いはoptimaにまったく及びません。従って、実用には<br>\nまだ辛いかと思います。ただ、optima付属のtestは(ほぼ)全部通りました。test scriptは無断でマルマル借り物なので、m2ymさんには感謝です。テストスクリプトってユーザからのissuesの反映の積み重ねなので、LLGPLとはいえこれを丸パクしてしまったのはすこしズルをしている感があります。</p>\n<p>主な違いについてはリンク先をどうぞ。</p>\n<p>追記：thunk は optima2では<a href=\"https://github.com/guicho271828/optima2#constructor-pattern\" title=\"\" target=\"_blank\">このように</a>書けます:</p>\n<div class=\"code-frame\" data-lang=\"cl\"><div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nv\">defpattern</span> <span class=\"nv\">thunk</span> <span class=\"p\">(</span><span class=\"nv\">forced-var</span><span class=\"p\">)</span>\n  <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nv\">constructor</span> <span class=\"p\">(</span><span class=\"k\">function</span> <span class=\"p\">()</span> <span class=\"no\">t</span><span class=\"p\">)</span> <span class=\"nf\">#&#39;</span><span class=\"nb\">functionp</span>\n                <span class=\"o\">,</span><span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">place-pattern-p</span> <span class=\"nb\">car</span><span class=\"p\">)</span>\n                     <span class=\"p\">(</span><span class=\"nb\">error</span> <span class=\"s\">&quot;thunk object cannot be overwritten&quot;</span><span class=\"p\">)</span>\n                     <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"ss\">:reader</span> <span class=\"nf\">#&#39;</span><span class=\"nb\">funcall</span> <span class=\"o\">,</span><span class=\"nv\">forced-var</span><span class=\"p\">))))</span>\n</pre></div></div><p>constructor パターンは type と predicate の両方を指定するようになっていますが、<br>\ntypeをチェックした後に predicate を呼び出します。<br>\nただし、predicate呼び出し部分はlocally にtype指定、inline指定かつ(optimize (speed 3))指定されるので、sbclなどの速い実装では呼び出しを消してくれる可能性もあります。</p>\n<p>今後の課題は、fabrice et.al. の4,5,6章にみられる以下の手法の実装。</p>\n\n<ul>\n<li>optimized mixture rule\n</li><li>Using exhaustiveness information\n</li><li>Optimizing exits\n</li><li>Aggressive control flow optimization\n</li><li>Better OR pattern compilation\n</li></ul>\n",
        "stock_users": []
    }
]